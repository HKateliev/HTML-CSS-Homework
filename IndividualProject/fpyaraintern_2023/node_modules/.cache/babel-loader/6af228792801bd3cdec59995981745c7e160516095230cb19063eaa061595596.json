{"ast":null,"code":"'use strict';\n\nconst BB = require('bluebird');\nconst cacache = require('cacache');\nconst cacheKey = require('../util/cache-key');\nconst Fetcher = require('../fetch');\nconst git = require('../util/git');\nconst mkdirp = BB.promisify(require('mkdirp'));\nconst pickManifest = require('npm-pick-manifest');\nconst optCheck = require('../util/opt-check');\nconst osenv = require('osenv');\nconst packDir = require('../util/pack-dir');\nconst PassThrough = require('stream').PassThrough;\nconst path = require('path');\nconst pipe = BB.promisify(require('mississippi').pipe);\nconst rimraf = BB.promisify(require('rimraf'));\nconst uniqueFilename = require('unique-filename');\n\n// `git` dependencies are fetched from git repositories and packed up.\nconst fetchGit = module.exports = Object.create(null);\nFetcher.impl(fetchGit, {\n  packument(spec, opts) {\n    return BB.reject(new Error('Not implemented yet.'));\n  },\n  manifest(spec, opts) {\n    opts = optCheck(opts);\n    if (spec.hosted && spec.hosted.getDefaultRepresentation() === 'shortcut') {\n      return hostedManifest(spec, opts);\n    } else {\n      // If it's not a shortcut, don't do fallbacks.\n      return plainManifest(spec.fetchSpec, spec, opts);\n    }\n  },\n  tarball(spec, opts) {\n    opts = optCheck(opts);\n    const stream = new PassThrough();\n    this.manifest(spec, opts).then(manifest => {\n      stream.emit('manifest', manifest);\n      return pipe(this.fromManifest(manifest, spec, opts).on('integrity', i => stream.emit('integrity', i)), stream);\n    }).catch(err => stream.emit('error', err));\n    return stream;\n  },\n  fromManifest(manifest, spec, opts) {\n    opts = optCheck(opts);\n    let streamError;\n    const stream = new PassThrough().on('error', e => {\n      streamError = e;\n    });\n    const cacheName = manifest._uniqueResolved || manifest._resolved || '';\n    const cacheStream = opts.cache && cacache.get.stream(opts.cache, cacheKey('packed-dir', cacheName), opts).on('integrity', i => stream.emit('integrity', i));\n    cacheStream.pipe(stream);\n    cacheStream.on('error', err => {\n      if (err.code !== 'ENOENT') {\n        return stream.emit('error', err);\n      } else {\n        stream.emit('reset');\n        return withTmp(opts, tmp => {\n          if (streamError) {\n            throw streamError;\n          }\n          return cloneRepo(spec, manifest._repo, manifest._ref, manifest._rawRef, tmp, opts).then(HEAD => {\n            if (streamError) {\n              throw streamError;\n            }\n            manifest._resolved = spec.saveSpec.replace(/(:?#.*)?$/, `#${HEAD}`);\n            manifest._uniqueResolved = manifest._resolved;\n            return packDir(manifest, manifest._uniqueResolved, tmp, stream, opts);\n          });\n        }).catch(err => stream.emit('error', err));\n      }\n    });\n    return stream;\n  }\n});\nfunction hostedManifest(spec, opts) {\n  return BB.resolve(null).then(() => {\n    if (!spec.hosted.git()) {\n      throw new Error(`No git url for ${spec}`);\n    }\n    return plainManifest(spec.hosted.git(), spec, opts);\n  }).catch(err => {\n    if (!spec.hosted.https()) {\n      throw err;\n    }\n    return plainManifest(spec.hosted.https(), spec, opts);\n  }).catch(err => {\n    if (!spec.hosted.sshurl()) {\n      throw err;\n    }\n    return plainManifest(spec.hosted.sshurl(), spec, opts);\n  });\n}\nfunction plainManifest(repo, spec, opts) {\n  const rawRef = spec.gitCommittish || spec.gitRange;\n  return resolve(repo, spec, spec.name, opts).then(ref => {\n    if (ref) {\n      const resolved = spec.saveSpec.replace(/(?:#.*)?$/, `#${ref.sha}`);\n      return {\n        _repo: repo,\n        _resolved: resolved,\n        _spec: spec,\n        _ref: ref,\n        _rawRef: spec.gitCommittish || spec.gitRange,\n        _uniqueResolved: resolved,\n        _integrity: false,\n        _shasum: false\n      };\n    } else {\n      // We're SOL and need a full clone :(\n      //\n      // If we're confident enough that `rawRef` is a commit SHA,\n      // then we can at least get `finalize-manifest` to cache its result.\n      const resolved = spec.saveSpec.replace(/(?:#.*)?$/, rawRef ? `#${rawRef}` : '');\n      return {\n        _repo: repo,\n        _rawRef: rawRef,\n        _resolved: rawRef && rawRef.match(/^[a-f0-9]{40}$/) && resolved,\n        _uniqueResolved: rawRef && rawRef.match(/^[a-f0-9]{40}$/) && resolved,\n        _integrity: false,\n        _shasum: false\n      };\n    }\n  });\n}\nfunction resolve(url, spec, name, opts) {\n  const isSemver = !!spec.gitRange;\n  return git.revs(url, opts).then(remoteRefs => {\n    return isSemver ? pickManifest({\n      versions: remoteRefs.versions,\n      'dist-tags': remoteRefs['dist-tags'],\n      name: name\n    }, spec.gitRange, opts) : remoteRefs ? BB.resolve(remoteRefs.refs[spec.gitCommittish] || remoteRefs.refs[remoteRefs.shas[spec.gitCommittish]]) : null;\n  });\n}\nfunction withTmp(opts, cb) {\n  if (opts.cache) {\n    // cacache has a special facility for working in a tmp dir\n    return cacache.tmp.withTmp(opts.cache, {\n      tmpPrefix: 'git-clone'\n    }, cb);\n  } else {\n    const tmpDir = path.join(osenv.tmpdir(), 'pacote-git-tmp');\n    const tmpName = uniqueFilename(tmpDir, 'git-clone');\n    const tmp = mkdirp(tmpName).then(() => tmpName).disposer(rimraf);\n    return BB.using(tmp, cb);\n  }\n}\n\n// Only certain whitelisted hosted gits support shadow cloning\nconst SHALLOW_HOSTS = new Set(['github', 'gist', 'gitlab', 'bitbucket']);\nfunction cloneRepo(spec, repo, resolvedRef, rawRef, tmp, opts) {\n  const ref = resolvedRef ? resolvedRef.ref : rawRef;\n  if (resolvedRef && spec.hosted && SHALLOW_HOSTS.has(spec.hosted.type)) {\n    return git.shallow(repo, ref, tmp, opts);\n  } else {\n    return git.clone(repo, ref, tmp, opts);\n  }\n}","map":{"version":3,"names":["BB","require","cacache","cacheKey","Fetcher","git","mkdirp","promisify","pickManifest","optCheck","osenv","packDir","PassThrough","path","pipe","rimraf","uniqueFilename","fetchGit","module","exports","Object","create","impl","packument","spec","opts","reject","Error","manifest","hosted","getDefaultRepresentation","hostedManifest","plainManifest","fetchSpec","tarball","stream","then","emit","fromManifest","on","i","catch","err","streamError","e","cacheName","_uniqueResolved","_resolved","cacheStream","cache","get","code","withTmp","tmp","cloneRepo","_repo","_ref","_rawRef","HEAD","saveSpec","replace","resolve","https","sshurl","repo","rawRef","gitCommittish","gitRange","name","ref","resolved","sha","_spec","_integrity","_shasum","match","url","isSemver","revs","remoteRefs","versions","refs","shas","cb","tmpPrefix","tmpDir","join","tmpdir","tmpName","disposer","using","SHALLOW_HOSTS","Set","resolvedRef","has","type","shallow","clone"],"sources":["/Users/hkateliev/node_modules/npm/node_modules/pacote/lib/fetchers/git.js"],"sourcesContent":["'use strict'\n\nconst BB = require('bluebird')\n\nconst cacache = require('cacache')\nconst cacheKey = require('../util/cache-key')\nconst Fetcher = require('../fetch')\nconst git = require('../util/git')\nconst mkdirp = BB.promisify(require('mkdirp'))\nconst pickManifest = require('npm-pick-manifest')\nconst optCheck = require('../util/opt-check')\nconst osenv = require('osenv')\nconst packDir = require('../util/pack-dir')\nconst PassThrough = require('stream').PassThrough\nconst path = require('path')\nconst pipe = BB.promisify(require('mississippi').pipe)\nconst rimraf = BB.promisify(require('rimraf'))\nconst uniqueFilename = require('unique-filename')\n\n// `git` dependencies are fetched from git repositories and packed up.\nconst fetchGit = module.exports = Object.create(null)\n\nFetcher.impl(fetchGit, {\n  packument (spec, opts) {\n    return BB.reject(new Error('Not implemented yet.'))\n  },\n\n  manifest (spec, opts) {\n    opts = optCheck(opts)\n    if (spec.hosted && spec.hosted.getDefaultRepresentation() === 'shortcut') {\n      return hostedManifest(spec, opts)\n    } else {\n      // If it's not a shortcut, don't do fallbacks.\n      return plainManifest(spec.fetchSpec, spec, opts)\n    }\n  },\n\n  tarball (spec, opts) {\n    opts = optCheck(opts)\n    const stream = new PassThrough()\n    this.manifest(spec, opts).then(manifest => {\n      stream.emit('manifest', manifest)\n      return pipe(\n        this.fromManifest(\n          manifest, spec, opts\n        ).on('integrity', i => stream.emit('integrity', i)), stream\n      )\n    }).catch(err => stream.emit('error', err))\n    return stream\n  },\n\n  fromManifest (manifest, spec, opts) {\n    opts = optCheck(opts)\n    let streamError\n    const stream = new PassThrough().on('error', e => { streamError = e })\n    const cacheName = manifest._uniqueResolved || manifest._resolved || ''\n    const cacheStream = (\n      opts.cache &&\n      cacache.get.stream(\n        opts.cache, cacheKey('packed-dir', cacheName), opts\n      ).on('integrity', i => stream.emit('integrity', i))\n    )\n    cacheStream.pipe(stream)\n    cacheStream.on('error', err => {\n      if (err.code !== 'ENOENT') {\n        return stream.emit('error', err)\n      } else {\n        stream.emit('reset')\n        return withTmp(opts, tmp => {\n          if (streamError) { throw streamError }\n          return cloneRepo(\n            spec, manifest._repo, manifest._ref, manifest._rawRef, tmp, opts\n          ).then(HEAD => {\n            if (streamError) { throw streamError }\n            manifest._resolved = spec.saveSpec.replace(/(:?#.*)?$/, `#${HEAD}`)\n            manifest._uniqueResolved = manifest._resolved\n            return packDir(manifest, manifest._uniqueResolved, tmp, stream, opts)\n          })\n        }).catch(err => stream.emit('error', err))\n      }\n    })\n    return stream\n  }\n})\n\nfunction hostedManifest (spec, opts) {\n  return BB.resolve(null).then(() => {\n    if (!spec.hosted.git()) {\n      throw new Error(`No git url for ${spec}`)\n    }\n    return plainManifest(spec.hosted.git(), spec, opts)\n  }).catch(err => {\n    if (!spec.hosted.https()) {\n      throw err\n    }\n    return plainManifest(spec.hosted.https(), spec, opts)\n  }).catch(err => {\n    if (!spec.hosted.sshurl()) {\n      throw err\n    }\n    return plainManifest(spec.hosted.sshurl(), spec, opts)\n  })\n}\n\nfunction plainManifest (repo, spec, opts) {\n  const rawRef = spec.gitCommittish || spec.gitRange\n  return resolve(\n    repo, spec, spec.name, opts\n  ).then(ref => {\n    if (ref) {\n      const resolved = spec.saveSpec.replace(/(?:#.*)?$/, `#${ref.sha}`)\n      return {\n        _repo: repo,\n        _resolved: resolved,\n        _spec: spec,\n        _ref: ref,\n        _rawRef: spec.gitCommittish || spec.gitRange,\n        _uniqueResolved: resolved,\n        _integrity: false,\n        _shasum: false\n      }\n    } else {\n      // We're SOL and need a full clone :(\n      //\n      // If we're confident enough that `rawRef` is a commit SHA,\n      // then we can at least get `finalize-manifest` to cache its result.\n      const resolved = spec.saveSpec.replace(/(?:#.*)?$/, rawRef ? `#${rawRef}` : '')\n      return {\n        _repo: repo,\n        _rawRef: rawRef,\n        _resolved: rawRef && rawRef.match(/^[a-f0-9]{40}$/) && resolved,\n        _uniqueResolved: rawRef && rawRef.match(/^[a-f0-9]{40}$/) && resolved,\n        _integrity: false,\n        _shasum: false\n      }\n    }\n  })\n}\n\nfunction resolve (url, spec, name, opts) {\n  const isSemver = !!spec.gitRange\n  return git.revs(url, opts).then(remoteRefs => {\n    return isSemver\n      ? pickManifest({\n        versions: remoteRefs.versions,\n        'dist-tags': remoteRefs['dist-tags'],\n        name: name\n      }, spec.gitRange, opts)\n      : remoteRefs\n        ? BB.resolve(\n          remoteRefs.refs[spec.gitCommittish] || remoteRefs.refs[remoteRefs.shas[spec.gitCommittish]]\n        )\n        : null\n  })\n}\n\nfunction withTmp (opts, cb) {\n  if (opts.cache) {\n    // cacache has a special facility for working in a tmp dir\n    return cacache.tmp.withTmp(opts.cache, { tmpPrefix: 'git-clone' }, cb)\n  } else {\n    const tmpDir = path.join(osenv.tmpdir(), 'pacote-git-tmp')\n    const tmpName = uniqueFilename(tmpDir, 'git-clone')\n    const tmp = mkdirp(tmpName).then(() => tmpName).disposer(rimraf)\n    return BB.using(tmp, cb)\n  }\n}\n\n// Only certain whitelisted hosted gits support shadow cloning\nconst SHALLOW_HOSTS = new Set(['github', 'gist', 'gitlab', 'bitbucket'])\nfunction cloneRepo (spec, repo, resolvedRef, rawRef, tmp, opts) {\n  const ref = resolvedRef ? resolvedRef.ref : rawRef\n  if (resolvedRef && spec.hosted && SHALLOW_HOSTS.has(spec.hosted.type)) {\n    return git.shallow(repo, ref, tmp, opts)\n  } else {\n    return git.clone(repo, ref, tmp, opts)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}