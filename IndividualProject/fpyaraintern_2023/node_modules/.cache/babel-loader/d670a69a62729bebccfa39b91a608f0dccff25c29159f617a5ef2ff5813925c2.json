{"ast":null,"code":"'use strict';\n\nmodule.exports = isOnlyDev;\nconst moduleName = require('../utils/module-name.js');\nconst isDevDep = require('./is-dev-dep.js');\nconst isProdDep = require('./is-prod-dep.js');\n\n// Returns true if the module `node` is only required direcctly as a dev\n// dependency of the top level or transitively _from_ top level dev\n// dependencies.\n// Dual mode modules (that are both dev AND prod) should return false.\nfunction isOnlyDev(node, seen) {\n  if (!seen) seen = new Set();\n  return node.requiredBy.length && node.requiredBy.every(andIsOnlyDev(moduleName(node), seen));\n}\n\n// There is a known limitation with this implementation: If a dependency is\n// ONLY required by cycles that are detached from the top level then it will\n// ultimately return true.\n//\n// This is ok though: We don't allow shrinkwraps with extraneous deps and\n// these situation is caught by the extraneous checker before we get here.\nfunction andIsOnlyDev(name, seen) {\n  return function (req) {\n    const isDev = isDevDep(req, name);\n    const isProd = isProdDep(req, name);\n    if (req.isTop) {\n      return isDev && !isProd;\n    } else {\n      if (seen.has(req)) return true;\n      seen.add(req);\n      const result = isOnlyDev(req, seen);\n      seen.delete(req);\n      return result;\n    }\n  };\n}","map":{"version":3,"names":["module","exports","isOnlyDev","moduleName","require","isDevDep","isProdDep","node","seen","Set","requiredBy","length","every","andIsOnlyDev","name","req","isDev","isProd","isTop","has","add","result","delete"],"sources":["/Users/hkateliev/node_modules/npm/lib/install/is-only-dev.js"],"sourcesContent":["'use strict'\nmodule.exports = isOnlyDev\n\nconst moduleName = require('../utils/module-name.js')\nconst isDevDep = require('./is-dev-dep.js')\nconst isProdDep = require('./is-prod-dep.js')\n\n// Returns true if the module `node` is only required direcctly as a dev\n// dependency of the top level or transitively _from_ top level dev\n// dependencies.\n// Dual mode modules (that are both dev AND prod) should return false.\nfunction isOnlyDev (node, seen) {\n  if (!seen) seen = new Set()\n  return node.requiredBy.length && node.requiredBy.every(andIsOnlyDev(moduleName(node), seen))\n}\n\n// There is a known limitation with this implementation: If a dependency is\n// ONLY required by cycles that are detached from the top level then it will\n// ultimately return true.\n//\n// This is ok though: We don't allow shrinkwraps with extraneous deps and\n// these situation is caught by the extraneous checker before we get here.\nfunction andIsOnlyDev (name, seen) {\n  return function (req) {\n    const isDev = isDevDep(req, name)\n    const isProd = isProdDep(req, name)\n    if (req.isTop) {\n      return isDev && !isProd\n    } else {\n      if (seen.has(req)) return true\n      seen.add(req)\n      const result = isOnlyDev(req, seen)\n      seen.delete(req)\n      return result\n    }\n  }\n}\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,OAAO,GAAGC,SAAS;AAE1B,MAAMC,UAAU,GAAGC,OAAO,CAAC,yBAAyB,CAAC;AACrD,MAAMC,QAAQ,GAAGD,OAAO,CAAC,iBAAiB,CAAC;AAC3C,MAAME,SAAS,GAAGF,OAAO,CAAC,kBAAkB,CAAC;;AAE7C;AACA;AACA;AACA;AACA,SAASF,SAASA,CAAEK,IAAI,EAAEC,IAAI,EAAE;EAC9B,IAAI,CAACA,IAAI,EAAEA,IAAI,GAAG,IAAIC,GAAG,EAAE;EAC3B,OAAOF,IAAI,CAACG,UAAU,CAACC,MAAM,IAAIJ,IAAI,CAACG,UAAU,CAACE,KAAK,CAACC,YAAY,CAACV,UAAU,CAACI,IAAI,CAAC,EAAEC,IAAI,CAAC,CAAC;AAC9F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASK,YAAYA,CAAEC,IAAI,EAAEN,IAAI,EAAE;EACjC,OAAO,UAAUO,GAAG,EAAE;IACpB,MAAMC,KAAK,GAAGX,QAAQ,CAACU,GAAG,EAAED,IAAI,CAAC;IACjC,MAAMG,MAAM,GAAGX,SAAS,CAACS,GAAG,EAAED,IAAI,CAAC;IACnC,IAAIC,GAAG,CAACG,KAAK,EAAE;MACb,OAAOF,KAAK,IAAI,CAACC,MAAM;IACzB,CAAC,MAAM;MACL,IAAIT,IAAI,CAACW,GAAG,CAACJ,GAAG,CAAC,EAAE,OAAO,IAAI;MAC9BP,IAAI,CAACY,GAAG,CAACL,GAAG,CAAC;MACb,MAAMM,MAAM,GAAGnB,SAAS,CAACa,GAAG,EAAEP,IAAI,CAAC;MACnCA,IAAI,CAACc,MAAM,CAACP,GAAG,CAAC;MAChB,OAAOM,MAAM;IACf;EACF,CAAC;AACH"},"metadata":{},"sourceType":"script","externalDependencies":[]}