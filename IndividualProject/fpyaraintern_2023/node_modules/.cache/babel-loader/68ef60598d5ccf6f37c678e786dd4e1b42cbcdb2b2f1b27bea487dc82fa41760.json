{"ast":null,"code":"'use strict';\n\n/**\n * index.js\n *\n * a request API compatible with window.fetch\n */\nconst url = require('url');\nconst http = require('http');\nconst https = require('https');\nconst zlib = require('zlib');\nconst PassThrough = require('stream').PassThrough;\nconst Body = require('./body.js');\nconst writeToStream = Body.writeToStream;\nconst Response = require('./response');\nconst Headers = require('./headers');\nconst Request = require('./request');\nconst getNodeRequestOptions = Request.getNodeRequestOptions;\nconst FetchError = require('./fetch-error');\nconst isURL = /^https?:/;\n\n/**\n * Fetch function\n *\n * @param   Mixed    url   Absolute url or Request instance\n * @param   Object   opts  Fetch options\n * @return  Promise\n */\nexports = module.exports = fetch;\nfunction fetch(uri, opts) {\n  // allow custom promise\n  if (!fetch.Promise) {\n    throw new Error('native promise missing, set fetch.Promise to your favorite alternative');\n  }\n  Body.Promise = fetch.Promise;\n\n  // wrap http.request into fetch\n  return new fetch.Promise((resolve, reject) => {\n    // build request object\n    const request = new Request(uri, opts);\n    const options = getNodeRequestOptions(request);\n    const send = (options.protocol === 'https:' ? https : http).request;\n\n    // http.request only support string as host header, this hack make custom host header possible\n    if (options.headers.host) {\n      options.headers.host = options.headers.host[0];\n    }\n\n    // send request\n    const req = send(options);\n    let reqTimeout;\n    if (request.timeout) {\n      req.once('socket', socket => {\n        reqTimeout = setTimeout(() => {\n          req.abort();\n          reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));\n        }, request.timeout);\n      });\n    }\n    req.on('error', err => {\n      clearTimeout(reqTimeout);\n      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));\n    });\n    req.on('response', res => {\n      clearTimeout(reqTimeout);\n\n      // handle redirect\n      if (fetch.isRedirect(res.statusCode) && request.redirect !== 'manual') {\n        if (request.redirect === 'error') {\n          reject(new FetchError(`redirect mode is set to error: ${request.url}`, 'no-redirect'));\n          return;\n        }\n        if (request.counter >= request.follow) {\n          reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n          return;\n        }\n        if (!res.headers.location) {\n          reject(new FetchError(`redirect location header missing at: ${request.url}`, 'invalid-redirect'));\n          return;\n        }\n        // Remove authorization if changing hostnames (but not if just\n        // changing ports or protocols).  This matches the behavior of request:\n        // https://github.com/request/request/blob/b12a6245/lib/redirect.js#L134-L138\n        const resolvedUrl = url.resolve(request.url, res.headers.location);\n        let redirectURL = '';\n        if (!isURL.test(res.headers.location)) {\n          redirectURL = url.parse(resolvedUrl);\n        } else {\n          redirectURL = url.parse(res.headers.location);\n        }\n        if (url.parse(request.url).hostname !== redirectURL.hostname) {\n          request.headers.delete('authorization');\n        }\n\n        // per fetch spec, for POST request with 301/302 response, or any request with 303 response, use GET when following redirect\n        if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {\n          request.method = 'GET';\n          request.body = null;\n          request.headers.delete('content-length');\n        }\n        request.counter++;\n        resolve(fetch(resolvedUrl, request));\n        return;\n      }\n\n      // normalize location header for manual redirect mode\n      const headers = new Headers();\n      for (const name of Object.keys(res.headers)) {\n        if (Array.isArray(res.headers[name])) {\n          for (const val of res.headers[name]) {\n            headers.append(name, val);\n          }\n        } else {\n          headers.append(name, res.headers[name]);\n        }\n      }\n      if (request.redirect === 'manual' && headers.has('location')) {\n        headers.set('location', url.resolve(request.url, headers.get('location')));\n      }\n\n      // prepare response\n      let body = res.pipe(new PassThrough());\n      const responseOptions = {\n        url: request.url,\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: headers,\n        size: request.size,\n        timeout: request.timeout\n      };\n\n      // HTTP-network fetch step 16.1.2\n      const codings = headers.get('Content-Encoding');\n\n      // HTTP-network fetch step 16.1.3: handle content codings\n\n      // in following scenarios we ignore compression support\n      // 1. compression support is disabled\n      // 2. HEAD request\n      // 3. no Content-Encoding header\n      // 4. no content response (204)\n      // 5. content not modified response (304)\n      if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n        resolve(new Response(body, responseOptions));\n        return;\n      }\n\n      // Be less strict when decoding compressed responses, since sometimes\n      // servers send slightly invalid responses that are still accepted\n      // by common browsers.\n      // Always using Z_SYNC_FLUSH is what cURL does.\n      const zlibOptions = {\n        flush: zlib.Z_SYNC_FLUSH,\n        finishFlush: zlib.Z_SYNC_FLUSH\n      };\n\n      // for gzip\n      if (codings === 'gzip' || codings === 'x-gzip') {\n        body = body.pipe(zlib.createGunzip(zlibOptions));\n        resolve(new Response(body, responseOptions));\n        return;\n      }\n\n      // for deflate\n      if (codings === 'deflate' || codings === 'x-deflate') {\n        // handle the infamous raw deflate response from old servers\n        // a hack for old IIS and Apache servers\n        const raw = res.pipe(new PassThrough());\n        raw.once('data', chunk => {\n          // see http://stackoverflow.com/questions/37519828\n          if ((chunk[0] & 0x0F) === 0x08) {\n            body = body.pipe(zlib.createInflate(zlibOptions));\n          } else {\n            body = body.pipe(zlib.createInflateRaw(zlibOptions));\n          }\n          resolve(new Response(body, responseOptions));\n        });\n        return;\n      }\n\n      // otherwise, use response as-is\n      resolve(new Response(body, responseOptions));\n    });\n    writeToStream(req, request);\n  });\n}\n;\n\n/**\n * Redirect code matching\n *\n * @param   Number   code  Status code\n * @return  Boolean\n */\nfetch.isRedirect = code => code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n\n// expose Promise\nfetch.Promise = global.Promise;\nexports.Headers = Headers;\nexports.Request = Request;\nexports.Response = Response;\nexports.FetchError = FetchError;","map":{"version":3,"names":["url","require","http","https","zlib","PassThrough","Body","writeToStream","Response","Headers","Request","getNodeRequestOptions","FetchError","isURL","exports","module","fetch","uri","opts","Promise","Error","resolve","reject","request","options","send","protocol","headers","host","req","reqTimeout","timeout","once","socket","setTimeout","abort","on","err","clearTimeout","message","res","isRedirect","statusCode","redirect","counter","follow","location","resolvedUrl","redirectURL","test","parse","hostname","delete","method","body","name","Object","keys","Array","isArray","val","append","has","set","get","pipe","responseOptions","status","statusText","statusMessage","size","codings","compress","zlibOptions","flush","Z_SYNC_FLUSH","finishFlush","createGunzip","raw","chunk","createInflate","createInflateRaw","code","global"],"sources":["/Users/hkateliev/node_modules/npm/node_modules/node-fetch-npm/src/index.js"],"sourcesContent":["'use strict'\n\n/**\n * index.js\n *\n * a request API compatible with window.fetch\n */\n\nconst url = require('url')\nconst http = require('http')\nconst https = require('https')\nconst zlib = require('zlib')\nconst PassThrough = require('stream').PassThrough\n\nconst Body = require('./body.js')\nconst writeToStream = Body.writeToStream\nconst Response = require('./response')\nconst Headers = require('./headers')\nconst Request = require('./request')\nconst getNodeRequestOptions = Request.getNodeRequestOptions\nconst FetchError = require('./fetch-error')\nconst isURL = /^https?:/\n\n/**\n * Fetch function\n *\n * @param   Mixed    url   Absolute url or Request instance\n * @param   Object   opts  Fetch options\n * @return  Promise\n */\nexports = module.exports = fetch\nfunction fetch (uri, opts) {\n  // allow custom promise\n  if (!fetch.Promise) {\n    throw new Error('native promise missing, set fetch.Promise to your favorite alternative')\n  }\n\n  Body.Promise = fetch.Promise\n\n  // wrap http.request into fetch\n  return new fetch.Promise((resolve, reject) => {\n    // build request object\n    const request = new Request(uri, opts)\n    const options = getNodeRequestOptions(request)\n\n    const send = (options.protocol === 'https:' ? https : http).request\n\n    // http.request only support string as host header, this hack make custom host header possible\n    if (options.headers.host) {\n      options.headers.host = options.headers.host[0]\n    }\n\n    // send request\n    const req = send(options)\n    let reqTimeout\n\n    if (request.timeout) {\n      req.once('socket', socket => {\n        reqTimeout = setTimeout(() => {\n          req.abort()\n          reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'))\n        }, request.timeout)\n      })\n    }\n\n    req.on('error', err => {\n      clearTimeout(reqTimeout)\n      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err))\n    })\n\n    req.on('response', res => {\n      clearTimeout(reqTimeout)\n\n      // handle redirect\n      if (fetch.isRedirect(res.statusCode) && request.redirect !== 'manual') {\n        if (request.redirect === 'error') {\n          reject(new FetchError(`redirect mode is set to error: ${request.url}`, 'no-redirect'))\n          return\n        }\n\n        if (request.counter >= request.follow) {\n          reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'))\n          return\n        }\n\n        if (!res.headers.location) {\n          reject(new FetchError(`redirect location header missing at: ${request.url}`, 'invalid-redirect'))\n          return\n        }\n        // Remove authorization if changing hostnames (but not if just\n        // changing ports or protocols).  This matches the behavior of request:\n        // https://github.com/request/request/blob/b12a6245/lib/redirect.js#L134-L138\n        const resolvedUrl = url.resolve(request.url, res.headers.location)\n        let redirectURL = ''\n        if (!isURL.test(res.headers.location)) {\n          redirectURL = url.parse(resolvedUrl)\n        } else {\n          redirectURL = url.parse(res.headers.location)\n        }\n        if (url.parse(request.url).hostname !== redirectURL.hostname) {\n          request.headers.delete('authorization')\n        }\n\n        // per fetch spec, for POST request with 301/302 response, or any request with 303 response, use GET when following redirect\n        if (res.statusCode === 303 ||\n          ((res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST')) {\n          request.method = 'GET'\n          request.body = null\n          request.headers.delete('content-length')\n        }\n\n        request.counter++\n\n        resolve(fetch(resolvedUrl, request))\n        return\n      }\n\n      // normalize location header for manual redirect mode\n      const headers = new Headers()\n      for (const name of Object.keys(res.headers)) {\n        if (Array.isArray(res.headers[name])) {\n          for (const val of res.headers[name]) {\n            headers.append(name, val)\n          }\n        } else {\n          headers.append(name, res.headers[name])\n        }\n      }\n      if (request.redirect === 'manual' && headers.has('location')) {\n        headers.set('location', url.resolve(request.url, headers.get('location')))\n      }\n\n      // prepare response\n      let body = res.pipe(new PassThrough())\n      const responseOptions = {\n        url: request.url,\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: headers,\n        size: request.size,\n        timeout: request.timeout\n      }\n\n      // HTTP-network fetch step 16.1.2\n      const codings = headers.get('Content-Encoding')\n\n      // HTTP-network fetch step 16.1.3: handle content codings\n\n      // in following scenarios we ignore compression support\n      // 1. compression support is disabled\n      // 2. HEAD request\n      // 3. no Content-Encoding header\n      // 4. no content response (204)\n      // 5. content not modified response (304)\n      if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n        resolve(new Response(body, responseOptions))\n        return\n      }\n\n      // Be less strict when decoding compressed responses, since sometimes\n      // servers send slightly invalid responses that are still accepted\n      // by common browsers.\n      // Always using Z_SYNC_FLUSH is what cURL does.\n      const zlibOptions = {\n        flush: zlib.Z_SYNC_FLUSH,\n        finishFlush: zlib.Z_SYNC_FLUSH\n      }\n\n      // for gzip\n      if (codings === 'gzip' || codings === 'x-gzip') {\n        body = body.pipe(zlib.createGunzip(zlibOptions))\n        resolve(new Response(body, responseOptions))\n        return\n      }\n\n      // for deflate\n      if (codings === 'deflate' || codings === 'x-deflate') {\n        // handle the infamous raw deflate response from old servers\n        // a hack for old IIS and Apache servers\n        const raw = res.pipe(new PassThrough())\n        raw.once('data', chunk => {\n          // see http://stackoverflow.com/questions/37519828\n          if ((chunk[0] & 0x0F) === 0x08) {\n            body = body.pipe(zlib.createInflate(zlibOptions))\n          } else {\n            body = body.pipe(zlib.createInflateRaw(zlibOptions))\n          }\n          resolve(new Response(body, responseOptions))\n        })\n        return\n      }\n\n      // otherwise, use response as-is\n      resolve(new Response(body, responseOptions))\n    })\n\n    writeToStream(req, request)\n  })\n};\n\n/**\n * Redirect code matching\n *\n * @param   Number   code  Status code\n * @return  Boolean\n */\nfetch.isRedirect = code => code === 301 || code === 302 || code === 303 || code === 307 || code === 308\n\n// expose Promise\nfetch.Promise = global.Promise\nexports.Headers = Headers\nexports.Request = Request\nexports.Response = Response\nexports.FetchError = FetchError\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}