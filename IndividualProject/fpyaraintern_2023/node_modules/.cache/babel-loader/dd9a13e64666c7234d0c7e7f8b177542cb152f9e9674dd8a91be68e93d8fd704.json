{"ast":null,"code":"const fs = require('fs');\n/* istanbul ignore next */\nconst promisify = require('util').promisify || require('util-promisify');\nconst {\n  resolve,\n  basename,\n  dirname,\n  join\n} = require('path');\nconst rpj = promisify(require('read-package-json'));\nconst readdir = promisify(require('readdir-scoped-modules'));\nconst realpath = require('./realpath.js');\nlet ID = 0;\nclass Node {\n  constructor(pkg, logical, physical, er, cache) {\n    // should be impossible.\n    const cached = cache.get(physical);\n    /* istanbul ignore next */\n    if (cached && !cached.then) throw new Error('re-creating already instantiated node');\n    cache.set(physical, this);\n    const parent = basename(dirname(logical));\n    if (parent.charAt(0) === '@') this.name = `${parent}/${basename(logical)}`;else this.name = basename(logical);\n    this.path = logical;\n    this.realpath = physical;\n    this.error = er;\n    this.id = ID++;\n    this.package = pkg || {};\n    this.parent = null;\n    this.isLink = false;\n    this.children = [];\n  }\n}\nclass Link extends Node {\n  constructor(pkg, logical, physical, realpath, er, cache) {\n    super(pkg, logical, physical, er, cache);\n\n    // if the target has started, but not completed, then\n    // a Promise will be in the cache to indicate this.\n    const cachedTarget = cache.get(realpath);\n    if (cachedTarget && cachedTarget.then) cachedTarget.then(node => {\n      this.target = node;\n      this.children = node.children;\n    });\n    this.target = cachedTarget || new Node(pkg, logical, realpath, er, cache);\n    this.realpath = realpath;\n    this.isLink = true;\n    this.error = er;\n    this.children = this.target.children;\n  }\n}\n\n// this is the way it is to expose a timing issue which is difficult to\n// test otherwise.  The creation of a Node may take slightly longer than\n// the creation of a Link that targets it.  If the Node has _begun_ its\n// creation phase (and put a Promise in the cache) then the Link will\n// get a Promise as its cachedTarget instead of an actual Node object.\n// This is not a problem, because it gets resolved prior to returning\n// the tree or attempting to load children.  However, it IS remarkably\n// difficult to get to happen in a test environment to verify reliably.\n// Hence this kludge.\nconst newNode = (pkg, logical, physical, er, cache) => process.env._TEST_RPT_SLOW_LINK_TARGET_ === '1' ? new Promise(res => setTimeout(() => res(new Node(pkg, logical, physical, er, cache)), 10)) : new Node(pkg, logical, physical, er, cache);\nconst loadNode = (logical, physical, cache, rpcache, stcache) => {\n  // cache temporarily holds a promise placeholder so we\n  // don't try to create the same node multiple times.\n  // this is very rare to encounter, given the aggressive\n  // caching on fs.realpath and fs.lstat calls, but\n  // it can happen in theory.\n  const cached = cache.get(physical);\n  /* istanbul ignore next */\n  if (cached) return Promise.resolve(cached);\n  const p = realpath(physical, rpcache, stcache, 0).then(real => rpj(join(real, 'package.json')).then(pkg => [pkg, null], er => [null, er]).then(_ref => {\n    let [pkg, er] = _ref;\n    return physical === real ? newNode(pkg, logical, physical, er, cache) : new Link(pkg, logical, physical, real, er, cache);\n  }),\n  // if the realpath fails, don't bother with the rest\n  er => new Node(null, logical, physical, er, cache));\n  cache.set(physical, p);\n  return p;\n};\nconst loadChildren = (node, cache, filterWith, rpcache, stcache) => {\n  // if a Link target has started, but not completed, then\n  // a Promise will be in the cache to indicate this.\n  //\n  // XXX When we can one day loadChildren on the link *target* instead of\n  // the link itself, to match real dep resolution, then we may end up with\n  // a node target in the cache that isn't yet done resolving when we get\n  // here.  For now, though, this line will never be reached, so it's hidden\n  //\n  // if (node.then)\n  //   return node.then(node => loadChildren(node, cache, filterWith, rpcache, stcache))\n\n  const nm = join(node.path, 'node_modules');\n  return realpath(nm, rpcache, stcache, 0).then(rm => readdir(rm).then(kids => [rm, kids])).then(_ref2 => {\n    let [rm, kids] = _ref2;\n    return Promise.all(kids.filter(kid => kid.charAt(0) !== '.' && (!filterWith || filterWith(node, kid))).map(kid => loadNode(join(nm, kid), join(rm, kid), cache, rpcache, stcache)));\n  }).then(kidNodes => {\n    kidNodes.forEach(k => k.parent = node);\n    node.children.push.apply(node.children, kidNodes.sort((a, b) => (a.package.name ? a.package.name.toLowerCase() : a.path).localeCompare(b.package.name ? b.package.name.toLowerCase() : b.path)));\n    return node;\n  }).catch(() => node);\n};\nconst loadTree = (node, did, cache, filterWith, rpcache, stcache) => {\n  // impossible except in pathological ELOOP cases\n  /* istanbul ignore next */\n  if (did.has(node.realpath)) return Promise.resolve(node);\n  did.add(node.realpath);\n\n  // load children on the target, not the link\n  return loadChildren(node, cache, filterWith, rpcache, stcache).then(node => Promise.all(node.children.filter(kid => !did.has(kid.realpath)).map(kid => loadTree(kid, did, cache, filterWith, rpcache, stcache)))).then(() => node);\n};\n\n// XXX Drop filterWith and/or cb in next semver major bump\nconst rpt = (root, filterWith, cb) => {\n  if (!cb && typeof filterWith === 'function') {\n    cb = filterWith;\n    filterWith = null;\n  }\n  const cache = new Map();\n  // we can assume that the cwd is real enough\n  const cwd = process.cwd();\n  const rpcache = new Map([[cwd, cwd]]);\n  const stcache = new Map();\n  const p = realpath(root, rpcache, stcache, 0).then(realRoot => loadNode(root, realRoot, cache, rpcache, stcache)).then(node => loadTree(node, new Set(), cache, filterWith, rpcache, stcache));\n  if (typeof cb === 'function') p.then(tree => cb(null, tree), cb);\n  return p;\n};\nrpt.Node = Node;\nrpt.Link = Link;\nmodule.exports = rpt;","map":{"version":3,"names":["fs","require","promisify","resolve","basename","dirname","join","rpj","readdir","realpath","ID","Node","constructor","pkg","logical","physical","er","cache","cached","get","then","Error","set","parent","charAt","name","path","error","id","package","isLink","children","Link","cachedTarget","node","target","newNode","process","env","_TEST_RPT_SLOW_LINK_TARGET_","Promise","res","setTimeout","loadNode","rpcache","stcache","p","real","_ref","loadChildren","filterWith","nm","rm","kids","_ref2","all","filter","kid","map","kidNodes","forEach","k","push","apply","sort","a","b","toLowerCase","localeCompare","catch","loadTree","did","has","add","rpt","root","cb","Map","cwd","realRoot","Set","tree","module","exports"],"sources":["/Users/hkateliev/node_modules/npm/node_modules/read-package-tree/rpt.js"],"sourcesContent":["const fs = require('fs')\n/* istanbul ignore next */\nconst promisify = require('util').promisify || require('util-promisify')\nconst { resolve, basename, dirname, join } = require('path')\nconst rpj = promisify(require('read-package-json'))\nconst readdir = promisify(require('readdir-scoped-modules'))\nconst realpath = require('./realpath.js')\n\nlet ID = 0\nclass Node {\n  constructor (pkg, logical, physical, er, cache) {\n    // should be impossible.\n    const cached = cache.get(physical)\n    /* istanbul ignore next */\n    if (cached && !cached.then)\n      throw new Error('re-creating already instantiated node')\n\n    cache.set(physical, this)\n\n    const parent = basename(dirname(logical))\n    if (parent.charAt(0) === '@')\n      this.name = `${parent}/${basename(logical)}`\n    else\n      this.name = basename(logical)\n    this.path = logical\n    this.realpath = physical\n    this.error = er\n    this.id = ID++\n    this.package = pkg || {}\n    this.parent = null\n    this.isLink = false\n    this.children = []\n  }\n}\n\nclass Link extends Node {\n  constructor (pkg, logical, physical, realpath, er, cache) {\n    super(pkg, logical, physical, er, cache)\n\n    // if the target has started, but not completed, then\n    // a Promise will be in the cache to indicate this.\n    const cachedTarget = cache.get(realpath)\n    if (cachedTarget && cachedTarget.then)\n      cachedTarget.then(node => {\n        this.target = node\n        this.children = node.children\n      })\n\n    this.target = cachedTarget || new Node(pkg, logical, realpath, er, cache)\n    this.realpath = realpath\n    this.isLink = true\n    this.error = er\n    this.children = this.target.children\n  }\n}\n\n// this is the way it is to expose a timing issue which is difficult to\n// test otherwise.  The creation of a Node may take slightly longer than\n// the creation of a Link that targets it.  If the Node has _begun_ its\n// creation phase (and put a Promise in the cache) then the Link will\n// get a Promise as its cachedTarget instead of an actual Node object.\n// This is not a problem, because it gets resolved prior to returning\n// the tree or attempting to load children.  However, it IS remarkably\n// difficult to get to happen in a test environment to verify reliably.\n// Hence this kludge.\nconst newNode = (pkg, logical, physical, er, cache) =>\n  process.env._TEST_RPT_SLOW_LINK_TARGET_ === '1'\n    ? new Promise(res => setTimeout(() =>\n      res(new Node(pkg, logical, physical, er, cache)), 10))\n    : new Node(pkg, logical, physical, er, cache)\n\nconst loadNode = (logical, physical, cache, rpcache, stcache) => {\n  // cache temporarily holds a promise placeholder so we\n  // don't try to create the same node multiple times.\n  // this is very rare to encounter, given the aggressive\n  // caching on fs.realpath and fs.lstat calls, but\n  // it can happen in theory.\n  const cached = cache.get(physical)\n  /* istanbul ignore next */\n  if (cached)\n    return Promise.resolve(cached)\n\n  const p = realpath(physical, rpcache, stcache, 0).then(real =>\n    rpj(join(real, 'package.json'))\n      .then(pkg => [pkg, null], er => [null, er])\n      .then(([pkg, er]) =>\n        physical === real ? newNode(pkg, logical, physical, er, cache)\n        : new Link(pkg, logical, physical, real, er, cache)\n      ),\n    // if the realpath fails, don't bother with the rest\n    er => new Node(null, logical, physical, er, cache))\n\n  cache.set(physical, p)\n  return p\n}\n\nconst loadChildren = (node, cache, filterWith, rpcache, stcache) => {\n  // if a Link target has started, but not completed, then\n  // a Promise will be in the cache to indicate this.\n  //\n  // XXX When we can one day loadChildren on the link *target* instead of\n  // the link itself, to match real dep resolution, then we may end up with\n  // a node target in the cache that isn't yet done resolving when we get\n  // here.  For now, though, this line will never be reached, so it's hidden\n  //\n  // if (node.then)\n  //   return node.then(node => loadChildren(node, cache, filterWith, rpcache, stcache))\n\n  const nm = join(node.path, 'node_modules')\n  return realpath(nm, rpcache, stcache, 0)\n    .then(rm => readdir(rm).then(kids => [rm, kids]))\n    .then(([rm, kids]) => Promise.all(\n      kids.filter(kid =>\n        kid.charAt(0) !== '.' && (!filterWith || filterWith(node, kid)))\n      .map(kid => loadNode(join(nm, kid), join(rm, kid), cache, rpcache, stcache)))\n    ).then(kidNodes => {\n      kidNodes.forEach(k => k.parent = node)\n      node.children.push.apply(node.children, kidNodes.sort((a, b) =>\n        (a.package.name ? a.package.name.toLowerCase() : a.path)\n        .localeCompare(\n          (b.package.name ? b.package.name.toLowerCase() : b.path)\n        )))\n      return node\n    })\n    .catch(() => node)\n}\n\nconst loadTree = (node, did, cache, filterWith, rpcache, stcache) => {\n  // impossible except in pathological ELOOP cases\n  /* istanbul ignore next */\n  if (did.has(node.realpath))\n    return Promise.resolve(node)\n\n  did.add(node.realpath)\n\n  // load children on the target, not the link\n  return loadChildren(node, cache, filterWith, rpcache, stcache)\n    .then(node => Promise.all(\n      node.children\n        .filter(kid => !did.has(kid.realpath))\n        .map(kid => loadTree(kid, did, cache, filterWith, rpcache, stcache))\n    )).then(() => node)\n}\n\n// XXX Drop filterWith and/or cb in next semver major bump\nconst rpt = (root, filterWith, cb) => {\n  if (!cb && typeof filterWith === 'function') {\n    cb = filterWith\n    filterWith = null\n  }\n\n  const cache = new Map()\n  // we can assume that the cwd is real enough\n  const cwd = process.cwd()\n  const rpcache = new Map([[ cwd, cwd ]])\n  const stcache = new Map()\n  const p = realpath(root, rpcache, stcache, 0)\n    .then(realRoot => loadNode(root, realRoot, cache, rpcache, stcache))\n    .then(node => loadTree(node, new Set(), cache, filterWith, rpcache, stcache))\n\n  if (typeof cb === 'function')\n    p.then(tree => cb(null, tree), cb)\n\n  return p\n}\n\nrpt.Node = Node\nrpt.Link = Link\nmodule.exports = rpt\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}