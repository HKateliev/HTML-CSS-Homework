{"ast":null,"code":"'use strict';\n\n// rfc7231 6.1\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar statusCodeCacheableByDefault = [200, 203, 204, 206, 300, 301, 404, 405, 410, 414, 501];\n\n// This implementation does not understand partial responses (206)\nvar understoodStatuses = [200, 203, 204, 300, 301, 302, 303, 307, 308, 404, 405, 410, 414, 501];\nvar hopByHopHeaders = {\n  'connection': true,\n  'keep-alive': true,\n  'proxy-authenticate': true,\n  'proxy-authorization': true,\n  'te': true,\n  'trailer': true,\n  'transfer-encoding': true,\n  'upgrade': true\n};\nvar excludedFromRevalidationUpdate = {\n  // Since the old body is reused, it doesn't make sense to change properties of the body\n  'content-length': true,\n  'content-encoding': true,\n  'transfer-encoding': true,\n  'content-range': true\n};\nfunction parseCacheControl(header) {\n  var cc = {};\n  if (!header) return cc;\n\n  // TODO: When there is more than one value present for a given directive (e.g., two Expires header fields, multiple Cache-Control: max-age directives),\n  // the directive's value is considered invalid. Caches are encouraged to consider responses that have invalid freshness information to be stale\n  var parts = header.trim().split(/\\s*,\\s*/); // TODO: lame parsing\n  for (var _iterator = parts, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n    var part = _ref;\n    var _part$split = part.split(/\\s*=\\s*/, 2),\n      k = _part$split[0],\n      v = _part$split[1];\n    cc[k] = v === undefined ? true : v.replace(/^\"|\"$/g, ''); // TODO: lame unquoting\n  }\n\n  return cc;\n}\nfunction formatCacheControl(cc) {\n  var parts = [];\n  for (var k in cc) {\n    var v = cc[k];\n    parts.push(v === true ? k : k + '=' + v);\n  }\n  if (!parts.length) {\n    return undefined;\n  }\n  return parts.join(', ');\n}\nmodule.exports = function () {\n  function CachePolicy(req, res) {\n    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      shared = _ref2.shared,\n      cacheHeuristic = _ref2.cacheHeuristic,\n      immutableMinTimeToLive = _ref2.immutableMinTimeToLive,\n      ignoreCargoCult = _ref2.ignoreCargoCult,\n      _fromObject = _ref2._fromObject;\n    _classCallCheck(this, CachePolicy);\n    if (_fromObject) {\n      this._fromObject(_fromObject);\n      return;\n    }\n    if (!res || !res.headers) {\n      throw Error(\"Response headers missing\");\n    }\n    this._assertRequestHasHeaders(req);\n    this._responseTime = this.now();\n    this._isShared = shared !== false;\n    this._cacheHeuristic = undefined !== cacheHeuristic ? cacheHeuristic : 0.1; // 10% matches IE\n    this._immutableMinTtl = undefined !== immutableMinTimeToLive ? immutableMinTimeToLive : 24 * 3600 * 1000;\n    this._status = 'status' in res ? res.status : 200;\n    this._resHeaders = res.headers;\n    this._rescc = parseCacheControl(res.headers['cache-control']);\n    this._method = 'method' in req ? req.method : 'GET';\n    this._url = req.url;\n    this._host = req.headers.host;\n    this._noAuthorization = !req.headers.authorization;\n    this._reqHeaders = res.headers.vary ? req.headers : null; // Don't keep all request headers if they won't be used\n    this._reqcc = parseCacheControl(req.headers['cache-control']);\n\n    // Assume that if someone uses legacy, non-standard uncecessary options they don't understand caching,\n    // so there's no point stricly adhering to the blindly copy&pasted directives.\n    if (ignoreCargoCult && \"pre-check\" in this._rescc && \"post-check\" in this._rescc) {\n      delete this._rescc['pre-check'];\n      delete this._rescc['post-check'];\n      delete this._rescc['no-cache'];\n      delete this._rescc['no-store'];\n      delete this._rescc['must-revalidate'];\n      this._resHeaders = Object.assign({}, this._resHeaders, {\n        'cache-control': formatCacheControl(this._rescc)\n      });\n      delete this._resHeaders.expires;\n      delete this._resHeaders.pragma;\n    }\n\n    // When the Cache-Control header field is not present in a request, caches MUST consider the no-cache request pragma-directive\n    // as having the same effect as if \"Cache-Control: no-cache\" were present (see Section 5.2.1).\n    if (!res.headers['cache-control'] && /no-cache/.test(res.headers.pragma)) {\n      this._rescc['no-cache'] = true;\n    }\n  }\n  CachePolicy.prototype.now = function now() {\n    return Date.now();\n  };\n  CachePolicy.prototype.storable = function storable() {\n    // The \"no-store\" request directive indicates that a cache MUST NOT store any part of either this request or any response to it.\n    return !!(!this._reqcc['no-store'] && (\n    // A cache MUST NOT store a response to any request, unless:\n    // The request method is understood by the cache and defined as being cacheable, and\n    'GET' === this._method || 'HEAD' === this._method || 'POST' === this._method && this._hasExplicitExpiration()) &&\n    // the response status code is understood by the cache, and\n    understoodStatuses.indexOf(this._status) !== -1 &&\n    // the \"no-store\" cache directive does not appear in request or response header fields, and\n    !this._rescc['no-store'] && (\n    // the \"private\" response directive does not appear in the response, if the cache is shared, and\n    !this._isShared || !this._rescc.private) && (\n    // the Authorization header field does not appear in the request, if the cache is shared,\n    !this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) && (\n    // the response either:\n\n    // contains an Expires header field, or\n    this._resHeaders.expires ||\n    // contains a max-age response directive, or\n    // contains a s-maxage response directive and the cache is shared, or\n    // contains a public response directive.\n    this._rescc.public || this._rescc['max-age'] || this._rescc['s-maxage'] ||\n    // has a status code that is defined as cacheable by default\n    statusCodeCacheableByDefault.indexOf(this._status) !== -1));\n  };\n  CachePolicy.prototype._hasExplicitExpiration = function _hasExplicitExpiration() {\n    // 4.2.1 Calculating Freshness Lifetime\n    return this._isShared && this._rescc['s-maxage'] || this._rescc['max-age'] || this._resHeaders.expires;\n  };\n  CachePolicy.prototype._assertRequestHasHeaders = function _assertRequestHasHeaders(req) {\n    if (!req || !req.headers) {\n      throw Error(\"Request headers missing\");\n    }\n  };\n  CachePolicy.prototype.satisfiesWithoutRevalidation = function satisfiesWithoutRevalidation(req) {\n    this._assertRequestHasHeaders(req);\n\n    // When presented with a request, a cache MUST NOT reuse a stored response, unless:\n    // the presented request does not contain the no-cache pragma (Section 5.4), nor the no-cache cache directive,\n    // unless the stored response is successfully validated (Section 4.3), and\n    var requestCC = parseCacheControl(req.headers['cache-control']);\n    if (requestCC['no-cache'] || /no-cache/.test(req.headers.pragma)) {\n      return false;\n    }\n    if (requestCC['max-age'] && this.age() > requestCC['max-age']) {\n      return false;\n    }\n    if (requestCC['min-fresh'] && this.timeToLive() < 1000 * requestCC['min-fresh']) {\n      return false;\n    }\n\n    // the stored response is either:\n    // fresh, or allowed to be served stale\n    if (this.stale()) {\n      var allowsStale = requestCC['max-stale'] && !this._rescc['must-revalidate'] && (true === requestCC['max-stale'] || requestCC['max-stale'] > this.age() - this.maxAge());\n      if (!allowsStale) {\n        return false;\n      }\n    }\n    return this._requestMatches(req, false);\n  };\n  CachePolicy.prototype._requestMatches = function _requestMatches(req, allowHeadMethod) {\n    // The presented effective request URI and that of the stored response match, and\n    return (!this._url || this._url === req.url) && this._host === req.headers.host && (\n    // the request method associated with the stored response allows it to be used for the presented request, and\n    !req.method || this._method === req.method || allowHeadMethod && 'HEAD' === req.method) &&\n    // selecting header fields nominated by the stored response (if any) match those presented, and\n    this._varyMatches(req);\n  };\n  CachePolicy.prototype._allowsStoringAuthenticated = function _allowsStoringAuthenticated() {\n    //  following Cache-Control response directives (Section 5.2.2) have such an effect: must-revalidate, public, and s-maxage.\n    return this._rescc['must-revalidate'] || this._rescc.public || this._rescc['s-maxage'];\n  };\n  CachePolicy.prototype._varyMatches = function _varyMatches(req) {\n    if (!this._resHeaders.vary) {\n      return true;\n    }\n\n    // A Vary header field-value of \"*\" always fails to match\n    if (this._resHeaders.vary === '*') {\n      return false;\n    }\n    var fields = this._resHeaders.vary.trim().toLowerCase().split(/\\s*,\\s*/);\n    for (var _iterator2 = fields, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref3;\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref3 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref3 = _i2.value;\n      }\n      var name = _ref3;\n      if (req.headers[name] !== this._reqHeaders[name]) return false;\n    }\n    return true;\n  };\n  CachePolicy.prototype._copyWithoutHopByHopHeaders = function _copyWithoutHopByHopHeaders(inHeaders) {\n    var headers = {};\n    for (var name in inHeaders) {\n      if (hopByHopHeaders[name]) continue;\n      headers[name] = inHeaders[name];\n    }\n    // 9.1.  Connection\n    if (inHeaders.connection) {\n      var tokens = inHeaders.connection.trim().split(/\\s*,\\s*/);\n      for (var _iterator3 = tokens, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n        var _ref4;\n        if (_isArray3) {\n          if (_i3 >= _iterator3.length) break;\n          _ref4 = _iterator3[_i3++];\n        } else {\n          _i3 = _iterator3.next();\n          if (_i3.done) break;\n          _ref4 = _i3.value;\n        }\n        var _name = _ref4;\n        delete headers[_name];\n      }\n    }\n    if (headers.warning) {\n      var warnings = headers.warning.split(/,/).filter(function (warning) {\n        return !/^\\s*1[0-9][0-9]/.test(warning);\n      });\n      if (!warnings.length) {\n        delete headers.warning;\n      } else {\n        headers.warning = warnings.join(',').trim();\n      }\n    }\n    return headers;\n  };\n  CachePolicy.prototype.responseHeaders = function responseHeaders() {\n    var headers = this._copyWithoutHopByHopHeaders(this._resHeaders);\n    var age = this.age();\n\n    // A cache SHOULD generate 113 warning if it heuristically chose a freshness\n    // lifetime greater than 24 hours and the response's age is greater than 24 hours.\n    if (age > 3600 * 24 && !this._hasExplicitExpiration() && this.maxAge() > 3600 * 24) {\n      headers.warning = (headers.warning ? `${headers.warning}, ` : '') + '113 - \"rfc7234 5.5.4\"';\n    }\n    headers.age = `${Math.round(age)}`;\n    return headers;\n  };\n\n  /**\n   * Value of the Date response header or current time if Date was demed invalid\n   * @return timestamp\n   */\n\n  CachePolicy.prototype.date = function date() {\n    var dateValue = Date.parse(this._resHeaders.date);\n    var maxClockDrift = 8 * 3600 * 1000;\n    if (Number.isNaN(dateValue) || dateValue < this._responseTime - maxClockDrift || dateValue > this._responseTime + maxClockDrift) {\n      return this._responseTime;\n    }\n    return dateValue;\n  };\n\n  /**\n   * Value of the Age header, in seconds, updated for the current time.\n   * May be fractional.\n   *\n   * @return Number\n   */\n\n  CachePolicy.prototype.age = function age() {\n    var age = Math.max(0, (this._responseTime - this.date()) / 1000);\n    if (this._resHeaders.age) {\n      var ageValue = this._ageValue();\n      if (ageValue > age) age = ageValue;\n    }\n    var residentTime = (this.now() - this._responseTime) / 1000;\n    return age + residentTime;\n  };\n  CachePolicy.prototype._ageValue = function _ageValue() {\n    var ageValue = parseInt(this._resHeaders.age);\n    return isFinite(ageValue) ? ageValue : 0;\n  };\n\n  /**\n   * Value of applicable max-age (or heuristic equivalent) in seconds. This counts since response's `Date`.\n   *\n   * For an up-to-date value, see `timeToLive()`.\n   *\n   * @return Number\n   */\n\n  CachePolicy.prototype.maxAge = function maxAge() {\n    if (!this.storable() || this._rescc['no-cache']) {\n      return 0;\n    }\n\n    // Shared responses with cookies are cacheable according to the RFC, but IMHO it'd be unwise to do so by default\n    // so this implementation requires explicit opt-in via public header\n    if (this._isShared && this._resHeaders['set-cookie'] && !this._rescc.public && !this._rescc.immutable) {\n      return 0;\n    }\n    if (this._resHeaders.vary === '*') {\n      return 0;\n    }\n    if (this._isShared) {\n      if (this._rescc['proxy-revalidate']) {\n        return 0;\n      }\n      // if a response includes the s-maxage directive, a shared cache recipient MUST ignore the Expires field.\n      if (this._rescc['s-maxage']) {\n        return parseInt(this._rescc['s-maxage'], 10);\n      }\n    }\n\n    // If a response includes a Cache-Control field with the max-age directive, a recipient MUST ignore the Expires field.\n    if (this._rescc['max-age']) {\n      return parseInt(this._rescc['max-age'], 10);\n    }\n    var defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;\n    var dateValue = this.date();\n    if (this._resHeaders.expires) {\n      var expires = Date.parse(this._resHeaders.expires);\n      // A cache recipient MUST interpret invalid date formats, especially the value \"0\", as representing a time in the past (i.e., \"already expired\").\n      if (Number.isNaN(expires) || expires < dateValue) {\n        return 0;\n      }\n      return Math.max(defaultMinTtl, (expires - dateValue) / 1000);\n    }\n    if (this._resHeaders['last-modified']) {\n      var lastModified = Date.parse(this._resHeaders['last-modified']);\n      if (isFinite(lastModified) && dateValue > lastModified) {\n        return Math.max(defaultMinTtl, (dateValue - lastModified) / 1000 * this._cacheHeuristic);\n      }\n    }\n    return defaultMinTtl;\n  };\n  CachePolicy.prototype.timeToLive = function timeToLive() {\n    return Math.max(0, this.maxAge() - this.age()) * 1000;\n  };\n  CachePolicy.prototype.stale = function stale() {\n    return this.maxAge() <= this.age();\n  };\n  CachePolicy.fromObject = function fromObject(obj) {\n    return new this(undefined, undefined, {\n      _fromObject: obj\n    });\n  };\n  CachePolicy.prototype._fromObject = function _fromObject(obj) {\n    if (this._responseTime) throw Error(\"Reinitialized\");\n    if (!obj || obj.v !== 1) throw Error(\"Invalid serialization\");\n    this._responseTime = obj.t;\n    this._isShared = obj.sh;\n    this._cacheHeuristic = obj.ch;\n    this._immutableMinTtl = obj.imm !== undefined ? obj.imm : 24 * 3600 * 1000;\n    this._status = obj.st;\n    this._resHeaders = obj.resh;\n    this._rescc = obj.rescc;\n    this._method = obj.m;\n    this._url = obj.u;\n    this._host = obj.h;\n    this._noAuthorization = obj.a;\n    this._reqHeaders = obj.reqh;\n    this._reqcc = obj.reqcc;\n  };\n  CachePolicy.prototype.toObject = function toObject() {\n    return {\n      v: 1,\n      t: this._responseTime,\n      sh: this._isShared,\n      ch: this._cacheHeuristic,\n      imm: this._immutableMinTtl,\n      st: this._status,\n      resh: this._resHeaders,\n      rescc: this._rescc,\n      m: this._method,\n      u: this._url,\n      h: this._host,\n      a: this._noAuthorization,\n      reqh: this._reqHeaders,\n      reqcc: this._reqcc\n    };\n  };\n\n  /**\n   * Headers for sending to the origin server to revalidate stale response.\n   * Allows server to return 304 to allow reuse of the previous response.\n   *\n   * Hop by hop headers are always stripped.\n   * Revalidation headers may be added or removed, depending on request.\n   */\n\n  CachePolicy.prototype.revalidationHeaders = function revalidationHeaders(incomingReq) {\n    this._assertRequestHasHeaders(incomingReq);\n    var headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);\n\n    // This implementation does not understand range requests\n    delete headers['if-range'];\n    if (!this._requestMatches(incomingReq, true) || !this.storable()) {\n      // revalidation allowed via HEAD\n      // not for the same resource, or wasn't allowed to be cached anyway\n      delete headers['if-none-match'];\n      delete headers['if-modified-since'];\n      return headers;\n    }\n\n    /* MUST send that entity-tag in any cache validation request (using If-Match or If-None-Match) if an entity-tag has been provided by the origin server. */\n    if (this._resHeaders.etag) {\n      headers['if-none-match'] = headers['if-none-match'] ? `${headers['if-none-match']}, ${this._resHeaders.etag}` : this._resHeaders.etag;\n    }\n\n    // Clients MAY issue simple (non-subrange) GET requests with either weak validators or strong validators. Clients MUST NOT use weak validators in other forms of request.\n    var forbidsWeakValidators = headers['accept-ranges'] || headers['if-match'] || headers['if-unmodified-since'] || this._method && this._method != 'GET';\n\n    /* SHOULD send the Last-Modified value in non-subrange cache validation requests (using If-Modified-Since) if only a Last-Modified value has been provided by the origin server.\n    Note: This implementation does not understand partial responses (206) */\n    if (forbidsWeakValidators) {\n      delete headers['if-modified-since'];\n      if (headers['if-none-match']) {\n        var etags = headers['if-none-match'].split(/,/).filter(function (etag) {\n          return !/^\\s*W\\//.test(etag);\n        });\n        if (!etags.length) {\n          delete headers['if-none-match'];\n        } else {\n          headers['if-none-match'] = etags.join(',').trim();\n        }\n      }\n    } else if (this._resHeaders['last-modified'] && !headers['if-modified-since']) {\n      headers['if-modified-since'] = this._resHeaders['last-modified'];\n    }\n    return headers;\n  };\n\n  /**\n   * Creates new CachePolicy with information combined from the previews response,\n   * and the new revalidation response.\n   *\n   * Returns {policy, modified} where modified is a boolean indicating\n   * whether the response body has been modified, and old cached body can't be used.\n   *\n   * @return {Object} {policy: CachePolicy, modified: Boolean}\n   */\n\n  CachePolicy.prototype.revalidatedPolicy = function revalidatedPolicy(request, response) {\n    this._assertRequestHasHeaders(request);\n    if (!response || !response.headers) {\n      throw Error(\"Response headers missing\");\n    }\n\n    // These aren't going to be supported exactly, since one CachePolicy object\n    // doesn't know about all the other cached objects.\n    var matches = false;\n    if (response.status !== undefined && response.status != 304) {\n      matches = false;\n    } else if (response.headers.etag && !/^\\s*W\\//.test(response.headers.etag)) {\n      // \"All of the stored responses with the same strong validator are selected.\n      // If none of the stored responses contain the same strong validator,\n      // then the cache MUST NOT use the new response to update any stored responses.\"\n      matches = this._resHeaders.etag && this._resHeaders.etag.replace(/^\\s*W\\//, '') === response.headers.etag;\n    } else if (this._resHeaders.etag && response.headers.etag) {\n      // \"If the new response contains a weak validator and that validator corresponds\n      // to one of the cache's stored responses,\n      // then the most recent of those matching stored responses is selected for update.\"\n      matches = this._resHeaders.etag.replace(/^\\s*W\\//, '') === response.headers.etag.replace(/^\\s*W\\//, '');\n    } else if (this._resHeaders['last-modified']) {\n      matches = this._resHeaders['last-modified'] === response.headers['last-modified'];\n    } else {\n      // If the new response does not include any form of validator (such as in the case where\n      // a client generates an If-Modified-Since request from a source other than the Last-Modified\n      // response header field), and there is only one stored response, and that stored response also\n      // lacks a validator, then that stored response is selected for update.\n      if (!this._resHeaders.etag && !this._resHeaders['last-modified'] && !response.headers.etag && !response.headers['last-modified']) {\n        matches = true;\n      }\n    }\n    if (!matches) {\n      return {\n        policy: new this.constructor(request, response),\n        modified: true\n      };\n    }\n\n    // use other header fields provided in the 304 (Not Modified) response to replace all instances\n    // of the corresponding header fields in the stored response.\n    var headers = {};\n    for (var k in this._resHeaders) {\n      headers[k] = k in response.headers && !excludedFromRevalidationUpdate[k] ? response.headers[k] : this._resHeaders[k];\n    }\n    var newResponse = Object.assign({}, response, {\n      status: this._status,\n      method: this._method,\n      headers\n    });\n    return {\n      policy: new this.constructor(request, newResponse),\n      modified: false\n    };\n  };\n  return CachePolicy;\n}();","map":{"version":3,"names":["_classCallCheck","instance","Constructor","TypeError","statusCodeCacheableByDefault","understoodStatuses","hopByHopHeaders","excludedFromRevalidationUpdate","parseCacheControl","header","cc","parts","trim","split","_iterator","_isArray","Array","isArray","_i","Symbol","iterator","_ref","length","next","done","value","part","_part$split","k","v","undefined","replace","formatCacheControl","push","join","module","exports","CachePolicy","req","res","_ref2","arguments","shared","cacheHeuristic","immutableMinTimeToLive","ignoreCargoCult","_fromObject","headers","Error","_assertRequestHasHeaders","_responseTime","now","_isShared","_cacheHeuristic","_immutableMinTtl","_status","status","_resHeaders","_rescc","_method","method","_url","url","_host","host","_noAuthorization","authorization","_reqHeaders","vary","_reqcc","Object","assign","expires","pragma","test","prototype","Date","storable","_hasExplicitExpiration","indexOf","private","_allowsStoringAuthenticated","public","satisfiesWithoutRevalidation","requestCC","age","timeToLive","stale","allowsStale","maxAge","_requestMatches","allowHeadMethod","_varyMatches","fields","toLowerCase","_iterator2","_isArray2","_i2","_ref3","name","_copyWithoutHopByHopHeaders","inHeaders","connection","tokens","_iterator3","_isArray3","_i3","_ref4","_name","warning","warnings","filter","responseHeaders","Math","round","date","dateValue","parse","maxClockDrift","Number","isNaN","max","ageValue","_ageValue","residentTime","parseInt","isFinite","immutable","defaultMinTtl","lastModified","fromObject","obj","t","sh","ch","imm","st","resh","rescc","m","u","h","a","reqh","reqcc","toObject","revalidationHeaders","incomingReq","etag","forbidsWeakValidators","etags","revalidatedPolicy","request","response","matches","policy","constructor","modified","newResponse"],"sources":["/Users/hkateliev/node_modules/npm/node_modules/http-cache-semantics/node4/index.js"],"sourcesContent":["'use strict';\n// rfc7231 6.1\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar statusCodeCacheableByDefault = [200, 203, 204, 206, 300, 301, 404, 405, 410, 414, 501];\n\n// This implementation does not understand partial responses (206)\nvar understoodStatuses = [200, 203, 204, 300, 301, 302, 303, 307, 308, 404, 405, 410, 414, 501];\n\nvar hopByHopHeaders = { 'connection': true, 'keep-alive': true, 'proxy-authenticate': true, 'proxy-authorization': true, 'te': true, 'trailer': true, 'transfer-encoding': true, 'upgrade': true };\nvar excludedFromRevalidationUpdate = {\n    // Since the old body is reused, it doesn't make sense to change properties of the body\n    'content-length': true, 'content-encoding': true, 'transfer-encoding': true,\n    'content-range': true\n};\n\nfunction parseCacheControl(header) {\n    var cc = {};\n    if (!header) return cc;\n\n    // TODO: When there is more than one value present for a given directive (e.g., two Expires header fields, multiple Cache-Control: max-age directives),\n    // the directive's value is considered invalid. Caches are encouraged to consider responses that have invalid freshness information to be stale\n    var parts = header.trim().split(/\\s*,\\s*/); // TODO: lame parsing\n    for (var _iterator = parts, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n            if (_i >= _iterator.length) break;\n            _ref = _iterator[_i++];\n        } else {\n            _i = _iterator.next();\n            if (_i.done) break;\n            _ref = _i.value;\n        }\n\n        var part = _ref;\n\n        var _part$split = part.split(/\\s*=\\s*/, 2),\n            k = _part$split[0],\n            v = _part$split[1];\n\n        cc[k] = v === undefined ? true : v.replace(/^\"|\"$/g, ''); // TODO: lame unquoting\n    }\n\n    return cc;\n}\n\nfunction formatCacheControl(cc) {\n    var parts = [];\n    for (var k in cc) {\n        var v = cc[k];\n        parts.push(v === true ? k : k + '=' + v);\n    }\n    if (!parts.length) {\n        return undefined;\n    }\n    return parts.join(', ');\n}\n\nmodule.exports = function () {\n    function CachePolicy(req, res) {\n        var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n            shared = _ref2.shared,\n            cacheHeuristic = _ref2.cacheHeuristic,\n            immutableMinTimeToLive = _ref2.immutableMinTimeToLive,\n            ignoreCargoCult = _ref2.ignoreCargoCult,\n            _fromObject = _ref2._fromObject;\n\n        _classCallCheck(this, CachePolicy);\n\n        if (_fromObject) {\n            this._fromObject(_fromObject);\n            return;\n        }\n\n        if (!res || !res.headers) {\n            throw Error(\"Response headers missing\");\n        }\n        this._assertRequestHasHeaders(req);\n\n        this._responseTime = this.now();\n        this._isShared = shared !== false;\n        this._cacheHeuristic = undefined !== cacheHeuristic ? cacheHeuristic : 0.1; // 10% matches IE\n        this._immutableMinTtl = undefined !== immutableMinTimeToLive ? immutableMinTimeToLive : 24 * 3600 * 1000;\n\n        this._status = 'status' in res ? res.status : 200;\n        this._resHeaders = res.headers;\n        this._rescc = parseCacheControl(res.headers['cache-control']);\n        this._method = 'method' in req ? req.method : 'GET';\n        this._url = req.url;\n        this._host = req.headers.host;\n        this._noAuthorization = !req.headers.authorization;\n        this._reqHeaders = res.headers.vary ? req.headers : null; // Don't keep all request headers if they won't be used\n        this._reqcc = parseCacheControl(req.headers['cache-control']);\n\n        // Assume that if someone uses legacy, non-standard uncecessary options they don't understand caching,\n        // so there's no point stricly adhering to the blindly copy&pasted directives.\n        if (ignoreCargoCult && \"pre-check\" in this._rescc && \"post-check\" in this._rescc) {\n            delete this._rescc['pre-check'];\n            delete this._rescc['post-check'];\n            delete this._rescc['no-cache'];\n            delete this._rescc['no-store'];\n            delete this._rescc['must-revalidate'];\n            this._resHeaders = Object.assign({}, this._resHeaders, { 'cache-control': formatCacheControl(this._rescc) });\n            delete this._resHeaders.expires;\n            delete this._resHeaders.pragma;\n        }\n\n        // When the Cache-Control header field is not present in a request, caches MUST consider the no-cache request pragma-directive\n        // as having the same effect as if \"Cache-Control: no-cache\" were present (see Section 5.2.1).\n        if (!res.headers['cache-control'] && /no-cache/.test(res.headers.pragma)) {\n            this._rescc['no-cache'] = true;\n        }\n    }\n\n    CachePolicy.prototype.now = function now() {\n        return Date.now();\n    };\n\n    CachePolicy.prototype.storable = function storable() {\n        // The \"no-store\" request directive indicates that a cache MUST NOT store any part of either this request or any response to it.\n        return !!(!this._reqcc['no-store'] && (\n        // A cache MUST NOT store a response to any request, unless:\n        // The request method is understood by the cache and defined as being cacheable, and\n        'GET' === this._method || 'HEAD' === this._method || 'POST' === this._method && this._hasExplicitExpiration()) &&\n        // the response status code is understood by the cache, and\n        understoodStatuses.indexOf(this._status) !== -1 &&\n        // the \"no-store\" cache directive does not appear in request or response header fields, and\n        !this._rescc['no-store'] && (\n        // the \"private\" response directive does not appear in the response, if the cache is shared, and\n        !this._isShared || !this._rescc.private) && (\n        // the Authorization header field does not appear in the request, if the cache is shared,\n        !this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) && (\n        // the response either:\n\n        // contains an Expires header field, or\n        this._resHeaders.expires ||\n        // contains a max-age response directive, or\n        // contains a s-maxage response directive and the cache is shared, or\n        // contains a public response directive.\n        this._rescc.public || this._rescc['max-age'] || this._rescc['s-maxage'] ||\n        // has a status code that is defined as cacheable by default\n        statusCodeCacheableByDefault.indexOf(this._status) !== -1));\n    };\n\n    CachePolicy.prototype._hasExplicitExpiration = function _hasExplicitExpiration() {\n        // 4.2.1 Calculating Freshness Lifetime\n        return this._isShared && this._rescc['s-maxage'] || this._rescc['max-age'] || this._resHeaders.expires;\n    };\n\n    CachePolicy.prototype._assertRequestHasHeaders = function _assertRequestHasHeaders(req) {\n        if (!req || !req.headers) {\n            throw Error(\"Request headers missing\");\n        }\n    };\n\n    CachePolicy.prototype.satisfiesWithoutRevalidation = function satisfiesWithoutRevalidation(req) {\n        this._assertRequestHasHeaders(req);\n\n        // When presented with a request, a cache MUST NOT reuse a stored response, unless:\n        // the presented request does not contain the no-cache pragma (Section 5.4), nor the no-cache cache directive,\n        // unless the stored response is successfully validated (Section 4.3), and\n        var requestCC = parseCacheControl(req.headers['cache-control']);\n        if (requestCC['no-cache'] || /no-cache/.test(req.headers.pragma)) {\n            return false;\n        }\n\n        if (requestCC['max-age'] && this.age() > requestCC['max-age']) {\n            return false;\n        }\n\n        if (requestCC['min-fresh'] && this.timeToLive() < 1000 * requestCC['min-fresh']) {\n            return false;\n        }\n\n        // the stored response is either:\n        // fresh, or allowed to be served stale\n        if (this.stale()) {\n            var allowsStale = requestCC['max-stale'] && !this._rescc['must-revalidate'] && (true === requestCC['max-stale'] || requestCC['max-stale'] > this.age() - this.maxAge());\n            if (!allowsStale) {\n                return false;\n            }\n        }\n\n        return this._requestMatches(req, false);\n    };\n\n    CachePolicy.prototype._requestMatches = function _requestMatches(req, allowHeadMethod) {\n        // The presented effective request URI and that of the stored response match, and\n        return (!this._url || this._url === req.url) && this._host === req.headers.host && (\n        // the request method associated with the stored response allows it to be used for the presented request, and\n        !req.method || this._method === req.method || allowHeadMethod && 'HEAD' === req.method) &&\n        // selecting header fields nominated by the stored response (if any) match those presented, and\n        this._varyMatches(req);\n    };\n\n    CachePolicy.prototype._allowsStoringAuthenticated = function _allowsStoringAuthenticated() {\n        //  following Cache-Control response directives (Section 5.2.2) have such an effect: must-revalidate, public, and s-maxage.\n        return this._rescc['must-revalidate'] || this._rescc.public || this._rescc['s-maxage'];\n    };\n\n    CachePolicy.prototype._varyMatches = function _varyMatches(req) {\n        if (!this._resHeaders.vary) {\n            return true;\n        }\n\n        // A Vary header field-value of \"*\" always fails to match\n        if (this._resHeaders.vary === '*') {\n            return false;\n        }\n\n        var fields = this._resHeaders.vary.trim().toLowerCase().split(/\\s*,\\s*/);\n        for (var _iterator2 = fields, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n            var _ref3;\n\n            if (_isArray2) {\n                if (_i2 >= _iterator2.length) break;\n                _ref3 = _iterator2[_i2++];\n            } else {\n                _i2 = _iterator2.next();\n                if (_i2.done) break;\n                _ref3 = _i2.value;\n            }\n\n            var name = _ref3;\n\n            if (req.headers[name] !== this._reqHeaders[name]) return false;\n        }\n        return true;\n    };\n\n    CachePolicy.prototype._copyWithoutHopByHopHeaders = function _copyWithoutHopByHopHeaders(inHeaders) {\n        var headers = {};\n        for (var name in inHeaders) {\n            if (hopByHopHeaders[name]) continue;\n            headers[name] = inHeaders[name];\n        }\n        // 9.1.  Connection\n        if (inHeaders.connection) {\n            var tokens = inHeaders.connection.trim().split(/\\s*,\\s*/);\n            for (var _iterator3 = tokens, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n                var _ref4;\n\n                if (_isArray3) {\n                    if (_i3 >= _iterator3.length) break;\n                    _ref4 = _iterator3[_i3++];\n                } else {\n                    _i3 = _iterator3.next();\n                    if (_i3.done) break;\n                    _ref4 = _i3.value;\n                }\n\n                var _name = _ref4;\n\n                delete headers[_name];\n            }\n        }\n        if (headers.warning) {\n            var warnings = headers.warning.split(/,/).filter(function (warning) {\n                return !/^\\s*1[0-9][0-9]/.test(warning);\n            });\n            if (!warnings.length) {\n                delete headers.warning;\n            } else {\n                headers.warning = warnings.join(',').trim();\n            }\n        }\n        return headers;\n    };\n\n    CachePolicy.prototype.responseHeaders = function responseHeaders() {\n        var headers = this._copyWithoutHopByHopHeaders(this._resHeaders);\n        var age = this.age();\n\n        // A cache SHOULD generate 113 warning if it heuristically chose a freshness\n        // lifetime greater than 24 hours and the response's age is greater than 24 hours.\n        if (age > 3600 * 24 && !this._hasExplicitExpiration() && this.maxAge() > 3600 * 24) {\n            headers.warning = (headers.warning ? `${headers.warning}, ` : '') + '113 - \"rfc7234 5.5.4\"';\n        }\n        headers.age = `${Math.round(age)}`;\n        return headers;\n    };\n\n    /**\n     * Value of the Date response header or current time if Date was demed invalid\n     * @return timestamp\n     */\n\n\n    CachePolicy.prototype.date = function date() {\n        var dateValue = Date.parse(this._resHeaders.date);\n        var maxClockDrift = 8 * 3600 * 1000;\n        if (Number.isNaN(dateValue) || dateValue < this._responseTime - maxClockDrift || dateValue > this._responseTime + maxClockDrift) {\n            return this._responseTime;\n        }\n        return dateValue;\n    };\n\n    /**\n     * Value of the Age header, in seconds, updated for the current time.\n     * May be fractional.\n     *\n     * @return Number\n     */\n\n\n    CachePolicy.prototype.age = function age() {\n        var age = Math.max(0, (this._responseTime - this.date()) / 1000);\n        if (this._resHeaders.age) {\n            var ageValue = this._ageValue();\n            if (ageValue > age) age = ageValue;\n        }\n\n        var residentTime = (this.now() - this._responseTime) / 1000;\n        return age + residentTime;\n    };\n\n    CachePolicy.prototype._ageValue = function _ageValue() {\n        var ageValue = parseInt(this._resHeaders.age);\n        return isFinite(ageValue) ? ageValue : 0;\n    };\n\n    /**\n     * Value of applicable max-age (or heuristic equivalent) in seconds. This counts since response's `Date`.\n     *\n     * For an up-to-date value, see `timeToLive()`.\n     *\n     * @return Number\n     */\n\n\n    CachePolicy.prototype.maxAge = function maxAge() {\n        if (!this.storable() || this._rescc['no-cache']) {\n            return 0;\n        }\n\n        // Shared responses with cookies are cacheable according to the RFC, but IMHO it'd be unwise to do so by default\n        // so this implementation requires explicit opt-in via public header\n        if (this._isShared && this._resHeaders['set-cookie'] && !this._rescc.public && !this._rescc.immutable) {\n            return 0;\n        }\n\n        if (this._resHeaders.vary === '*') {\n            return 0;\n        }\n\n        if (this._isShared) {\n            if (this._rescc['proxy-revalidate']) {\n                return 0;\n            }\n            // if a response includes the s-maxage directive, a shared cache recipient MUST ignore the Expires field.\n            if (this._rescc['s-maxage']) {\n                return parseInt(this._rescc['s-maxage'], 10);\n            }\n        }\n\n        // If a response includes a Cache-Control field with the max-age directive, a recipient MUST ignore the Expires field.\n        if (this._rescc['max-age']) {\n            return parseInt(this._rescc['max-age'], 10);\n        }\n\n        var defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;\n\n        var dateValue = this.date();\n        if (this._resHeaders.expires) {\n            var expires = Date.parse(this._resHeaders.expires);\n            // A cache recipient MUST interpret invalid date formats, especially the value \"0\", as representing a time in the past (i.e., \"already expired\").\n            if (Number.isNaN(expires) || expires < dateValue) {\n                return 0;\n            }\n            return Math.max(defaultMinTtl, (expires - dateValue) / 1000);\n        }\n\n        if (this._resHeaders['last-modified']) {\n            var lastModified = Date.parse(this._resHeaders['last-modified']);\n            if (isFinite(lastModified) && dateValue > lastModified) {\n                return Math.max(defaultMinTtl, (dateValue - lastModified) / 1000 * this._cacheHeuristic);\n            }\n        }\n\n        return defaultMinTtl;\n    };\n\n    CachePolicy.prototype.timeToLive = function timeToLive() {\n        return Math.max(0, this.maxAge() - this.age()) * 1000;\n    };\n\n    CachePolicy.prototype.stale = function stale() {\n        return this.maxAge() <= this.age();\n    };\n\n    CachePolicy.fromObject = function fromObject(obj) {\n        return new this(undefined, undefined, { _fromObject: obj });\n    };\n\n    CachePolicy.prototype._fromObject = function _fromObject(obj) {\n        if (this._responseTime) throw Error(\"Reinitialized\");\n        if (!obj || obj.v !== 1) throw Error(\"Invalid serialization\");\n\n        this._responseTime = obj.t;\n        this._isShared = obj.sh;\n        this._cacheHeuristic = obj.ch;\n        this._immutableMinTtl = obj.imm !== undefined ? obj.imm : 24 * 3600 * 1000;\n        this._status = obj.st;\n        this._resHeaders = obj.resh;\n        this._rescc = obj.rescc;\n        this._method = obj.m;\n        this._url = obj.u;\n        this._host = obj.h;\n        this._noAuthorization = obj.a;\n        this._reqHeaders = obj.reqh;\n        this._reqcc = obj.reqcc;\n    };\n\n    CachePolicy.prototype.toObject = function toObject() {\n        return {\n            v: 1,\n            t: this._responseTime,\n            sh: this._isShared,\n            ch: this._cacheHeuristic,\n            imm: this._immutableMinTtl,\n            st: this._status,\n            resh: this._resHeaders,\n            rescc: this._rescc,\n            m: this._method,\n            u: this._url,\n            h: this._host,\n            a: this._noAuthorization,\n            reqh: this._reqHeaders,\n            reqcc: this._reqcc\n        };\n    };\n\n    /**\n     * Headers for sending to the origin server to revalidate stale response.\n     * Allows server to return 304 to allow reuse of the previous response.\n     *\n     * Hop by hop headers are always stripped.\n     * Revalidation headers may be added or removed, depending on request.\n     */\n\n\n    CachePolicy.prototype.revalidationHeaders = function revalidationHeaders(incomingReq) {\n        this._assertRequestHasHeaders(incomingReq);\n        var headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);\n\n        // This implementation does not understand range requests\n        delete headers['if-range'];\n\n        if (!this._requestMatches(incomingReq, true) || !this.storable()) {\n            // revalidation allowed via HEAD\n            // not for the same resource, or wasn't allowed to be cached anyway\n            delete headers['if-none-match'];\n            delete headers['if-modified-since'];\n            return headers;\n        }\n\n        /* MUST send that entity-tag in any cache validation request (using If-Match or If-None-Match) if an entity-tag has been provided by the origin server. */\n        if (this._resHeaders.etag) {\n            headers['if-none-match'] = headers['if-none-match'] ? `${headers['if-none-match']}, ${this._resHeaders.etag}` : this._resHeaders.etag;\n        }\n\n        // Clients MAY issue simple (non-subrange) GET requests with either weak validators or strong validators. Clients MUST NOT use weak validators in other forms of request.\n        var forbidsWeakValidators = headers['accept-ranges'] || headers['if-match'] || headers['if-unmodified-since'] || this._method && this._method != 'GET';\n\n        /* SHOULD send the Last-Modified value in non-subrange cache validation requests (using If-Modified-Since) if only a Last-Modified value has been provided by the origin server.\n        Note: This implementation does not understand partial responses (206) */\n        if (forbidsWeakValidators) {\n            delete headers['if-modified-since'];\n\n            if (headers['if-none-match']) {\n                var etags = headers['if-none-match'].split(/,/).filter(function (etag) {\n                    return !/^\\s*W\\//.test(etag);\n                });\n                if (!etags.length) {\n                    delete headers['if-none-match'];\n                } else {\n                    headers['if-none-match'] = etags.join(',').trim();\n                }\n            }\n        } else if (this._resHeaders['last-modified'] && !headers['if-modified-since']) {\n            headers['if-modified-since'] = this._resHeaders['last-modified'];\n        }\n\n        return headers;\n    };\n\n    /**\n     * Creates new CachePolicy with information combined from the previews response,\n     * and the new revalidation response.\n     *\n     * Returns {policy, modified} where modified is a boolean indicating\n     * whether the response body has been modified, and old cached body can't be used.\n     *\n     * @return {Object} {policy: CachePolicy, modified: Boolean}\n     */\n\n\n    CachePolicy.prototype.revalidatedPolicy = function revalidatedPolicy(request, response) {\n        this._assertRequestHasHeaders(request);\n        if (!response || !response.headers) {\n            throw Error(\"Response headers missing\");\n        }\n\n        // These aren't going to be supported exactly, since one CachePolicy object\n        // doesn't know about all the other cached objects.\n        var matches = false;\n        if (response.status !== undefined && response.status != 304) {\n            matches = false;\n        } else if (response.headers.etag && !/^\\s*W\\//.test(response.headers.etag)) {\n            // \"All of the stored responses with the same strong validator are selected.\n            // If none of the stored responses contain the same strong validator,\n            // then the cache MUST NOT use the new response to update any stored responses.\"\n            matches = this._resHeaders.etag && this._resHeaders.etag.replace(/^\\s*W\\//, '') === response.headers.etag;\n        } else if (this._resHeaders.etag && response.headers.etag) {\n            // \"If the new response contains a weak validator and that validator corresponds\n            // to one of the cache's stored responses,\n            // then the most recent of those matching stored responses is selected for update.\"\n            matches = this._resHeaders.etag.replace(/^\\s*W\\//, '') === response.headers.etag.replace(/^\\s*W\\//, '');\n        } else if (this._resHeaders['last-modified']) {\n            matches = this._resHeaders['last-modified'] === response.headers['last-modified'];\n        } else {\n            // If the new response does not include any form of validator (such as in the case where\n            // a client generates an If-Modified-Since request from a source other than the Last-Modified\n            // response header field), and there is only one stored response, and that stored response also\n            // lacks a validator, then that stored response is selected for update.\n            if (!this._resHeaders.etag && !this._resHeaders['last-modified'] && !response.headers.etag && !response.headers['last-modified']) {\n                matches = true;\n            }\n        }\n\n        if (!matches) {\n            return {\n                policy: new this.constructor(request, response),\n                modified: true\n            };\n        }\n\n        // use other header fields provided in the 304 (Not Modified) response to replace all instances\n        // of the corresponding header fields in the stored response.\n        var headers = {};\n        for (var k in this._resHeaders) {\n            headers[k] = k in response.headers && !excludedFromRevalidationUpdate[k] ? response.headers[k] : this._resHeaders[k];\n        }\n\n        var newResponse = Object.assign({}, response, {\n            status: this._status,\n            method: this._method,\n            headers\n        });\n        return {\n            policy: new this.constructor(request, newResponse),\n            modified: false\n        };\n    };\n\n    return CachePolicy;\n}();"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}