{"ast":null,"code":"'use strict';\n\nvar union = require('lodash.union');\nvar without = require('lodash.without');\nvar validate = require('aproba');\nvar flattenTree = require('./flatten-tree.js');\nvar isExtraneous = require('./is-extraneous.js');\nvar validateAllPeerDeps = require('./deps.js').validateAllPeerDeps;\nvar packageId = require('../utils/package-id.js');\nvar moduleName = require('../utils/module-name.js');\nvar npm = require('../npm.js');\n\n// Return true if tree is a part of a cycle that:\n//   A) Never connects to the top of the tree\n//   B) Has not not had a point in the cycle arbitrarily declared its top\n//      yet.\nfunction isDisconnectedCycle(tree, seen) {\n  if (!seen) seen = {};\n  if (tree.isTop || tree.cycleTop || tree.requiredBy.length === 0) {\n    return false;\n  } else if (seen[tree.path]) {\n    return true;\n  } else {\n    seen[tree.path] = true;\n    return tree.requiredBy.every(function (node) {\n      return isDisconnectedCycle(node, Object.create(seen));\n    });\n  }\n}\nvar mutateIntoLogicalTree = module.exports = function (tree) {\n  validate('O', arguments);\n  validateAllPeerDeps(tree, function (tree, pkgname, version) {\n    if (!tree.missingPeers) tree.missingPeers = {};\n    tree.missingPeers[pkgname] = version;\n  });\n  var flat = flattenTree(tree);\n  Object.keys(flat).sort().forEach(function (flatname) {\n    var node = flat[flatname];\n    if (!(node.requiredBy && node.requiredBy.length)) return;\n    if (node.parent) {\n      // If a node is a cycle that never reaches the root of the logical\n      // tree then we'll leave it attached to the root, or else it\n      // would go missing. Further we'll note that this is the node in the\n      // cycle that we picked arbitrarily to be the one attached to the root.\n      // others will fall\n      if (isDisconnectedCycle(node)) {\n        node.cycleTop = true;\n        // Nor do we want to disconnect non-cyclical extraneous modules from the tree.\n      } else if (node.requiredBy.length) {\n        // regular deps though, we do, as we're moving them into the capable\n        // hands of the modules that require them.\n        node.parent.children = without(node.parent.children, node);\n      }\n    }\n    node.requiredBy.forEach(function (parentNode) {\n      parentNode.children = union(parentNode.children, [node]);\n    });\n  });\n  return tree;\n};\nmodule.exports.asReadInstalled = function (tree) {\n  mutateIntoLogicalTree(tree);\n  return translateTree(tree);\n};\nfunction translateTree(tree) {\n  return translateTree_(tree, new Set());\n}\nfunction translateTree_(tree, seen) {\n  var pkg = tree.package;\n  if (seen.has(tree)) return pkg;\n  seen.add(tree);\n  if (pkg._dependencies) return pkg;\n  pkg._dependencies = pkg.dependencies;\n  pkg.dependencies = {};\n  tree.children.forEach(function (child) {\n    const dep = pkg.dependencies[moduleName(child)] = translateTree_(child, seen);\n    if (child.fakeChild) {\n      dep.missing = true;\n      dep.optional = child.package._optional;\n      dep.requiredBy = child.package._spec;\n    }\n  });\n  function markMissing(name, requiredBy) {\n    if (pkg.dependencies[name]) {\n      if (pkg.dependencies[name].missing) return;\n      pkg.dependencies[name].invalid = true;\n      pkg.dependencies[name].realName = name;\n      pkg.dependencies[name].extraneous = false;\n    } else {\n      pkg.dependencies[name] = {\n        requiredBy: requiredBy,\n        missing: true,\n        optional: !!pkg.optionalDependencies[name]\n      };\n    }\n  }\n  Object.keys(tree.missingDeps).forEach(function (name) {\n    markMissing(name, tree.missingDeps[name]);\n  });\n  Object.keys(tree.missingDevDeps).forEach(function (name) {\n    markMissing(name, tree.missingDevDeps[name]);\n  });\n  var checkForMissingPeers = (tree.parent ? [] : [tree]).concat(tree.children);\n  checkForMissingPeers.filter(function (child) {\n    return child.missingPeers;\n  }).forEach(function (child) {\n    Object.keys(child.missingPeers).forEach(function (pkgname) {\n      var version = child.missingPeers[pkgname];\n      var peerPkg = pkg.dependencies[pkgname];\n      if (!peerPkg) {\n        peerPkg = pkg.dependencies[pkgname] = {\n          _id: pkgname + '@' + version,\n          name: pkgname,\n          version: version\n        };\n      }\n      if (!peerPkg.peerMissing) peerPkg.peerMissing = [];\n      peerPkg.peerMissing.push({\n        requiredBy: packageId(child),\n        requires: pkgname + '@' + version\n      });\n    });\n  });\n  pkg.path = tree.path;\n  pkg.error = tree.error;\n  pkg.extraneous = !tree.isTop && (!tree.parent.isTop || !tree.parent.error) && !npm.config.get('global') && isExtraneous(tree);\n  if (tree.target && tree.parent && !tree.parent.target) pkg.link = tree.realpath;\n  return pkg;\n}","map":{"version":3,"names":["union","require","without","validate","flattenTree","isExtraneous","validateAllPeerDeps","packageId","moduleName","npm","isDisconnectedCycle","tree","seen","isTop","cycleTop","requiredBy","length","path","every","node","Object","create","mutateIntoLogicalTree","module","exports","arguments","pkgname","version","missingPeers","flat","keys","sort","forEach","flatname","parent","children","parentNode","asReadInstalled","translateTree","translateTree_","Set","pkg","package","has","add","_dependencies","dependencies","child","dep","fakeChild","missing","optional","_optional","_spec","markMissing","name","invalid","realName","extraneous","optionalDependencies","missingDeps","missingDevDeps","checkForMissingPeers","concat","filter","peerPkg","_id","peerMissing","push","requires","error","config","get","target","link","realpath"],"sources":["/Users/hkateliev/node_modules/npm/lib/install/mutate-into-logical-tree.js"],"sourcesContent":["'use strict'\nvar union = require('lodash.union')\nvar without = require('lodash.without')\nvar validate = require('aproba')\nvar flattenTree = require('./flatten-tree.js')\nvar isExtraneous = require('./is-extraneous.js')\nvar validateAllPeerDeps = require('./deps.js').validateAllPeerDeps\nvar packageId = require('../utils/package-id.js')\nvar moduleName = require('../utils/module-name.js')\nvar npm = require('../npm.js')\n\n// Return true if tree is a part of a cycle that:\n//   A) Never connects to the top of the tree\n//   B) Has not not had a point in the cycle arbitrarily declared its top\n//      yet.\nfunction isDisconnectedCycle (tree, seen) {\n  if (!seen) seen = {}\n  if (tree.isTop || tree.cycleTop || tree.requiredBy.length === 0) {\n    return false\n  } else if (seen[tree.path]) {\n    return true\n  } else {\n    seen[tree.path] = true\n    return tree.requiredBy.every(function (node) {\n      return isDisconnectedCycle(node, Object.create(seen))\n    })\n  }\n}\n\nvar mutateIntoLogicalTree = module.exports = function (tree) {\n  validate('O', arguments)\n\n  validateAllPeerDeps(tree, function (tree, pkgname, version) {\n    if (!tree.missingPeers) tree.missingPeers = {}\n    tree.missingPeers[pkgname] = version\n  })\n\n  var flat = flattenTree(tree)\n\n  Object.keys(flat).sort().forEach(function (flatname) {\n    var node = flat[flatname]\n    if (!(node.requiredBy && node.requiredBy.length)) return\n\n    if (node.parent) {\n      // If a node is a cycle that never reaches the root of the logical\n      // tree then we'll leave it attached to the root, or else it\n      // would go missing. Further we'll note that this is the node in the\n      // cycle that we picked arbitrarily to be the one attached to the root.\n      // others will fall\n      if (isDisconnectedCycle(node)) {\n        node.cycleTop = true\n      // Nor do we want to disconnect non-cyclical extraneous modules from the tree.\n      } else if (node.requiredBy.length) {\n        // regular deps though, we do, as we're moving them into the capable\n        // hands of the modules that require them.\n        node.parent.children = without(node.parent.children, node)\n      }\n    }\n\n    node.requiredBy.forEach(function (parentNode) {\n      parentNode.children = union(parentNode.children, [node])\n    })\n  })\n  return tree\n}\n\nmodule.exports.asReadInstalled = function (tree) {\n  mutateIntoLogicalTree(tree)\n  return translateTree(tree)\n}\n\nfunction translateTree (tree) {\n  return translateTree_(tree, new Set())\n}\n\nfunction translateTree_ (tree, seen) {\n  var pkg = tree.package\n  if (seen.has(tree)) return pkg\n  seen.add(tree)\n  if (pkg._dependencies) return pkg\n  pkg._dependencies = pkg.dependencies\n  pkg.dependencies = {}\n  tree.children.forEach(function (child) {\n    const dep = pkg.dependencies[moduleName(child)] = translateTree_(child, seen)\n    if (child.fakeChild) {\n      dep.missing = true\n      dep.optional = child.package._optional\n      dep.requiredBy = child.package._spec\n    }\n  })\n\n  function markMissing (name, requiredBy) {\n    if (pkg.dependencies[name]) {\n      if (pkg.dependencies[name].missing) return\n      pkg.dependencies[name].invalid = true\n      pkg.dependencies[name].realName = name\n      pkg.dependencies[name].extraneous = false\n    } else {\n      pkg.dependencies[name] = {\n        requiredBy: requiredBy,\n        missing: true,\n        optional: !!pkg.optionalDependencies[name]\n      }\n    }\n  }\n\n  Object.keys(tree.missingDeps).forEach(function (name) {\n    markMissing(name, tree.missingDeps[name])\n  })\n  Object.keys(tree.missingDevDeps).forEach(function (name) {\n    markMissing(name, tree.missingDevDeps[name])\n  })\n  var checkForMissingPeers = (tree.parent ? [] : [tree]).concat(tree.children)\n  checkForMissingPeers.filter(function (child) {\n    return child.missingPeers\n  }).forEach(function (child) {\n    Object.keys(child.missingPeers).forEach(function (pkgname) {\n      var version = child.missingPeers[pkgname]\n      var peerPkg = pkg.dependencies[pkgname]\n      if (!peerPkg) {\n        peerPkg = pkg.dependencies[pkgname] = {\n          _id: pkgname + '@' + version,\n          name: pkgname,\n          version: version\n        }\n      }\n      if (!peerPkg.peerMissing) peerPkg.peerMissing = []\n      peerPkg.peerMissing.push({\n        requiredBy: packageId(child),\n        requires: pkgname + '@' + version\n      })\n    })\n  })\n  pkg.path = tree.path\n\n  pkg.error = tree.error\n  pkg.extraneous = !tree.isTop && (!tree.parent.isTop || !tree.parent.error) && !npm.config.get('global') && isExtraneous(tree)\n  if (tree.target && tree.parent && !tree.parent.target) pkg.link = tree.realpath\n  return pkg\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}