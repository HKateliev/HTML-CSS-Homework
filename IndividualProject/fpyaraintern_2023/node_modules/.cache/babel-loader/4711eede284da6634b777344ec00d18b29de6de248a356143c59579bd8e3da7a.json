{"ast":null,"code":"'use strict';\n\n// calls linkIfExists on unix, or cmdShimIfExists on Windows\n// reads the cmd shim to ensure it's where we need it to be in the case of\n// top level global packages\nconst readCmdShim = require('read-cmd-shim');\nconst cmdShim = require('cmd-shim');\nconst {\n  linkIfExists\n} = require('./link.js');\nconst binLink = (from, to, opts, cb) => {\n  // just for testing\n  const platform = opts._FAKE_PLATFORM_ || process.platform;\n  if (platform !== 'win32') {\n    return linkIfExists(from, to, opts, cb);\n  }\n  if (!opts.clobberLinkGently || opts.force === true || !opts.gently || typeof opts.gently !== 'string') {\n    // easy, just go ahead and delete anything in the way\n    return cmdShim.ifExists(from, to, cb);\n  }\n\n  // read all three shim targets\n  // if any exist, and are not a shim to our gently folder, then\n  // exit with a simulated EEXIST error.\n\n  const shimFiles = [to, to + '.cmd', to + '.ps1'];\n\n  // call this once we've checked all three, if we're good\n  const done = () => cmdShim.ifExists(from, to, cb);\n  const then = times(3, done, cb);\n  shimFiles.forEach(to => isClobberable(from, to, opts, then));\n};\nconst times = (n, ok, cb) => {\n  let errState = null;\n  return er => {\n    if (!errState) {\n      if (er) {\n        cb(errState = er);\n      } else if (--n === 0) {\n        ok();\n      }\n    }\n  };\n};\nconst isClobberable = (from, to, opts, cb) => {\n  readCmdShim(to, (er, target) => {\n    // either going to get an error, or the target of where this\n    // cmd shim points.\n    // shim, not in opts.gently: simulate EEXIST\n    // not a shim: simulate EEXIST\n    // ENOENT: fine, move forward\n    // shim in opts.gently: fine\n    if (er) {\n      switch (er.code) {\n        case 'ENOENT':\n          // totally fine, nothing there to clobber\n          return cb();\n        case 'ENOTASHIM':\n          // something is there, and it's not one of ours\n          return cb(simulateEEXIST(from, to));\n        default:\n          // would probably fail this way later anyway\n          // can't read the file, likely can't write it either\n          return cb(er);\n      }\n    }\n    // no error, check the target\n    if (target.indexOf(opts.gently) !== 0) {\n      return cb(simulateEEXIST(from, to));\n    }\n    // ok!  it's one of ours.\n    return cb();\n  });\n};\nconst simulateEEXIST = (from, to) => {\n  // simulate the EEXIST we'd get from fs.symlink to the file\n  const err = new Error('EEXIST: file already exists, cmd shim \\'' + from + '\\' -> \\'' + to + '\\'');\n  err.code = 'EEXIST';\n  err.path = from;\n  err.dest = to;\n  return err;\n};\nmodule.exports = binLink;","map":{"version":3,"names":["readCmdShim","require","cmdShim","linkIfExists","binLink","from","to","opts","cb","platform","_FAKE_PLATFORM_","process","clobberLinkGently","force","gently","ifExists","shimFiles","done","then","times","forEach","isClobberable","n","ok","errState","er","target","code","simulateEEXIST","indexOf","err","Error","path","dest","module","exports"],"sources":["/Users/hkateliev/node_modules/npm/node_modules/gentle-fs/lib/bin-link.js"],"sourcesContent":["'use strict'\n// calls linkIfExists on unix, or cmdShimIfExists on Windows\n// reads the cmd shim to ensure it's where we need it to be in the case of\n// top level global packages\n\nconst readCmdShim = require('read-cmd-shim')\nconst cmdShim = require('cmd-shim')\nconst {linkIfExists} = require('./link.js')\n\nconst binLink = (from, to, opts, cb) => {\n  // just for testing\n  const platform = opts._FAKE_PLATFORM_ || process.platform\n  if (platform !== 'win32') {\n    return linkIfExists(from, to, opts, cb)\n  }\n\n  if (!opts.clobberLinkGently ||\n      opts.force === true ||\n      !opts.gently ||\n      typeof opts.gently !== 'string') {\n    // easy, just go ahead and delete anything in the way\n    return cmdShim.ifExists(from, to, cb)\n  }\n\n  // read all three shim targets\n  // if any exist, and are not a shim to our gently folder, then\n  // exit with a simulated EEXIST error.\n\n  const shimFiles = [\n    to,\n    to + '.cmd',\n    to + '.ps1'\n  ]\n\n  // call this once we've checked all three, if we're good\n  const done = () => cmdShim.ifExists(from, to, cb)\n  const then = times(3, done, cb)\n  shimFiles.forEach(to => isClobberable(from, to, opts, then))\n}\n\nconst times = (n, ok, cb) => {\n  let errState = null\n  return er => {\n    if (!errState) {\n      if (er) {\n        cb(errState = er)\n      } else if (--n === 0) {\n        ok()\n      }\n    }\n  }\n}\n\nconst isClobberable = (from, to, opts, cb) => {\n  readCmdShim(to, (er, target) => {\n    // either going to get an error, or the target of where this\n    // cmd shim points.\n    // shim, not in opts.gently: simulate EEXIST\n    // not a shim: simulate EEXIST\n    // ENOENT: fine, move forward\n    // shim in opts.gently: fine\n    if (er) {\n      switch (er.code) {\n        case 'ENOENT':\n          // totally fine, nothing there to clobber\n          return cb()\n        case 'ENOTASHIM':\n          // something is there, and it's not one of ours\n          return cb(simulateEEXIST(from, to))\n        default:\n          // would probably fail this way later anyway\n          // can't read the file, likely can't write it either\n          return cb(er)\n      }\n    }\n    // no error, check the target\n    if (target.indexOf(opts.gently) !== 0) {\n      return cb(simulateEEXIST(from, to))\n    }\n    // ok!  it's one of ours.\n    return cb()\n  })\n}\n\nconst simulateEEXIST = (from, to) => {\n  // simulate the EEXIST we'd get from fs.symlink to the file\n  const err = new Error('EEXIST: file already exists, cmd shim \\'' +\n    from + '\\' -> \\'' + to + '\\'')\n\n  err.code = 'EEXIST'\n  err.path = from\n  err.dest = to\n  return err\n}\n\nmodule.exports = binLink\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}