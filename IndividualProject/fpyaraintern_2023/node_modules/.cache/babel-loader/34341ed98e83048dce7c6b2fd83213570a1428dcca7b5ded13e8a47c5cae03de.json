{"ast":null,"code":"'use strict';\n\nconst genfun = require('genfun');\nclass Duck extends Function {\n  // Duck.impl(Foo, [String, Array], { frob (str, arr) { ... }})\n  impl(target, types, impls) {\n    if (!impls && !isArray(types)) {\n      impls = types;\n      types = [];\n    }\n    if (!impls && this.isDerivable) {\n      impls = this._defaultImpls;\n    }\n    if (!impls) {\n      impls = {};\n    }\n    if (typeof target === 'function' && !target.isGenfun) {\n      target = target.prototype;\n    }\n    checkImpls(this, target, impls);\n    checkArgTypes(this, types);\n    this._constraints.forEach(c => {\n      if (!c.verify(target, types)) {\n        throw new Error(`Implementations of ${this.name || 'this protocol'} must first implement ${c.parent.name || 'its constraint protocols defined in opts.where.'}`);\n      }\n    });\n    this._methodNames.forEach(name => {\n      defineMethod(this, name, target, types, impls);\n    });\n  }\n  hasImpl(arg, args) {\n    args = args || [];\n    const fns = this._methodNames;\n    var gf;\n    if (typeof arg === 'function' && !arg.isGenfun) {\n      arg = arg.prototype;\n    }\n    args = args.map(arg => {\n      if (typeof arg === 'function' && !arg.isGenfun) {\n        return arg.prototype;\n      } else {\n        return arg;\n      }\n    });\n    for (var i = 0; i < fns.length; i++) {\n      gf = arg[fns[i]];\n      if (!gf || (gf.hasMethod ? !gf.hasMethod.apply(gf, args) : typeof gf === 'function')) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // MyDuck.matches('a', ['this', 'c'])\n  matches(thisType, argTypes) {\n    if (!argTypes && isArray(thisType)) {\n      argTypes = thisType;\n      thisType = 'this';\n    }\n    if (!thisType) {\n      thisType = 'this';\n    }\n    if (!argTypes) {\n      argTypes = [];\n    }\n    return new Constraint(this, thisType, argTypes);\n  }\n}\nDuck.prototype.isDuck = true;\nDuck.prototype.isProtocol = true;\nconst Protoduck = module.exports = define(['duck'], {\n  createGenfun: ['duck', _metaCreateGenfun],\n  addMethod: ['duck', _metaAddMethod]\n}, {\n  name: 'Protoduck'\n});\nconst noImplFound = module.exports.noImplFound = genfun.noApplicableMethod;\nmodule.exports.define = define;\nfunction define(types, spec, opts) {\n  if (!isArray(types)) {\n    // protocol(spec, opts?) syntax for method-based protocols\n    opts = spec;\n    spec = types;\n    types = [];\n  }\n  const duck = function (thisType, argTypes) {\n    return duck.matches(thisType, argTypes);\n  };\n  Object.setPrototypeOf(duck, Duck.prototype);\n  duck.isDerivable = true;\n  Object.defineProperty(duck, 'name', {\n    value: opts && opts.name || 'Protocol'\n  });\n  if (opts && opts.where) {\n    let where = opts.where;\n    if (!isArray(opts.where)) {\n      where = [opts.where];\n    }\n    duck._constraints = where.map(w => w.isProtocol // `where: [Foo]`\n    ? w.matches() : w);\n  } else {\n    duck._constraints = [];\n  }\n  duck.isProtocol = true;\n  duck._metaobject = opts && opts.metaobject;\n  duck._types = types;\n  duck._defaultImpls = {};\n  duck._gfTypes = {};\n  duck._methodNames = Object.keys(spec);\n  duck._methodNames.forEach(name => {\n    checkMethodSpec(duck, name, spec);\n  });\n  duck._constraints.forEach(c => c.attach(duck));\n  return duck;\n}\nfunction checkMethodSpec(duck, name, spec) {\n  let gfTypes = spec[name];\n  if (typeof gfTypes === 'function') {\n    duck._defaultImpls[name] = gfTypes;\n    gfTypes = [gfTypes];\n  }\n  if (typeof gfTypes[gfTypes.length - 1] === 'function') {\n    duck._defaultImpls[name] = gfTypes.pop();\n  } else {\n    duck.isDerivable = false;\n  }\n  duck._gfTypes[name] = gfTypes.map(typeId => {\n    const idx = duck._types.indexOf(typeId);\n    if (idx === -1) {\n      throw new Error(`type '${typeId}' for function '${name}' does not match any protocol types (${duck._types.join(', ')}).`);\n    } else {\n      return idx;\n    }\n  });\n}\nfunction defineMethod(duck, name, target, types, impls) {\n  const methodTypes = duck._gfTypes[name].map(function (typeIdx) {\n    return types[typeIdx];\n  });\n  for (let i = methodTypes.length - 1; i >= 0; i--) {\n    if (methodTypes[i] === undefined) {\n      methodTypes.pop();\n    } else {\n      break;\n    }\n  }\n  const useMetaobject = duck._metaobject && duck._metaobject !== Protoduck;\n  // `target` does not necessarily inherit from `Object`\n  if (!Object.prototype.hasOwnProperty.call(target, name)) {\n    // Make a genfun if there's nothing there\n    const gf = useMetaobject ? duck._metaobject.createGenfun(duck, target, name, null) : _metaCreateGenfun(duck, target, name, null);\n    target[name] = gf;\n  } else if (typeof target[name] === 'function' && !target[name].isGenfun) {\n    // Turn non-gf functions into genfuns\n    const gf = useMetaobject ? duck._metaobject.createGenfun(duck, target, name, target[name]) : _metaCreateGenfun(duck, target, name, target[name]);\n    target[name] = gf;\n  }\n  const fn = impls[name] || duck._defaultImpls[name];\n  if (fn) {\n    // checkImpls made sure this is safe\n    useMetaobject ? duck._metaobject.addMethod(duck, target, name, methodTypes, fn) : _metaAddMethod(duck, target, name, methodTypes, fn);\n  }\n}\nfunction checkImpls(duck, target, impls) {\n  duck._methodNames.forEach(function (name) {\n    if (!impls[name] && !duck._defaultImpls[name] &&\n    // Existing methods on the target are acceptable defaults.\n    typeof target[name] !== 'function') {\n      throw new Error(`Missing implementation for ${formatMethod(duck, name, duck.name)}. Make sure the method is present in your ${duck.name || 'protocol'} definition. Required methods: ${duck._methodNames.filter(m => {\n        return !duck._defaultImpls[m];\n      }).map(m => formatMethod(duck, m)).join(', ')}.`);\n    }\n  });\n  Object.keys(impls).forEach(function (name) {\n    if (duck._methodNames.indexOf(name) === -1) {\n      throw new Error(`${name}() was included in the impl, but is not part of ${duck.name || 'the protocol'}. Allowed methods: ${duck._methodNames.map(m => formatMethod(duck, m)).join(', ')}.`);\n    }\n  });\n}\nfunction formatMethod(duck, name, withDuckName) {\n  return `${withDuckName && duck.name ? `${duck.name}#` : ''}${name}(${duck._gfTypes[name].map(n => duck._types[n]).join(', ')})`;\n}\nfunction checkArgTypes(duck, types) {\n  var requiredTypes = duck._types;\n  if (types.length > requiredTypes.length) {\n    throw new Error(`${duck.name || 'Protocol'} expects to be defined across ${requiredTypes.length} type${requiredTypes.length > 1 ? 's' : ''}, but ${types.length} ${types.length > 1 ? 'were' : 'was'} specified.`);\n  }\n}\nfunction typeName(obj) {\n  return /\\[object ([a-zA-Z0-9]+)\\]/.exec({}.toString.call(obj))[1];\n}\nfunction installMethodErrorMessage(proto, gf, target, name) {\n  noImplFound.add([gf], function (gf, thisArg, args) {\n    let parent = Object.getPrototypeOf(thisArg);\n    while (parent && parent[name] === gf) {\n      parent = Object.getPrototypeOf(parent);\n    }\n    if (parent && parent[name] && typeof parent[name] === 'function') {}\n    var msg = `No ${typeName(thisArg)} impl for ${proto.name ? `${proto.name}#` : ''}${name}(${[].map.call(args, typeName).join(', ')}). You must implement ${proto.name ? formatMethod(proto, name, true) : `the protocol ${formatMethod(proto, name)} belongs to`} in order to call ${typeName(thisArg)}#${name}(${[].map.call(args, typeName).join(', ')}).`;\n    const err = new Error(msg);\n    err.protocol = proto;\n    err.function = gf;\n    err.thisArg = thisArg;\n    err.args = args;\n    err.code = 'ENOIMPL';\n    throw err;\n  });\n}\nfunction isArray(x) {\n  return Object.prototype.toString.call(x) === '[object Array]';\n}\n\n// Metaobject Protocol\nProtoduck.impl(Protoduck); // defaults configured by definition\n\nfunction _metaCreateGenfun(proto, target, name, deflt) {\n  var gf = genfun({\n    default: deflt,\n    name: `${proto.name ? `${proto.name}#` : ''}${name}`\n  });\n  installMethodErrorMessage(proto, gf, target, name);\n  gf.duck = proto;\n  return gf;\n}\nfunction _metaAddMethod(duck, target, name, methodTypes, fn) {\n  return target[name].add(methodTypes, fn);\n}\n\n// Constraints\nclass Constraint {\n  constructor(parent, thisType, argTypes) {\n    this.parent = parent;\n    this.target = thisType;\n    this.types = argTypes;\n  }\n  attach(obj) {\n    this.child = obj;\n    if (this.target === 'this') {\n      this.thisIdx = 'this';\n    } else {\n      const idx = this.child._types.indexOf(this.target);\n      if (idx === -1) {\n        this.thisIdx = null;\n      } else {\n        this.thisIdx = idx;\n      }\n    }\n    this.indices = this.types.map(typeId => {\n      if (typeId === 'this') {\n        return 'this';\n      } else {\n        const idx = this.child._types.indexOf(typeId);\n        if (idx === -1) {\n          return null;\n        } else {\n          return idx;\n        }\n      }\n    });\n  }\n  verify(target, types) {\n    const thisType = this.thisIdx === 'this' || this.thisIdx == null ? target : types[this.thisIdx];\n    const parentTypes = this.indices.map(idx => {\n      if (idx === 'this') {\n        return target;\n      } else if (idx === 'this') {\n        return types[this.thisIdx];\n      } else if (idx === null) {\n        return Object;\n      } else {\n        return types[idx] || Object.prototype;\n      }\n    });\n    return this.parent.hasImpl(thisType, parentTypes);\n  }\n}\nConstraint.prototype.isConstraint = true;","map":{"version":3,"names":["genfun","require","Duck","Function","impl","target","types","impls","isArray","isDerivable","_defaultImpls","isGenfun","prototype","checkImpls","checkArgTypes","_constraints","forEach","c","verify","Error","name","parent","_methodNames","defineMethod","hasImpl","arg","args","fns","gf","map","i","length","hasMethod","apply","matches","thisType","argTypes","Constraint","isDuck","isProtocol","Protoduck","module","exports","define","createGenfun","_metaCreateGenfun","addMethod","_metaAddMethod","noImplFound","noApplicableMethod","spec","opts","duck","Object","setPrototypeOf","defineProperty","value","where","w","_metaobject","metaobject","_types","_gfTypes","keys","checkMethodSpec","attach","gfTypes","pop","typeId","idx","indexOf","join","methodTypes","typeIdx","undefined","useMetaobject","hasOwnProperty","call","fn","formatMethod","filter","m","withDuckName","n","requiredTypes","typeName","obj","exec","toString","installMethodErrorMessage","proto","add","thisArg","getPrototypeOf","msg","err","protocol","function","code","x","deflt","default","constructor","child","thisIdx","indices","parentTypes","isConstraint"],"sources":["/Users/hkateliev/node_modules/npm/node_modules/protoduck/index.js"],"sourcesContent":["'use strict'\n\nconst genfun = require('genfun')\n\nclass Duck extends Function {\n  // Duck.impl(Foo, [String, Array], { frob (str, arr) { ... }})\n  impl (target, types, impls) {\n    if (!impls && !isArray(types)) {\n      impls = types\n      types = []\n    }\n    if (!impls && this.isDerivable) {\n      impls = this._defaultImpls\n    }\n    if (!impls) {\n      impls = {}\n    }\n    if (typeof target === 'function' && !target.isGenfun) {\n      target = target.prototype\n    }\n    checkImpls(this, target, impls)\n    checkArgTypes(this, types)\n    this._constraints.forEach(c => {\n      if (!c.verify(target, types)) {\n        throw new Error(`Implementations of ${\n          this.name || 'this protocol'\n        } must first implement ${\n          c.parent.name || 'its constraint protocols defined in opts.where.'\n        }`)\n      }\n    })\n    this._methodNames.forEach(name => {\n      defineMethod(this, name, target, types, impls)\n    })\n  }\n\n  hasImpl (arg, args) {\n    args = args || []\n    const fns = this._methodNames\n    var gf\n    if (typeof arg === 'function' && !arg.isGenfun) {\n      arg = arg.prototype\n    }\n    args = args.map(arg => {\n      if (typeof arg === 'function' && !arg.isGenfun) {\n        return arg.prototype\n      } else {\n        return arg\n      }\n    })\n    for (var i = 0; i < fns.length; i++) {\n      gf = arg[fns[i]]\n      if (!gf ||\n          (gf.hasMethod\n            ? !gf.hasMethod.apply(gf, args)\n            : typeof gf === 'function')) {\n        return false\n      }\n    }\n    return true\n  }\n\n  // MyDuck.matches('a', ['this', 'c'])\n  matches (thisType, argTypes) {\n    if (!argTypes && isArray(thisType)) {\n      argTypes = thisType\n      thisType = 'this'\n    }\n    if (!thisType) {\n      thisType = 'this'\n    }\n    if (!argTypes) {\n      argTypes = []\n    }\n    return new Constraint(this, thisType, argTypes)\n  }\n}\nDuck.prototype.isDuck = true\nDuck.prototype.isProtocol = true\n\nconst Protoduck = module.exports = define(['duck'], {\n  createGenfun: ['duck', _metaCreateGenfun],\n  addMethod: ['duck', _metaAddMethod]\n}, { name: 'Protoduck' })\n\nconst noImplFound = module.exports.noImplFound = genfun.noApplicableMethod\n\nmodule.exports.define = define\nfunction define (types, spec, opts) {\n  if (!isArray(types)) {\n    // protocol(spec, opts?) syntax for method-based protocols\n    opts = spec\n    spec = types\n    types = []\n  }\n  const duck = function (thisType, argTypes) {\n    return duck.matches(thisType, argTypes)\n  }\n  Object.setPrototypeOf(duck, Duck.prototype)\n  duck.isDerivable = true\n  Object.defineProperty(duck, 'name', {\n    value: (opts && opts.name) || 'Protocol'\n  })\n  if (opts && opts.where) {\n    let where = opts.where\n    if (!isArray(opts.where)) { where = [opts.where] }\n    duck._constraints = where.map(w => w.isProtocol // `where: [Foo]`\n      ? w.matches()\n      : w\n    )\n  } else {\n    duck._constraints = []\n  }\n  duck.isProtocol = true\n  duck._metaobject = opts && opts.metaobject\n  duck._types = types\n  duck._defaultImpls = {}\n  duck._gfTypes = {}\n  duck._methodNames = Object.keys(spec)\n  duck._methodNames.forEach(name => {\n    checkMethodSpec(duck, name, spec)\n  })\n  duck._constraints.forEach(c => c.attach(duck))\n  return duck\n}\n\nfunction checkMethodSpec (duck, name, spec) {\n  let gfTypes = spec[name]\n  if (typeof gfTypes === 'function') {\n    duck._defaultImpls[name] = gfTypes\n    gfTypes = [gfTypes]\n  } if (typeof gfTypes[gfTypes.length - 1] === 'function') {\n    duck._defaultImpls[name] = gfTypes.pop()\n  } else {\n    duck.isDerivable = false\n  }\n  duck._gfTypes[name] = gfTypes.map(typeId => {\n    const idx = duck._types.indexOf(typeId)\n    if (idx === -1) {\n      throw new Error(\n        `type '${\n          typeId\n        }' for function '${\n          name\n        }' does not match any protocol types (${\n          duck._types.join(', ')\n        }).`\n      )\n    } else {\n      return idx\n    }\n  })\n}\n\nfunction defineMethod (duck, name, target, types, impls) {\n  const methodTypes = duck._gfTypes[name].map(function (typeIdx) {\n    return types[typeIdx]\n  })\n  for (let i = methodTypes.length - 1; i >= 0; i--) {\n    if (methodTypes[i] === undefined) {\n      methodTypes.pop()\n    } else {\n      break\n    }\n  }\n  const useMetaobject = duck._metaobject && duck._metaobject !== Protoduck\n  // `target` does not necessarily inherit from `Object`\n  if (!Object.prototype.hasOwnProperty.call(target, name)) {\n    // Make a genfun if there's nothing there\n    const gf = useMetaobject\n      ? duck._metaobject.createGenfun(duck, target, name, null)\n      : _metaCreateGenfun(duck, target, name, null)\n    target[name] = gf\n  } else if (typeof target[name] === 'function' && !target[name].isGenfun) {\n    // Turn non-gf functions into genfuns\n    const gf = useMetaobject\n      ? duck._metaobject.createGenfun(duck, target, name, target[name])\n      : _metaCreateGenfun(duck, target, name, target[name])\n    target[name] = gf\n  }\n\n  const fn = impls[name] || duck._defaultImpls[name]\n  if (fn) { // checkImpls made sure this is safe\n    useMetaobject\n      ? duck._metaobject.addMethod(duck, target, name, methodTypes, fn)\n      : _metaAddMethod(duck, target, name, methodTypes, fn)\n  }\n}\n\nfunction checkImpls (duck, target, impls) {\n  duck._methodNames.forEach(function (name) {\n    if (\n      !impls[name] &&\n      !duck._defaultImpls[name] &&\n      // Existing methods on the target are acceptable defaults.\n      typeof target[name] !== 'function'\n    ) {\n      throw new Error(`Missing implementation for ${\n        formatMethod(duck, name, duck.name)\n      }. Make sure the method is present in your ${\n        duck.name || 'protocol'\n      } definition. Required methods: ${\n        duck._methodNames.filter(m => {\n          return !duck._defaultImpls[m]\n        }).map(m => formatMethod(duck, m)).join(', ')\n      }.`)\n    }\n  })\n  Object.keys(impls).forEach(function (name) {\n    if (duck._methodNames.indexOf(name) === -1) {\n      throw new Error(\n        `${name}() was included in the impl, but is not part of ${\n          duck.name || 'the protocol'\n        }. Allowed methods: ${\n          duck._methodNames.map(m => formatMethod(duck, m)).join(', ')\n        }.`\n      )\n    }\n  })\n}\n\nfunction formatMethod (duck, name, withDuckName) {\n  return `${\n    withDuckName && duck.name ? `${duck.name}#` : ''\n  }${name}(${duck._gfTypes[name].map(n => duck._types[n]).join(', ')})`\n}\n\nfunction checkArgTypes (duck, types) {\n  var requiredTypes = duck._types\n  if (types.length > requiredTypes.length) {\n    throw new Error(\n      `${\n        duck.name || 'Protocol'\n      } expects to be defined across ${\n        requiredTypes.length\n      } type${requiredTypes.length > 1 ? 's' : ''}, but ${\n        types.length\n      } ${types.length > 1 ? 'were' : 'was'} specified.`\n    )\n  }\n}\n\nfunction typeName (obj) {\n  return (/\\[object ([a-zA-Z0-9]+)\\]/).exec(({}).toString.call(obj))[1]\n}\n\nfunction installMethodErrorMessage (proto, gf, target, name) {\n  noImplFound.add([gf], function (gf, thisArg, args) {\n    let parent = Object.getPrototypeOf(thisArg)\n    while (parent && parent[name] === gf) {\n      parent = Object.getPrototypeOf(parent)\n    }\n    if (parent && parent[name] && typeof parent[name] === 'function') {\n    }\n    var msg = `No ${typeName(thisArg)} impl for ${\n      proto.name ? `${proto.name}#` : ''\n    }${name}(${[].map.call(args, typeName).join(', ')}). You must implement ${\n      proto.name\n        ? formatMethod(proto, name, true)\n        : `the protocol ${formatMethod(proto, name)} belongs to`\n    } in order to call ${typeName(thisArg)}#${name}(${\n      [].map.call(args, typeName).join(', ')\n    }).`\n    const err = new Error(msg)\n    err.protocol = proto\n    err.function = gf\n    err.thisArg = thisArg\n    err.args = args\n    err.code = 'ENOIMPL'\n    throw err\n  })\n}\n\nfunction isArray (x) {\n  return Object.prototype.toString.call(x) === '[object Array]'\n}\n\n// Metaobject Protocol\nProtoduck.impl(Protoduck) // defaults configured by definition\n\nfunction _metaCreateGenfun (proto, target, name, deflt) {\n  var gf = genfun({\n    default: deflt,\n    name: `${proto.name ? `${proto.name}#` : ''}${name}`\n  })\n  installMethodErrorMessage(proto, gf, target, name)\n  gf.duck = proto\n  return gf\n}\n\nfunction _metaAddMethod (duck, target, name, methodTypes, fn) {\n  return target[name].add(methodTypes, fn)\n}\n\n// Constraints\nclass Constraint {\n  constructor (parent, thisType, argTypes) {\n    this.parent = parent\n    this.target = thisType\n    this.types = argTypes\n  }\n\n  attach (obj) {\n    this.child = obj\n    if (this.target === 'this') {\n      this.thisIdx = 'this'\n    } else {\n      const idx = this.child._types.indexOf(this.target)\n      if (idx === -1) {\n        this.thisIdx = null\n      } else {\n        this.thisIdx = idx\n      }\n    }\n    this.indices = this.types.map(typeId => {\n      if (typeId === 'this') {\n        return 'this'\n      } else {\n        const idx = this.child._types.indexOf(typeId)\n        if (idx === -1) {\n          return null\n        } else {\n          return idx\n        }\n      }\n    })\n  }\n\n  verify (target, types) {\n    const thisType = (\n      this.thisIdx === 'this' || this.thisIdx == null\n    )\n      ? target\n      : types[this.thisIdx]\n    const parentTypes = this.indices.map(idx => {\n      if (idx === 'this') {\n        return target\n      } else if (idx === 'this') {\n        return types[this.thisIdx]\n      } else if (idx === null) {\n        return Object\n      } else {\n        return types[idx] || Object.prototype\n      }\n    })\n    return this.parent.hasImpl(thisType, parentTypes)\n  }\n}\nConstraint.prototype.isConstraint = true\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}