{"ast":null,"code":"// look up the realpath, but cache stats to minimize overhead\n// If the parent folder is in  the realpath cache, then we just\n// lstat the child, since there's no need to do a full realpath\n// This is not a separate module, and is much simpler than Node's\n// built-in fs.realpath, because we only care about symbolic links,\n// so we can handle many fewer edge cases.\n\nconst fs = require('fs');\n/* istanbul ignore next */\nconst promisify = require('util').promisify || require('util-promisify');\nconst readlink = promisify(fs.readlink);\nconst lstat = promisify(fs.lstat);\nconst {\n  resolve,\n  basename,\n  dirname\n} = require('path');\nconst realpathCached = (path, rpcache, stcache, depth) => {\n  // just a safety against extremely deep eloops\n  /* istanbul ignore next */\n  if (depth > 2000) throw eloop(path);\n  path = resolve(path);\n  if (rpcache.has(path)) return Promise.resolve(rpcache.get(path));\n  const dir = dirname(path);\n  const base = basename(path);\n  if (base && rpcache.has(dir)) return realpathChild(dir, base, rpcache, stcache, depth);\n\n  // if it's the root, then we know it's real\n  if (!base) {\n    rpcache.set(dir, dir);\n    return Promise.resolve(dir);\n  }\n\n  // the parent, what is that?\n  // find out, and then come back.\n  return realpathCached(dir, rpcache, stcache, depth + 1).then(() => realpathCached(path, rpcache, stcache, depth + 1));\n};\nconst lstatCached = (path, stcache) => {\n  if (stcache.has(path)) return Promise.resolve(stcache.get(path));\n  const p = lstat(path).then(st => {\n    stcache.set(path, st);\n    return st;\n  });\n  stcache.set(path, p);\n  return p;\n};\n\n// This is a slight fib, as it doesn't actually occur during a stat syscall.\n// But file systems are giant piles of lies, so whatever.\nconst eloop = path => Object.assign(new Error(`ELOOP: too many symbolic links encountered, stat '${path}'`), {\n  errno: -62,\n  syscall: 'stat',\n  code: 'ELOOP',\n  path: path\n});\nconst realpathChild = (dir, base, rpcache, stcache, depth) => {\n  const realdir = rpcache.get(dir);\n  // that unpossible\n  /* istanbul ignore next */\n  if (typeof realdir === 'undefined') throw new Error('in realpathChild without parent being in realpath cache');\n  const realish = resolve(realdir, base);\n  return lstatCached(realish, stcache).then(st => {\n    if (!st.isSymbolicLink()) {\n      rpcache.set(resolve(dir, base), realish);\n      return realish;\n    }\n    let res;\n    return readlink(realish).then(target => {\n      const resolved = res = resolve(realdir, target);\n      if (realish === resolved) throw eloop(realish);\n      return realpathCached(resolved, rpcache, stcache, depth + 1);\n    }).then(real => {\n      rpcache.set(resolve(dir, base), real);\n      return real;\n    });\n  });\n};\nmodule.exports = realpathCached;","map":{"version":3,"names":["fs","require","promisify","readlink","lstat","resolve","basename","dirname","realpathCached","path","rpcache","stcache","depth","eloop","has","Promise","get","dir","base","realpathChild","set","then","lstatCached","p","st","Object","assign","Error","errno","syscall","code","realdir","realish","isSymbolicLink","res","target","resolved","real","module","exports"],"sources":["/Users/hkateliev/node_modules/npm/node_modules/read-package-tree/realpath.js"],"sourcesContent":["// look up the realpath, but cache stats to minimize overhead\n// If the parent folder is in  the realpath cache, then we just\n// lstat the child, since there's no need to do a full realpath\n// This is not a separate module, and is much simpler than Node's\n// built-in fs.realpath, because we only care about symbolic links,\n// so we can handle many fewer edge cases.\n\nconst fs = require('fs')\n/* istanbul ignore next */\nconst promisify = require('util').promisify || require('util-promisify')\nconst readlink = promisify(fs.readlink)\nconst lstat = promisify(fs.lstat)\nconst { resolve, basename, dirname } = require('path')\n\nconst realpathCached = (path, rpcache, stcache, depth) => {\n  // just a safety against extremely deep eloops\n  /* istanbul ignore next */\n  if (depth > 2000)\n    throw eloop(path)\n\n  path = resolve(path)\n  if (rpcache.has(path))\n    return Promise.resolve(rpcache.get(path))\n\n  const dir = dirname(path)\n  const base = basename(path)\n\n  if (base && rpcache.has(dir))\n    return realpathChild(dir, base, rpcache, stcache, depth)\n\n  // if it's the root, then we know it's real\n  if (!base) {\n    rpcache.set(dir, dir)\n    return Promise.resolve(dir)\n  }\n\n  // the parent, what is that?\n  // find out, and then come back.\n  return realpathCached(dir, rpcache, stcache, depth + 1).then(() =>\n    realpathCached(path, rpcache, stcache, depth + 1))\n}\n\nconst lstatCached = (path, stcache) => {\n  if (stcache.has(path))\n    return Promise.resolve(stcache.get(path))\n\n  const p = lstat(path).then(st => {\n    stcache.set(path, st)\n    return st\n  })\n  stcache.set(path, p)\n  return p\n}\n\n// This is a slight fib, as it doesn't actually occur during a stat syscall.\n// But file systems are giant piles of lies, so whatever.\nconst eloop = path =>\n  Object.assign(new Error(\n    `ELOOP: too many symbolic links encountered, stat '${path}'`), {\n    errno: -62,\n    syscall: 'stat',\n    code: 'ELOOP',\n    path: path,\n  })\n\nconst realpathChild = (dir, base, rpcache, stcache, depth) => {\n  const realdir = rpcache.get(dir)\n  // that unpossible\n  /* istanbul ignore next */\n  if (typeof realdir === 'undefined')\n    throw new Error('in realpathChild without parent being in realpath cache')\n\n  const realish = resolve(realdir, base)\n  return lstatCached(realish, stcache).then(st => {\n    if (!st.isSymbolicLink()) {\n      rpcache.set(resolve(dir, base), realish)\n      return realish\n    }\n\n    let res\n    return readlink(realish).then(target => {\n      const resolved = res = resolve(realdir, target)\n      if (realish === resolved)\n        throw eloop(realish)\n\n      return realpathCached(resolved, rpcache, stcache, depth + 1)\n    }).then(real => {\n      rpcache.set(resolve(dir, base), real)\n      return real\n    })\n  })\n}\n\nmodule.exports = realpathCached\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}