{"ast":null,"code":"'use strict';\n\nconst Method = require('./method');\nconst Role = require('./role');\nconst util = require('./util');\nconst kCache = Symbol('cache');\nconst kDefaultMethod = Symbol('defaultMethod');\nconst kMethods = Symbol('methods');\nconst kNoNext = Symbol('noNext');\nmodule.exports = function genfun(opts) {\n  function gf() {\n    if (!gf[kMethods].length && gf[kDefaultMethod]) {\n      return gf[kDefaultMethod].func.apply(this, arguments);\n    } else {\n      return gf.applyGenfun(this, arguments);\n    }\n  }\n  Object.setPrototypeOf(gf, Genfun.prototype);\n  gf[kMethods] = [];\n  gf[kCache] = {\n    key: [],\n    methods: [],\n    state: STATES.UNINITIALIZED\n  };\n  if (opts && typeof opts === 'function') {\n    gf.add(opts);\n  } else if (opts && opts.default) {\n    gf.add(opts.default);\n  }\n  if (opts && opts.name) {\n    Object.defineProperty(gf, 'name', {\n      value: opts.name\n    });\n  }\n  if (opts && opts.noNextMethod) {\n    gf[kNoNext] = true;\n  }\n  return gf;\n};\nclass Genfun extends Function {}\nGenfun.prototype.isGenfun = true;\nconst STATES = {\n  UNINITIALIZED: 0,\n  MONOMORPHIC: 1,\n  POLYMORPHIC: 2,\n  MEGAMORPHIC: 3\n};\nconst MAX_CACHE_SIZE = 32;\n\n/**\n * Defines a method on a generic function.\n *\n * @function\n * @param {Array-like} selector - Selector array for dispatching the method.\n * @param {Function} methodFunction - Function to execute when the method\n *                                    successfully dispatches.\n */\nGenfun.prototype.add = function addMethod(selector, func) {\n  if (!func && typeof selector === 'function') {\n    func = selector;\n    selector = [];\n  }\n  selector = [].slice.call(selector);\n  for (var i = 0; i < selector.length; i++) {\n    if (!selector.hasOwnProperty(i)) {\n      selector[i] = Object.prototype;\n    }\n  }\n  this[kCache] = {\n    key: [],\n    methods: [],\n    state: STATES.UNINITIALIZED\n  };\n  let method = new Method(this, selector, func);\n  if (selector.length) {\n    this[kMethods].push(method);\n  } else {\n    this[kDefaultMethod] = method;\n  }\n  return this;\n};\n\n/**\n * Removes a previously-defined method on `genfun` that matches\n * `selector` exactly.\n *\n * @function\n * @param {Genfun} genfun - Genfun to remove a method from.\n * @param {Array-like} selector - Objects to match on when finding a\n *                                    method to remove.\n */\nGenfun.prototype.rm = function removeMethod() {\n  throw new Error('not yet implemented');\n};\n\n/**\n * Returns true if there are methods that apply to the given arguments on\n * `genfun`. Additionally, makes sure the cache is warmed up for the given\n * arguments.\n *\n */\nGenfun.prototype.hasMethod = function hasMethod() {\n  const methods = this.getApplicableMethods(arguments);\n  return !!(methods && methods.length);\n};\n\n/**\n * This generic function is called when `genfun` has been called and no\n * applicable method was found. The default method throws an `Error`.\n *\n * @function\n * @param {Genfun} genfun - Generic function instance that was called.\n * @param {*} newthis - value of `this` the genfun was called with.\n * @param {Array} callArgs - Arguments the genfun was called with.\n */\nmodule.exports.noApplicableMethod = module.exports();\nmodule.exports.noApplicableMethod.add([], (gf, thisArg, args) => {\n  let msg = 'No applicable method found when called with arguments of types: (' + [].map.call(args, arg => {\n    return /\\[object ([a-zA-Z0-9]+)\\]/.exec({}.toString.call(arg))[1];\n  }).join(', ') + ')';\n  let err = new Error(msg);\n  err.genfun = gf;\n  err.thisArg = thisArg;\n  err.args = args;\n  throw err;\n});\n\n/*\n * Internal\n */\nGenfun.prototype.applyGenfun = function applyGenfun(newThis, args) {\n  let applicableMethods = this.getApplicableMethods(args);\n  if (applicableMethods.length === 1 || this[kNoNext]) {\n    return applicableMethods[0].func.apply(newThis, args);\n  } else if (applicableMethods.length > 1) {\n    let idx = 0;\n    const nextMethod = function nextMethod() {\n      if (arguments.length) {\n        // Replace args if passed in explicitly\n        args = arguments;\n        Array.prototype.push.call(args, nextMethod);\n      }\n      const next = applicableMethods[idx++];\n      if (idx >= applicableMethods.length) {\n        Array.prototype.pop.call(args);\n      }\n      return next.func.apply(newThis, args);\n    };\n    Array.prototype.push.call(args, nextMethod);\n    return nextMethod();\n  } else {\n    return module.exports.noApplicableMethod(this, newThis, args);\n  }\n};\nGenfun.prototype.getApplicableMethods = function getApplicableMethods(args) {\n  if (!args.length || !this[kMethods].length) {\n    return this[kDefaultMethod] ? [this[kDefaultMethod]] : [];\n  }\n  let applicableMethods;\n  let maybeMethods = cachedMethods(this, args);\n  if (maybeMethods) {\n    applicableMethods = maybeMethods;\n  } else {\n    applicableMethods = computeApplicableMethods(this, args);\n    cacheArgs(this, args, applicableMethods);\n  }\n  return applicableMethods;\n};\nfunction cacheArgs(genfun, args, methods) {\n  if (genfun[kCache].state === STATES.MEGAMORPHIC) {\n    return;\n  }\n  var key = [];\n  var proto;\n  for (var i = 0; i < args.length; i++) {\n    proto = cacheableProto(genfun, args[i]);\n    if (proto) {\n      key[i] = proto;\n    } else {\n      return null;\n    }\n  }\n  genfun[kCache].key.unshift(key);\n  genfun[kCache].methods.unshift(methods);\n  if (genfun[kCache].key.length === 1) {\n    genfun[kCache].state = STATES.MONOMORPHIC;\n  } else if (genfun[kCache].key.length < MAX_CACHE_SIZE) {\n    genfun[kCache].state = STATES.POLYMORPHIC;\n  } else {\n    genfun[kCache].state = STATES.MEGAMORPHIC;\n  }\n}\nfunction cacheableProto(genfun, arg) {\n  var dispatchable = util.dispatchableObject(arg);\n  if (Object.hasOwnProperty.call(dispatchable, Role.roleKeyName)) {\n    for (var j = 0; j < dispatchable[Role.roleKeyName].length; j++) {\n      var role = dispatchable[Role.roleKeyName][j];\n      if (role.method.genfun === genfun) {\n        return null;\n      }\n    }\n  }\n  return Object.getPrototypeOf(dispatchable);\n}\nfunction cachedMethods(genfun, args) {\n  if (genfun[kCache].state === STATES.UNINITIALIZED || genfun[kCache].state === STATES.MEGAMORPHIC) {\n    return null;\n  }\n  var protos = [];\n  var proto;\n  for (var i = 0; i < args.length; i++) {\n    proto = cacheableProto(genfun, args[i]);\n    if (proto) {\n      protos[i] = proto;\n    } else {\n      return;\n    }\n  }\n  for (i = 0; i < genfun[kCache].key.length; i++) {\n    if (matchCachedMethods(genfun[kCache].key[i], protos)) {\n      return genfun[kCache].methods[i];\n    }\n  }\n}\nfunction matchCachedMethods(key, protos) {\n  if (key.length !== protos.length) {\n    return false;\n  }\n  for (var i = 0; i < key.length; i++) {\n    if (key[i] !== protos[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction computeApplicableMethods(genfun, args) {\n  args = [].slice.call(args);\n  let discoveredMethods = [];\n  function findAndRankRoles(object, hierarchyPosition, index) {\n    var roles = Object.hasOwnProperty.call(object, Role.roleKeyName) ? object[Role.roleKeyName] : [];\n    roles.forEach(role => {\n      if (role.method.genfun === genfun && index === role.position) {\n        if (discoveredMethods.indexOf(role.method) < 0) {\n          Method.clearRank(role.method);\n          discoveredMethods.push(role.method);\n        }\n        Method.setRankHierarchyPosition(role.method, index, hierarchyPosition);\n      }\n    });\n    // When a discovered method would receive more arguments than\n    // were specialized, we pretend all extra arguments have a role\n    // on Object.prototype.\n    if (util.isObjectProto(object)) {\n      discoveredMethods.forEach(method => {\n        if (method.minimalSelector <= index) {\n          Method.setRankHierarchyPosition(method, index, hierarchyPosition);\n        }\n      });\n    }\n  }\n  args.forEach((arg, index) => {\n    getPrecedenceList(util.dispatchableObject(arg)).forEach((obj, hierarchyPosition) => {\n      findAndRankRoles(obj, hierarchyPosition, index);\n    });\n  });\n  let applicableMethods = discoveredMethods.filter(method => {\n    return args.length === method._rank.length && Method.isFullySpecified(method);\n  });\n  applicableMethods.sort((a, b) => Method.score(a) - Method.score(b));\n  if (genfun[kDefaultMethod]) {\n    applicableMethods.push(genfun[kDefaultMethod]);\n  }\n  return applicableMethods;\n}\n\n/*\n * Helper function for getting an array representing the entire\n * inheritance/precedence chain for an object by navigating its\n * prototype pointers.\n */\nfunction getPrecedenceList(obj) {\n  var precedenceList = [];\n  var nextObj = obj;\n  while (nextObj) {\n    precedenceList.push(nextObj);\n    nextObj = Object.getPrototypeOf(nextObj);\n  }\n  return precedenceList;\n}","map":{"version":3,"names":["Method","require","Role","util","kCache","Symbol","kDefaultMethod","kMethods","kNoNext","module","exports","genfun","opts","gf","length","func","apply","arguments","applyGenfun","Object","setPrototypeOf","Genfun","prototype","key","methods","state","STATES","UNINITIALIZED","add","default","name","defineProperty","value","noNextMethod","Function","isGenfun","MONOMORPHIC","POLYMORPHIC","MEGAMORPHIC","MAX_CACHE_SIZE","addMethod","selector","slice","call","i","hasOwnProperty","method","push","rm","removeMethod","Error","hasMethod","getApplicableMethods","noApplicableMethod","thisArg","args","msg","map","arg","exec","toString","join","err","newThis","applicableMethods","idx","nextMethod","Array","next","pop","maybeMethods","cachedMethods","computeApplicableMethods","cacheArgs","proto","cacheableProto","unshift","dispatchable","dispatchableObject","roleKeyName","j","role","getPrototypeOf","protos","matchCachedMethods","discoveredMethods","findAndRankRoles","object","hierarchyPosition","index","roles","forEach","position","indexOf","clearRank","setRankHierarchyPosition","isObjectProto","minimalSelector","getPrecedenceList","obj","filter","_rank","isFullySpecified","sort","a","b","score","precedenceList","nextObj"],"sources":["/Users/hkateliev/node_modules/npm/node_modules/genfun/lib/genfun.js"],"sourcesContent":["'use strict'\n\nconst Method = require('./method')\nconst Role = require('./role')\nconst util = require('./util')\n\nconst kCache = Symbol('cache')\nconst kDefaultMethod = Symbol('defaultMethod')\nconst kMethods = Symbol('methods')\nconst kNoNext = Symbol('noNext')\n\nmodule.exports = function genfun (opts) {\n  function gf () {\n    if (!gf[kMethods].length && gf[kDefaultMethod]) {\n      return gf[kDefaultMethod].func.apply(this, arguments)\n    } else {\n      return gf.applyGenfun(this, arguments)\n    }\n  }\n  Object.setPrototypeOf(gf, Genfun.prototype)\n  gf[kMethods] = []\n  gf[kCache] = {key: [], methods: [], state: STATES.UNINITIALIZED}\n  if (opts && typeof opts === 'function') {\n    gf.add(opts)\n  } else if (opts && opts.default) {\n    gf.add(opts.default)\n  }\n  if (opts && opts.name) {\n    Object.defineProperty(gf, 'name', {\n      value: opts.name\n    })\n  }\n  if (opts && opts.noNextMethod) {\n    gf[kNoNext] = true\n  }\n  return gf\n}\n\nclass Genfun extends Function {}\nGenfun.prototype.isGenfun = true\n\nconst STATES = {\n  UNINITIALIZED: 0,\n  MONOMORPHIC: 1,\n  POLYMORPHIC: 2,\n  MEGAMORPHIC: 3\n}\n\nconst MAX_CACHE_SIZE = 32\n\n/**\n * Defines a method on a generic function.\n *\n * @function\n * @param {Array-like} selector - Selector array for dispatching the method.\n * @param {Function} methodFunction - Function to execute when the method\n *                                    successfully dispatches.\n */\nGenfun.prototype.add = function addMethod (selector, func) {\n  if (!func && typeof selector === 'function') {\n    func = selector\n    selector = []\n  }\n  selector = [].slice.call(selector)\n  for (var i = 0; i < selector.length; i++) {\n    if (!selector.hasOwnProperty(i)) {\n      selector[i] = Object.prototype\n    }\n  }\n  this[kCache] = {key: [], methods: [], state: STATES.UNINITIALIZED}\n  let method = new Method(this, selector, func)\n  if (selector.length) {\n    this[kMethods].push(method)\n  } else {\n    this[kDefaultMethod] = method\n  }\n  return this\n}\n\n/**\n * Removes a previously-defined method on `genfun` that matches\n * `selector` exactly.\n *\n * @function\n * @param {Genfun} genfun - Genfun to remove a method from.\n * @param {Array-like} selector - Objects to match on when finding a\n *                                    method to remove.\n */\nGenfun.prototype.rm = function removeMethod () {\n  throw new Error('not yet implemented')\n}\n\n/**\n * Returns true if there are methods that apply to the given arguments on\n * `genfun`. Additionally, makes sure the cache is warmed up for the given\n * arguments.\n *\n */\nGenfun.prototype.hasMethod = function hasMethod () {\n  const methods = this.getApplicableMethods(arguments)\n  return !!(methods && methods.length)\n}\n\n/**\n * This generic function is called when `genfun` has been called and no\n * applicable method was found. The default method throws an `Error`.\n *\n * @function\n * @param {Genfun} genfun - Generic function instance that was called.\n * @param {*} newthis - value of `this` the genfun was called with.\n * @param {Array} callArgs - Arguments the genfun was called with.\n */\nmodule.exports.noApplicableMethod = module.exports()\nmodule.exports.noApplicableMethod.add([], (gf, thisArg, args) => {\n  let msg =\n        'No applicable method found when called with arguments of types: (' +\n        [].map.call(args, (arg) => {\n          return (/\\[object ([a-zA-Z0-9]+)\\]/)\n            .exec(({}).toString.call(arg))[1]\n        }).join(', ') + ')'\n  let err = new Error(msg)\n  err.genfun = gf\n  err.thisArg = thisArg\n  err.args = args\n  throw err\n})\n\n/*\n * Internal\n */\nGenfun.prototype.applyGenfun = function applyGenfun (newThis, args) {\n  let applicableMethods = this.getApplicableMethods(args)\n  if (applicableMethods.length === 1 || this[kNoNext]) {\n    return applicableMethods[0].func.apply(newThis, args)\n  } else if (applicableMethods.length > 1) {\n    let idx = 0\n    const nextMethod = function nextMethod () {\n      if (arguments.length) {\n        // Replace args if passed in explicitly\n        args = arguments\n        Array.prototype.push.call(args, nextMethod)\n      }\n      const next = applicableMethods[idx++]\n      if (idx >= applicableMethods.length) {\n        Array.prototype.pop.call(args)\n      }\n      return next.func.apply(newThis, args)\n    }\n    Array.prototype.push.call(args, nextMethod)\n    return nextMethod()\n  } else {\n    return module.exports.noApplicableMethod(this, newThis, args)\n  }\n}\n\nGenfun.prototype.getApplicableMethods = function getApplicableMethods (args) {\n  if (!args.length || !this[kMethods].length) {\n    return this[kDefaultMethod] ? [this[kDefaultMethod]] : []\n  }\n  let applicableMethods\n  let maybeMethods = cachedMethods(this, args)\n  if (maybeMethods) {\n    applicableMethods = maybeMethods\n  } else {\n    applicableMethods = computeApplicableMethods(this, args)\n    cacheArgs(this, args, applicableMethods)\n  }\n  return applicableMethods\n}\n\nfunction cacheArgs (genfun, args, methods) {\n  if (genfun[kCache].state === STATES.MEGAMORPHIC) { return }\n  var key = []\n  var proto\n  for (var i = 0; i < args.length; i++) {\n    proto = cacheableProto(genfun, args[i])\n    if (proto) {\n      key[i] = proto\n    } else {\n      return null\n    }\n  }\n  genfun[kCache].key.unshift(key)\n  genfun[kCache].methods.unshift(methods)\n  if (genfun[kCache].key.length === 1) {\n    genfun[kCache].state = STATES.MONOMORPHIC\n  } else if (genfun[kCache].key.length < MAX_CACHE_SIZE) {\n    genfun[kCache].state = STATES.POLYMORPHIC\n  } else {\n    genfun[kCache].state = STATES.MEGAMORPHIC\n  }\n}\n\nfunction cacheableProto (genfun, arg) {\n  var dispatchable = util.dispatchableObject(arg)\n  if (Object.hasOwnProperty.call(dispatchable, Role.roleKeyName)) {\n    for (var j = 0; j < dispatchable[Role.roleKeyName].length; j++) {\n      var role = dispatchable[Role.roleKeyName][j]\n      if (role.method.genfun === genfun) {\n        return null\n      }\n    }\n  }\n  return Object.getPrototypeOf(dispatchable)\n}\n\nfunction cachedMethods (genfun, args) {\n  if (genfun[kCache].state === STATES.UNINITIALIZED ||\n      genfun[kCache].state === STATES.MEGAMORPHIC) {\n    return null\n  }\n  var protos = []\n  var proto\n  for (var i = 0; i < args.length; i++) {\n    proto = cacheableProto(genfun, args[i])\n    if (proto) {\n      protos[i] = proto\n    } else {\n      return\n    }\n  }\n  for (i = 0; i < genfun[kCache].key.length; i++) {\n    if (matchCachedMethods(genfun[kCache].key[i], protos)) {\n      return genfun[kCache].methods[i]\n    }\n  }\n}\n\nfunction matchCachedMethods (key, protos) {\n  if (key.length !== protos.length) { return false }\n  for (var i = 0; i < key.length; i++) {\n    if (key[i] !== protos[i]) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction computeApplicableMethods (genfun, args) {\n  args = [].slice.call(args)\n  let discoveredMethods = []\n  function findAndRankRoles (object, hierarchyPosition, index) {\n    var roles = Object.hasOwnProperty.call(object, Role.roleKeyName)\n    ? object[Role.roleKeyName]\n    : []\n    roles.forEach(role => {\n      if (role.method.genfun === genfun && index === role.position) {\n        if (discoveredMethods.indexOf(role.method) < 0) {\n          Method.clearRank(role.method)\n          discoveredMethods.push(role.method)\n        }\n        Method.setRankHierarchyPosition(role.method, index, hierarchyPosition)\n      }\n    })\n    // When a discovered method would receive more arguments than\n    // were specialized, we pretend all extra arguments have a role\n    // on Object.prototype.\n    if (util.isObjectProto(object)) {\n      discoveredMethods.forEach(method => {\n        if (method.minimalSelector <= index) {\n          Method.setRankHierarchyPosition(method, index, hierarchyPosition)\n        }\n      })\n    }\n  }\n  args.forEach((arg, index) => {\n    getPrecedenceList(util.dispatchableObject(arg))\n      .forEach((obj, hierarchyPosition) => {\n        findAndRankRoles(obj, hierarchyPosition, index)\n      })\n  })\n  let applicableMethods = discoveredMethods.filter(method => {\n    return (args.length === method._rank.length &&\n            Method.isFullySpecified(method))\n  })\n  applicableMethods.sort((a, b) => Method.score(a) - Method.score(b))\n  if (genfun[kDefaultMethod]) {\n    applicableMethods.push(genfun[kDefaultMethod])\n  }\n  return applicableMethods\n}\n\n/*\n * Helper function for getting an array representing the entire\n * inheritance/precedence chain for an object by navigating its\n * prototype pointers.\n */\nfunction getPrecedenceList (obj) {\n  var precedenceList = []\n  var nextObj = obj\n  while (nextObj) {\n    precedenceList.push(nextObj)\n    nextObj = Object.getPrototypeOf(nextObj)\n  }\n  return precedenceList\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}