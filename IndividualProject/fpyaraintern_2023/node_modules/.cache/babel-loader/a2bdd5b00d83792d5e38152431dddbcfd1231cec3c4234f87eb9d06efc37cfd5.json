{"ast":null,"code":"'use strict';\n\nvar npm = require('../npm.js');\nvar validate = require('aproba');\nvar npa = require('npm-package-arg');\nvar flattenTree = require('./flatten-tree.js');\nvar isOnlyDev = require('./is-only-dev.js');\nvar log = require('npmlog');\nvar path = require('path');\nvar ssri = require('ssri');\nvar moduleName = require('../utils/module-name.js');\nvar isOnlyOptional = require('./is-only-optional.js');\n\n// we don't use get-requested because we're operating on files on disk, and\n// we don't want to extrapolate from what _should_ be there.\nfunction pkgRequested(pkg) {\n  return pkg._requested || pkg._resolved && npa(pkg._resolved) || pkg._from && npa(pkg._from);\n}\nfunction nonRegistrySource(requested) {\n  if (fromGit(requested)) return true;\n  if (fromLocal(requested)) return true;\n  if (fromRemote(requested)) return true;\n  return false;\n}\nfunction fromRemote(requested) {\n  if (requested.type === 'remote') return true;\n}\nfunction fromLocal(requested) {\n  // local is an npm@3 type that meant \"file\"\n  if (requested.type === 'file' || requested.type === 'directory' || requested.type === 'local') return true;\n  return false;\n}\nfunction fromGit(requested) {\n  if (requested.type === 'hosted' || requested.type === 'git') return true;\n  return false;\n}\nfunction pkgIntegrity(pkg) {\n  try {\n    // dist is provided by the registry\n    var sri = pkg.dist && pkg.dist.integrity ||\n    // _integrity is provided by pacote\n    pkg._integrity ||\n    // _shasum is legacy\n    pkg._shasum && ssri.fromHex(pkg._shasum, 'sha1').toString();\n    if (!sri) return;\n    var integrity = ssri.parse(sri);\n    if (Object.keys(integrity).length === 0) return;\n    return integrity;\n  } catch (ex) {}\n}\nfunction sriMatch(aa, bb) {\n  if (!aa || !bb) return false;\n  for (let algo of Object.keys(aa)) {\n    if (!bb[algo]) continue;\n    for (let aaHash of aa[algo]) {\n      for (let bbHash of bb[algo]) {\n        return aaHash.digest === bbHash.digest;\n      }\n    }\n  }\n  return false;\n}\nfunction pkgAreEquiv(aa, bb) {\n  // coming in we know they share a path…\n\n  // if one is inside a link and the other is not, then they are not equivalent\n  // this happens when we're replacing a linked dep with a non-linked version\n  if (aa.isInLink !== bb.isInLink) return false;\n  // if they share package metadata _identity_, they're the same thing\n  if (aa.package === bb.package) return true;\n  // if they share integrity information, they're the same thing\n  var aaIntegrity = pkgIntegrity(aa.package);\n  var bbIntegrity = pkgIntegrity(bb.package);\n  if (aaIntegrity || bbIntegrity) return sriMatch(aaIntegrity, bbIntegrity);\n\n  // if they're links and they share the same target, they're the same thing\n  if (aa.isLink && bb.isLink) return aa.realpath === bb.realpath;\n\n  // if we can't determine both their sources then we have no way to know\n  // if they're the same thing, so we have to assume they aren't\n  var aaReq = pkgRequested(aa.package);\n  var bbReq = pkgRequested(bb.package);\n  if (!aaReq || !bbReq) return false;\n  if (fromGit(aaReq) && fromGit(bbReq)) {\n    // if both are git and share a _resolved specifier (one with the\n    // comittish replaced by a commit hash) then they're the same\n    return aa.package._resolved && bb.package._resolved && aa.package._resolved === bb.package._resolved;\n  }\n\n  // we have to give up trying to find matches for non-registry sources at this point…\n  if (nonRegistrySource(aaReq) || nonRegistrySource(bbReq)) return false;\n\n  // finally, if they ARE a registry source then version matching counts\n  return aa.package.version === bb.package.version;\n}\nfunction pushAll(aa, bb) {\n  Array.prototype.push.apply(aa, bb);\n}\nmodule.exports = function (oldTree, newTree, differences, log, next) {\n  validate('OOAOF', arguments);\n  pushAll(differences, sortActions(diffTrees(oldTree, newTree)));\n  log.finish();\n  next();\n};\nfunction isNotTopOrExtraneous(node) {\n  return !node.isTop && !node.userRequired && !node.existing;\n}\nvar sortActions = module.exports.sortActions = function (differences) {\n  var actions = {};\n  differences.forEach(function (action) {\n    var child = action[1];\n    actions[child.location] = action;\n  });\n  var sorted = [];\n  var added = {};\n  var sortedlocs = Object.keys(actions).sort(sortByLocation);\n\n  // We're going to sort the actions taken on top level dependencies first, before\n  // considering the order of transitive deps. Because we're building our list\n  // from the bottom up, this means we will return a list with top level deps LAST.\n  // This is important in terms of keeping installations as consistent as possible\n  // as folks add new dependencies.\n  var toplocs = sortedlocs.filter(function (location) {\n    var mod = actions[location][1];\n    if (!mod.requiredBy) return true;\n    // If this module is required by any non-top level module\n    // or by any extraneous module, eg user requested or existing\n    // then we don't want to give this priority sorting.\n    return !mod.requiredBy.some(isNotTopOrExtraneous);\n  });\n  toplocs.concat(sortedlocs).forEach(function (location) {\n    sortByDeps(actions[location]);\n  });\n  function sortByLocation(aa, bb) {\n    return bb.localeCompare(aa);\n  }\n  function sortModuleByLocation(aa, bb) {\n    return sortByLocation(aa && aa.location, bb && bb.location);\n  }\n  function sortByDeps(action) {\n    var mod = action[1];\n    if (added[mod.location]) return;\n    added[mod.location] = action;\n    if (!mod.requiredBy) mod.requiredBy = [];\n    mod.requiredBy.sort(sortModuleByLocation).forEach(function (mod) {\n      if (actions[mod.location]) sortByDeps(actions[mod.location]);\n    });\n    sorted.unshift(action);\n  }\n\n  // safety net, anything excluded above gets tacked on the end\n  differences.forEach(_ => {\n    if (sorted.indexOf(_) === -1) sorted.push(_);\n  });\n  return sorted;\n};\nfunction setAction(differences, action, pkg) {\n  differences.push([action, pkg]);\n}\nvar diffTrees = module.exports._diffTrees = function (oldTree, newTree) {\n  validate('OO', arguments);\n  var differences = [];\n  var flatOldTree = flattenTree(oldTree);\n  var flatNewTree = flattenTree(newTree);\n  var toRemove = {};\n  var toRemoveByName = {};\n\n  // Build our tentative remove list.  We don't add remove actions yet\n  // because we might resuse them as part of a move.\n  Object.keys(flatOldTree).forEach(function (flatname) {\n    if (flatname === '/') return;\n    if (flatNewTree[flatname]) return;\n    var pkg = flatOldTree[flatname];\n    if (pkg.isInLink && /^[.][.][/\\\\]/.test(path.relative(newTree.realpath, pkg.realpath))) return;\n    toRemove[flatname] = pkg;\n    var name = moduleName(pkg);\n    if (!toRemoveByName[name]) toRemoveByName[name] = [];\n    toRemoveByName[name].push({\n      flatname: flatname,\n      pkg: pkg\n    });\n  });\n\n  // generate our add/update/move actions\n  Object.keys(flatNewTree).forEach(function (flatname) {\n    if (flatname === '/') return;\n    var pkg = flatNewTree[flatname];\n    var oldPkg = pkg.oldPkg = flatOldTree[flatname];\n    if (oldPkg) {\n      // if the versions are equivalent then we don't need to update… unless\n      // the user explicitly asked us to.\n      if (!pkg.userRequired && pkgAreEquiv(oldPkg, pkg)) return;\n      setAction(differences, 'update', pkg);\n    } else {\n      var name = moduleName(pkg);\n      // find any packages we're removing that share the same name and are equivalent\n      var removing = (toRemoveByName[name] || []).filter(rm => pkgAreEquiv(rm.pkg, pkg));\n      var bundlesOrFromBundle = pkg.fromBundle || pkg.package.bundleDependencies;\n      // if we have any removes that match AND we're not working with a bundle then upgrade to a move\n      if (removing.length && !bundlesOrFromBundle) {\n        var toMv = removing.shift();\n        toRemoveByName[name] = toRemoveByName[name].filter(rm => rm !== toMv);\n        pkg.fromPath = toMv.pkg.path;\n        setAction(differences, 'move', pkg);\n        delete toRemove[toMv.flatname];\n        // we don't generate add actions for things found in links (which already exist on disk)\n      } else if (!pkg.isInLink || !(pkg.fromBundle && pkg.fromBundle.isLink)) {\n        setAction(differences, 'add', pkg);\n      }\n    }\n  });\n\n  // finally generate our remove actions from any not consumed by moves\n  Object.keys(toRemove).map(flatname => toRemove[flatname]).forEach(pkg => setAction(differences, 'remove', pkg));\n  return filterActions(differences);\n};\nfunction filterActions(differences) {\n  const includeOpt = npm.config.get('optional');\n  const includeDev = npm.config.get('dev') || !/^prod(uction)?$/.test(npm.config.get('only')) && !npm.config.get('production') || /^dev(elopment)?$/.test(npm.config.get('only')) || /^dev(elopment)?$/.test(npm.config.get('also'));\n  const includeProd = !/^dev(elopment)?$/.test(npm.config.get('only'));\n  if (includeProd && includeDev && includeOpt) return differences;\n  log.silly('diff-trees', 'filtering actions:', 'includeDev', includeDev, 'includeProd', includeProd, 'includeOpt', includeOpt);\n  return differences.filter(diff => {\n    const pkg = diff[1];\n    const pkgIsOnlyDev = isOnlyDev(pkg);\n    const pkgIsOnlyOpt = isOnlyOptional(pkg);\n    if (!includeProd && pkgIsOnlyDev) return true;\n    if (includeDev && pkgIsOnlyDev) return true;\n    if (includeProd && !pkgIsOnlyDev && (includeOpt || !pkgIsOnlyOpt)) return true;\n    return false;\n  });\n}","map":{"version":3,"names":["npm","require","validate","npa","flattenTree","isOnlyDev","log","path","ssri","moduleName","isOnlyOptional","pkgRequested","pkg","_requested","_resolved","_from","nonRegistrySource","requested","fromGit","fromLocal","fromRemote","type","pkgIntegrity","sri","dist","integrity","_integrity","_shasum","fromHex","toString","parse","Object","keys","length","ex","sriMatch","aa","bb","algo","aaHash","bbHash","digest","pkgAreEquiv","isInLink","package","aaIntegrity","bbIntegrity","isLink","realpath","aaReq","bbReq","version","pushAll","Array","prototype","push","apply","module","exports","oldTree","newTree","differences","next","arguments","sortActions","diffTrees","finish","isNotTopOrExtraneous","node","isTop","userRequired","existing","actions","forEach","action","child","location","sorted","added","sortedlocs","sort","sortByLocation","toplocs","filter","mod","requiredBy","some","concat","sortByDeps","localeCompare","sortModuleByLocation","unshift","_","indexOf","setAction","_diffTrees","flatOldTree","flatNewTree","toRemove","toRemoveByName","flatname","test","relative","name","oldPkg","removing","rm","bundlesOrFromBundle","fromBundle","bundleDependencies","toMv","shift","fromPath","map","filterActions","includeOpt","config","get","includeDev","includeProd","silly","diff","pkgIsOnlyDev","pkgIsOnlyOpt"],"sources":["/Users/hkateliev/node_modules/npm/lib/install/diff-trees.js"],"sourcesContent":["'use strict'\nvar npm = require('../npm.js')\nvar validate = require('aproba')\nvar npa = require('npm-package-arg')\nvar flattenTree = require('./flatten-tree.js')\nvar isOnlyDev = require('./is-only-dev.js')\nvar log = require('npmlog')\nvar path = require('path')\nvar ssri = require('ssri')\nvar moduleName = require('../utils/module-name.js')\nvar isOnlyOptional = require('./is-only-optional.js')\n\n// we don't use get-requested because we're operating on files on disk, and\n// we don't want to extrapolate from what _should_ be there.\nfunction pkgRequested (pkg) {\n  return pkg._requested || (pkg._resolved && npa(pkg._resolved)) || (pkg._from && npa(pkg._from))\n}\n\nfunction nonRegistrySource (requested) {\n  if (fromGit(requested)) return true\n  if (fromLocal(requested)) return true\n  if (fromRemote(requested)) return true\n  return false\n}\n\nfunction fromRemote (requested) {\n  if (requested.type === 'remote') return true\n}\n\nfunction fromLocal (requested) {\n  // local is an npm@3 type that meant \"file\"\n  if (requested.type === 'file' || requested.type === 'directory' || requested.type === 'local') return true\n  return false\n}\n\nfunction fromGit (requested) {\n  if (requested.type === 'hosted' || requested.type === 'git') return true\n  return false\n}\n\nfunction pkgIntegrity (pkg) {\n  try {\n    // dist is provided by the registry\n    var sri = (pkg.dist && pkg.dist.integrity) ||\n              // _integrity is provided by pacote\n              pkg._integrity ||\n              // _shasum is legacy\n              (pkg._shasum && ssri.fromHex(pkg._shasum, 'sha1').toString())\n    if (!sri) return\n    var integrity = ssri.parse(sri)\n    if (Object.keys(integrity).length === 0) return\n    return integrity\n  } catch (ex) {\n\n  }\n}\n\nfunction sriMatch (aa, bb) {\n  if (!aa || !bb) return false\n  for (let algo of Object.keys(aa)) {\n    if (!bb[algo]) continue\n    for (let aaHash of aa[algo]) {\n      for (let bbHash of bb[algo]) {\n        return aaHash.digest === bbHash.digest\n      }\n    }\n  }\n  return false\n}\n\nfunction pkgAreEquiv (aa, bb) {\n  // coming in we know they share a path…\n\n  // if one is inside a link and the other is not, then they are not equivalent\n  // this happens when we're replacing a linked dep with a non-linked version\n  if (aa.isInLink !== bb.isInLink) return false\n  // if they share package metadata _identity_, they're the same thing\n  if (aa.package === bb.package) return true\n  // if they share integrity information, they're the same thing\n  var aaIntegrity = pkgIntegrity(aa.package)\n  var bbIntegrity = pkgIntegrity(bb.package)\n  if (aaIntegrity || bbIntegrity) return sriMatch(aaIntegrity, bbIntegrity)\n\n  // if they're links and they share the same target, they're the same thing\n  if (aa.isLink && bb.isLink) return aa.realpath === bb.realpath\n\n  // if we can't determine both their sources then we have no way to know\n  // if they're the same thing, so we have to assume they aren't\n  var aaReq = pkgRequested(aa.package)\n  var bbReq = pkgRequested(bb.package)\n  if (!aaReq || !bbReq) return false\n\n  if (fromGit(aaReq) && fromGit(bbReq)) {\n    // if both are git and share a _resolved specifier (one with the\n    // comittish replaced by a commit hash) then they're the same\n    return aa.package._resolved && bb.package._resolved &&\n           aa.package._resolved === bb.package._resolved\n  }\n\n  // we have to give up trying to find matches for non-registry sources at this point…\n  if (nonRegistrySource(aaReq) || nonRegistrySource(bbReq)) return false\n\n  // finally, if they ARE a registry source then version matching counts\n  return aa.package.version === bb.package.version\n}\n\nfunction pushAll (aa, bb) {\n  Array.prototype.push.apply(aa, bb)\n}\n\nmodule.exports = function (oldTree, newTree, differences, log, next) {\n  validate('OOAOF', arguments)\n  pushAll(differences, sortActions(diffTrees(oldTree, newTree)))\n  log.finish()\n  next()\n}\n\nfunction isNotTopOrExtraneous (node) {\n  return !node.isTop && !node.userRequired && !node.existing\n}\n\nvar sortActions = module.exports.sortActions = function (differences) {\n  var actions = {}\n  differences.forEach(function (action) {\n    var child = action[1]\n    actions[child.location] = action\n  })\n\n  var sorted = []\n  var added = {}\n\n  var sortedlocs = Object.keys(actions).sort(sortByLocation)\n\n  // We're going to sort the actions taken on top level dependencies first, before\n  // considering the order of transitive deps. Because we're building our list\n  // from the bottom up, this means we will return a list with top level deps LAST.\n  // This is important in terms of keeping installations as consistent as possible\n  // as folks add new dependencies.\n  var toplocs = sortedlocs.filter(function (location) {\n    var mod = actions[location][1]\n    if (!mod.requiredBy) return true\n    // If this module is required by any non-top level module\n    // or by any extraneous module, eg user requested or existing\n    // then we don't want to give this priority sorting.\n    return !mod.requiredBy.some(isNotTopOrExtraneous)\n  })\n\n  toplocs.concat(sortedlocs).forEach(function (location) {\n    sortByDeps(actions[location])\n  })\n\n  function sortByLocation (aa, bb) {\n    return bb.localeCompare(aa)\n  }\n  function sortModuleByLocation (aa, bb) {\n    return sortByLocation(aa && aa.location, bb && bb.location)\n  }\n  function sortByDeps (action) {\n    var mod = action[1]\n    if (added[mod.location]) return\n    added[mod.location] = action\n    if (!mod.requiredBy) mod.requiredBy = []\n    mod.requiredBy.sort(sortModuleByLocation).forEach(function (mod) {\n      if (actions[mod.location]) sortByDeps(actions[mod.location])\n    })\n    sorted.unshift(action)\n  }\n\n  // safety net, anything excluded above gets tacked on the end\n  differences.forEach((_) => {\n    if (sorted.indexOf(_) === -1) sorted.push(_)\n  })\n\n  return sorted\n}\n\nfunction setAction (differences, action, pkg) {\n  differences.push([action, pkg])\n}\n\nvar diffTrees = module.exports._diffTrees = function (oldTree, newTree) {\n  validate('OO', arguments)\n  var differences = []\n  var flatOldTree = flattenTree(oldTree)\n  var flatNewTree = flattenTree(newTree)\n  var toRemove = {}\n  var toRemoveByName = {}\n\n  // Build our tentative remove list.  We don't add remove actions yet\n  // because we might resuse them as part of a move.\n  Object.keys(flatOldTree).forEach(function (flatname) {\n    if (flatname === '/') return\n    if (flatNewTree[flatname]) return\n    var pkg = flatOldTree[flatname]\n    if (pkg.isInLink && /^[.][.][/\\\\]/.test(path.relative(newTree.realpath, pkg.realpath))) return\n\n    toRemove[flatname] = pkg\n    var name = moduleName(pkg)\n    if (!toRemoveByName[name]) toRemoveByName[name] = []\n    toRemoveByName[name].push({flatname: flatname, pkg: pkg})\n  })\n\n  // generate our add/update/move actions\n  Object.keys(flatNewTree).forEach(function (flatname) {\n    if (flatname === '/') return\n    var pkg = flatNewTree[flatname]\n    var oldPkg = pkg.oldPkg = flatOldTree[flatname]\n    if (oldPkg) {\n      // if the versions are equivalent then we don't need to update… unless\n      // the user explicitly asked us to.\n      if (!pkg.userRequired && pkgAreEquiv(oldPkg, pkg)) return\n      setAction(differences, 'update', pkg)\n    } else {\n      var name = moduleName(pkg)\n      // find any packages we're removing that share the same name and are equivalent\n      var removing = (toRemoveByName[name] || []).filter((rm) => pkgAreEquiv(rm.pkg, pkg))\n      var bundlesOrFromBundle = pkg.fromBundle || pkg.package.bundleDependencies\n      // if we have any removes that match AND we're not working with a bundle then upgrade to a move\n      if (removing.length && !bundlesOrFromBundle) {\n        var toMv = removing.shift()\n        toRemoveByName[name] = toRemoveByName[name].filter((rm) => rm !== toMv)\n        pkg.fromPath = toMv.pkg.path\n        setAction(differences, 'move', pkg)\n        delete toRemove[toMv.flatname]\n      // we don't generate add actions for things found in links (which already exist on disk)\n      } else if (!pkg.isInLink || !(pkg.fromBundle && pkg.fromBundle.isLink)) {\n        setAction(differences, 'add', pkg)\n      }\n    }\n  })\n\n  // finally generate our remove actions from any not consumed by moves\n  Object\n    .keys(toRemove)\n    .map((flatname) => toRemove[flatname])\n    .forEach((pkg) => setAction(differences, 'remove', pkg))\n\n  return filterActions(differences)\n}\n\nfunction filterActions (differences) {\n  const includeOpt = npm.config.get('optional')\n  const includeDev = npm.config.get('dev') ||\n    (!/^prod(uction)?$/.test(npm.config.get('only')) && !npm.config.get('production')) ||\n    /^dev(elopment)?$/.test(npm.config.get('only')) ||\n    /^dev(elopment)?$/.test(npm.config.get('also'))\n  const includeProd = !/^dev(elopment)?$/.test(npm.config.get('only'))\n  if (includeProd && includeDev && includeOpt) return differences\n\n  log.silly('diff-trees', 'filtering actions:', 'includeDev', includeDev, 'includeProd', includeProd, 'includeOpt', includeOpt)\n  return differences.filter((diff) => {\n    const pkg = diff[1]\n    const pkgIsOnlyDev = isOnlyDev(pkg)\n    const pkgIsOnlyOpt = isOnlyOptional(pkg)\n    if (!includeProd && pkgIsOnlyDev) return true\n    if (includeDev && pkgIsOnlyDev) return true\n    if (includeProd && !pkgIsOnlyDev && (includeOpt || !pkgIsOnlyOpt)) return true\n    return false\n  })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}