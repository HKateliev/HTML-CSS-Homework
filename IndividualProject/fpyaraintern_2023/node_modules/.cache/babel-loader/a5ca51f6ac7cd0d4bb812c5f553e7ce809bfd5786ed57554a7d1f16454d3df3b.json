{"ast":null,"code":"'use strict';\n\nlet Cache;\nconst url = require('url');\nconst CachePolicy = require('http-cache-semantics');\nconst fetch = require('node-fetch-npm');\nconst pkg = require('./package.json');\nconst retry = require('promise-retry');\nlet ssri;\nconst Stream = require('stream');\nconst getAgent = require('./agent');\nconst setWarning = require('./warning');\nconst isURL = /^https?:/;\nconst USER_AGENT = `${pkg.name}/${pkg.version} (+https://npm.im/${pkg.name})`;\nconst RETRY_ERRORS = ['ECONNRESET',\n// remote socket closed on us\n'ECONNREFUSED',\n// remote host refused to open connection\n'EADDRINUSE',\n// failed to bind to a local port (proxy?)\n'ETIMEDOUT' // someone in the transaction is WAY TOO SLOW\n// Known codes we do NOT retry on:\n// ENOTFOUND (getaddrinfo failure. Either bad hostname, or offline)\n];\n\nconst RETRY_TYPES = ['request-timeout'];\n\n// https://fetch.spec.whatwg.org/#http-network-or-cache-fetch\nmodule.exports = cachingFetch;\ncachingFetch.defaults = function (_uri, _opts) {\n  const fetch = this;\n  if (typeof _uri === 'object') {\n    _opts = _uri;\n    _uri = null;\n  }\n  function defaultedFetch(uri, opts) {\n    const finalOpts = Object.assign({}, _opts || {}, opts || {});\n    return fetch(uri || _uri, finalOpts);\n  }\n  defaultedFetch.defaults = fetch.defaults;\n  defaultedFetch.delete = fetch.delete;\n  return defaultedFetch;\n};\ncachingFetch.delete = cacheDelete;\nfunction cacheDelete(uri, opts) {\n  opts = configureOptions(opts);\n  if (opts.cacheManager) {\n    const req = new fetch.Request(uri, {\n      method: opts.method,\n      headers: opts.headers\n    });\n    return opts.cacheManager.delete(req, opts);\n  }\n}\nfunction initializeCache(opts) {\n  if (typeof opts.cacheManager === 'string') {\n    if (!Cache) {\n      // Default cacache-based cache\n      Cache = require('./cache');\n    }\n    opts.cacheManager = new Cache(opts.cacheManager, opts);\n  }\n  opts.cache = opts.cache || 'default';\n  if (opts.cache === 'default' && isHeaderConditional(opts.headers)) {\n    // If header list contains `If-Modified-Since`, `If-None-Match`,\n    // `If-Unmodified-Since`, `If-Match`, or `If-Range`, fetch will set cache\n    // mode to \"no-store\" if it is \"default\".\n    opts.cache = 'no-store';\n  }\n}\nfunction configureOptions(_opts) {\n  const opts = Object.assign({}, _opts || {});\n  opts.method = (opts.method || 'GET').toUpperCase();\n  if (opts.retry && typeof opts.retry === 'number') {\n    opts.retry = {\n      retries: opts.retry\n    };\n  }\n  if (opts.retry === false) {\n    opts.retry = {\n      retries: 0\n    };\n  }\n  if (opts.cacheManager) {\n    initializeCache(opts);\n  }\n  return opts;\n}\nfunction initializeSsri() {\n  if (!ssri) {\n    ssri = require('ssri');\n  }\n}\nfunction cachingFetch(uri, _opts) {\n  const opts = configureOptions(_opts);\n  if (opts.integrity) {\n    initializeSsri();\n    // if verifying integrity, node-fetch must not decompress\n    opts.compress = false;\n  }\n  const isCachable = (opts.method === 'GET' || opts.method === 'HEAD') && opts.cacheManager && opts.cache !== 'no-store' && opts.cache !== 'reload';\n  if (isCachable) {\n    const req = new fetch.Request(uri, {\n      method: opts.method,\n      headers: opts.headers\n    });\n    return opts.cacheManager.match(req, opts).then(res => {\n      if (res) {\n        const warningCode = (res.headers.get('Warning') || '').match(/^\\d+/);\n        if (warningCode && +warningCode >= 100 && +warningCode < 200) {\n          // https://tools.ietf.org/html/rfc7234#section-4.3.4\n          //\n          // If a stored response is selected for update, the cache MUST:\n          //\n          // * delete any Warning header fields in the stored response with\n          //   warn-code 1xx (see Section 5.5);\n          //\n          // * retain any Warning header fields in the stored response with\n          //   warn-code 2xx;\n          //\n          res.headers.delete('Warning');\n        }\n        if (opts.cache === 'default' && !isStale(req, res)) {\n          return res;\n        }\n        if (opts.cache === 'default' || opts.cache === 'no-cache') {\n          return conditionalFetch(req, res, opts);\n        }\n        if (opts.cache === 'force-cache' || opts.cache === 'only-if-cached') {\n          //   112 Disconnected operation\n          // SHOULD be included if the cache is intentionally disconnected from\n          // the rest of the network for a period of time.\n          // (https://tools.ietf.org/html/rfc2616#section-14.46)\n          setWarning(res, 112, 'Disconnected operation');\n          return res;\n        }\n      }\n      if (!res && opts.cache === 'only-if-cached') {\n        const errorMsg = `request to ${uri} failed: cache mode is 'only-if-cached' but no cached response available.`;\n        const err = new Error(errorMsg);\n        err.code = 'ENOTCACHED';\n        throw err;\n      }\n\n      // Missing cache entry, or mode is default (if stale), reload, no-store\n      return remoteFetch(req.url, opts);\n    });\n  }\n  return remoteFetch(uri, opts);\n}\nfunction iterableToObject(iter) {\n  const obj = {};\n  for (let k of iter.keys()) {\n    obj[k] = iter.get(k);\n  }\n  return obj;\n}\nfunction makePolicy(req, res) {\n  const _req = {\n    url: req.url,\n    method: req.method,\n    headers: iterableToObject(req.headers)\n  };\n  const _res = {\n    status: res.status,\n    headers: iterableToObject(res.headers)\n  };\n  return new CachePolicy(_req, _res, {\n    shared: false\n  });\n}\n\n// https://tools.ietf.org/html/rfc7234#section-4.2\nfunction isStale(req, res) {\n  if (!res) {\n    return null;\n  }\n  const _req = {\n    url: req.url,\n    method: req.method,\n    headers: iterableToObject(req.headers)\n  };\n  const policy = makePolicy(req, res);\n  const responseTime = res.headers.get('x-local-cache-time') || res.headers.get('date') || 0;\n  policy._responseTime = new Date(responseTime);\n  const bool = !policy.satisfiesWithoutRevalidation(_req);\n  return bool;\n}\nfunction mustRevalidate(res) {\n  return (res.headers.get('cache-control') || '').match(/must-revalidate/i);\n}\nfunction conditionalFetch(req, cachedRes, opts) {\n  const _req = {\n    url: req.url,\n    method: req.method,\n    headers: Object.assign({}, opts.headers || {})\n  };\n  const policy = makePolicy(req, cachedRes);\n  opts.headers = policy.revalidationHeaders(_req);\n  return remoteFetch(req.url, opts).then(condRes => {\n    const revalidatedPolicy = policy.revalidatedPolicy(_req, {\n      status: condRes.status,\n      headers: iterableToObject(condRes.headers)\n    });\n    if (condRes.status >= 500 && !mustRevalidate(cachedRes)) {\n      //   111 Revalidation failed\n      // MUST be included if a cache returns a stale response because an\n      // attempt to revalidate the response failed, due to an inability to\n      // reach the server.\n      // (https://tools.ietf.org/html/rfc2616#section-14.46)\n      setWarning(cachedRes, 111, 'Revalidation failed');\n      return cachedRes;\n    }\n    if (condRes.status === 304) {\n      // 304 Not Modified\n      condRes.body = cachedRes.body;\n      return opts.cacheManager.put(req, condRes, opts).then(newRes => {\n        newRes.headers = new fetch.Headers(revalidatedPolicy.policy.responseHeaders());\n        return newRes;\n      });\n    }\n    return condRes;\n  }).then(res => res).catch(err => {\n    if (mustRevalidate(cachedRes)) {\n      throw err;\n    } else {\n      //   111 Revalidation failed\n      // MUST be included if a cache returns a stale response because an\n      // attempt to revalidate the response failed, due to an inability to\n      // reach the server.\n      // (https://tools.ietf.org/html/rfc2616#section-14.46)\n      setWarning(cachedRes, 111, 'Revalidation failed');\n      //   199 Miscellaneous warning\n      // The warning text MAY include arbitrary information to be presented to\n      // a human user, or logged. A system receiving this warning MUST NOT take\n      // any automated action, besides presenting the warning to the user.\n      // (https://tools.ietf.org/html/rfc2616#section-14.46)\n      setWarning(cachedRes, 199, `Miscellaneous Warning ${err.code}: ${err.message}`);\n      return cachedRes;\n    }\n  });\n}\nfunction remoteFetchHandleIntegrity(res, integrity) {\n  const oldBod = res.body;\n  const newBod = ssri.integrityStream({\n    integrity\n  });\n  oldBod.pipe(newBod);\n  res.body = newBod;\n  oldBod.once('error', err => {\n    newBod.emit('error', err);\n  });\n  newBod.once('error', err => {\n    oldBod.emit('error', err);\n  });\n}\nfunction remoteFetch(uri, opts) {\n  const agent = getAgent(uri, opts);\n  const headers = Object.assign({\n    'connection': agent ? 'keep-alive' : 'close',\n    'user-agent': USER_AGENT\n  }, opts.headers || {});\n  const reqOpts = {\n    agent,\n    body: opts.body,\n    compress: opts.compress,\n    follow: opts.follow,\n    headers: new fetch.Headers(headers),\n    method: opts.method,\n    redirect: 'manual',\n    size: opts.size,\n    counter: opts.counter,\n    timeout: opts.timeout\n  };\n  return retry((retryHandler, attemptNum) => {\n    const req = new fetch.Request(uri, reqOpts);\n    return fetch(req).then(res => {\n      res.headers.set('x-fetch-attempts', attemptNum);\n      if (opts.integrity) {\n        remoteFetchHandleIntegrity(res, opts.integrity);\n      }\n      const isStream = req.body instanceof Stream;\n      if (opts.cacheManager) {\n        const isMethodGetHead = req.method === 'GET' || req.method === 'HEAD';\n        const isCachable = opts.cache !== 'no-store' && isMethodGetHead && makePolicy(req, res).storable() && res.status === 200; // No other statuses should be stored!\n\n        if (isCachable) {\n          return opts.cacheManager.put(req, res, opts);\n        }\n        if (!isMethodGetHead) {\n          return opts.cacheManager.delete(req).then(() => {\n            if (res.status >= 500 && req.method !== 'POST' && !isStream) {\n              if (typeof opts.onRetry === 'function') {\n                opts.onRetry(res);\n              }\n              return retryHandler(res);\n            }\n            return res;\n          });\n        }\n      }\n      const isRetriable = req.method !== 'POST' && !isStream && (res.status === 408 ||\n      // Request Timeout\n      res.status === 420 ||\n      // Enhance Your Calm (usually Twitter rate-limit)\n      res.status === 429 ||\n      // Too Many Requests (\"standard\" rate-limiting)\n      res.status >= 500 // Assume server errors are momentary hiccups\n      );\n\n      if (isRetriable) {\n        if (typeof opts.onRetry === 'function') {\n          opts.onRetry(res);\n        }\n        return retryHandler(res);\n      }\n      if (!fetch.isRedirect(res.status) || opts.redirect === 'manual') {\n        return res;\n      }\n\n      // handle redirects - matches behavior of npm-fetch: https://github.com/bitinn/node-fetch\n      if (opts.redirect === 'error') {\n        const err = new Error(`redirect mode is set to error: ${uri}`);\n        err.code = 'ENOREDIRECT';\n        throw err;\n      }\n      if (!res.headers.get('location')) {\n        const err = new Error(`redirect location header missing at: ${uri}`);\n        err.code = 'EINVALIDREDIRECT';\n        throw err;\n      }\n      if (req.counter >= req.follow) {\n        const err = new Error(`maximum redirect reached at: ${uri}`);\n        err.code = 'EMAXREDIRECT';\n        throw err;\n      }\n      const resolvedUrl = url.resolve(req.url, res.headers.get('location'));\n      let redirectURL = url.parse(resolvedUrl);\n      if (isURL.test(res.headers.get('location'))) {\n        redirectURL = url.parse(res.headers.get('location'));\n      }\n\n      // Remove authorization if changing hostnames (but not if just\n      // changing ports or protocols).  This matches the behavior of request:\n      // https://github.com/request/request/blob/b12a6245/lib/redirect.js#L134-L138\n      if (url.parse(req.url).hostname !== redirectURL.hostname) {\n        req.headers.delete('authorization');\n      }\n\n      // for POST request with 301/302 response, or any request with 303 response,\n      // use GET when following redirect\n      if (res.status === 303 || (res.status === 301 || res.status === 302) && req.method === 'POST') {\n        opts.method = 'GET';\n        opts.body = null;\n        req.headers.delete('content-length');\n      }\n      opts.headers = {};\n      req.headers.forEach((value, name) => {\n        opts.headers[name] = value;\n      });\n      opts.counter = ++req.counter;\n      return cachingFetch(resolvedUrl, opts);\n    }).catch(err => {\n      const code = err.code === 'EPROMISERETRY' ? err.retried.code : err.code;\n      const isRetryError = RETRY_ERRORS.indexOf(code) === -1 && RETRY_TYPES.indexOf(err.type) === -1;\n      if (req.method === 'POST' || isRetryError) {\n        throw err;\n      }\n      if (typeof opts.onRetry === 'function') {\n        opts.onRetry(err);\n      }\n      return retryHandler(err);\n    });\n  }, opts.retry).catch(err => {\n    if (err.status >= 400) {\n      return err;\n    }\n    throw err;\n  });\n}\nfunction isHeaderConditional(headers) {\n  if (!headers || typeof headers !== 'object') {\n    return false;\n  }\n  const modifiers = ['if-modified-since', 'if-none-match', 'if-unmodified-since', 'if-match', 'if-range'];\n  return Object.keys(headers).some(h => modifiers.indexOf(h.toLowerCase()) !== -1);\n}","map":{"version":3,"names":["Cache","url","require","CachePolicy","fetch","pkg","retry","ssri","Stream","getAgent","setWarning","isURL","USER_AGENT","name","version","RETRY_ERRORS","RETRY_TYPES","module","exports","cachingFetch","defaults","_uri","_opts","defaultedFetch","uri","opts","finalOpts","Object","assign","delete","cacheDelete","configureOptions","cacheManager","req","Request","method","headers","initializeCache","cache","isHeaderConditional","toUpperCase","retries","initializeSsri","integrity","compress","isCachable","match","then","res","warningCode","get","isStale","conditionalFetch","errorMsg","err","Error","code","remoteFetch","iterableToObject","iter","obj","k","keys","makePolicy","_req","_res","status","shared","policy","responseTime","_responseTime","Date","bool","satisfiesWithoutRevalidation","mustRevalidate","cachedRes","revalidationHeaders","condRes","revalidatedPolicy","body","put","newRes","Headers","responseHeaders","catch","message","remoteFetchHandleIntegrity","oldBod","newBod","integrityStream","pipe","once","emit","agent","reqOpts","follow","redirect","size","counter","timeout","retryHandler","attemptNum","set","isStream","isMethodGetHead","storable","onRetry","isRetriable","isRedirect","resolvedUrl","resolve","redirectURL","parse","test","hostname","forEach","value","retried","isRetryError","indexOf","type","modifiers","some","h","toLowerCase"],"sources":["/Users/hkateliev/node_modules/npm/node_modules/make-fetch-happen/index.js"],"sourcesContent":["'use strict'\n\nlet Cache\nconst url = require('url')\nconst CachePolicy = require('http-cache-semantics')\nconst fetch = require('node-fetch-npm')\nconst pkg = require('./package.json')\nconst retry = require('promise-retry')\nlet ssri\nconst Stream = require('stream')\nconst getAgent = require('./agent')\nconst setWarning = require('./warning')\n\nconst isURL = /^https?:/\nconst USER_AGENT = `${pkg.name}/${pkg.version} (+https://npm.im/${pkg.name})`\n\nconst RETRY_ERRORS = [\n  'ECONNRESET', // remote socket closed on us\n  'ECONNREFUSED', // remote host refused to open connection\n  'EADDRINUSE', // failed to bind to a local port (proxy?)\n  'ETIMEDOUT' // someone in the transaction is WAY TOO SLOW\n  // Known codes we do NOT retry on:\n  // ENOTFOUND (getaddrinfo failure. Either bad hostname, or offline)\n]\n\nconst RETRY_TYPES = [\n  'request-timeout'\n]\n\n// https://fetch.spec.whatwg.org/#http-network-or-cache-fetch\nmodule.exports = cachingFetch\ncachingFetch.defaults = function (_uri, _opts) {\n  const fetch = this\n  if (typeof _uri === 'object') {\n    _opts = _uri\n    _uri = null\n  }\n\n  function defaultedFetch (uri, opts) {\n    const finalOpts = Object.assign({}, _opts || {}, opts || {})\n    return fetch(uri || _uri, finalOpts)\n  }\n\n  defaultedFetch.defaults = fetch.defaults\n  defaultedFetch.delete = fetch.delete\n  return defaultedFetch\n}\n\ncachingFetch.delete = cacheDelete\nfunction cacheDelete (uri, opts) {\n  opts = configureOptions(opts)\n  if (opts.cacheManager) {\n    const req = new fetch.Request(uri, {\n      method: opts.method,\n      headers: opts.headers\n    })\n    return opts.cacheManager.delete(req, opts)\n  }\n}\n\nfunction initializeCache (opts) {\n  if (typeof opts.cacheManager === 'string') {\n    if (!Cache) {\n      // Default cacache-based cache\n      Cache = require('./cache')\n    }\n\n    opts.cacheManager = new Cache(opts.cacheManager, opts)\n  }\n\n  opts.cache = opts.cache || 'default'\n\n  if (opts.cache === 'default' && isHeaderConditional(opts.headers)) {\n    // If header list contains `If-Modified-Since`, `If-None-Match`,\n    // `If-Unmodified-Since`, `If-Match`, or `If-Range`, fetch will set cache\n    // mode to \"no-store\" if it is \"default\".\n    opts.cache = 'no-store'\n  }\n}\n\nfunction configureOptions (_opts) {\n  const opts = Object.assign({}, _opts || {})\n  opts.method = (opts.method || 'GET').toUpperCase()\n\n  if (opts.retry && typeof opts.retry === 'number') {\n    opts.retry = { retries: opts.retry }\n  }\n\n  if (opts.retry === false) {\n    opts.retry = { retries: 0 }\n  }\n\n  if (opts.cacheManager) {\n    initializeCache(opts)\n  }\n\n  return opts\n}\n\nfunction initializeSsri () {\n  if (!ssri) {\n    ssri = require('ssri')\n  }\n}\n\nfunction cachingFetch (uri, _opts) {\n  const opts = configureOptions(_opts)\n\n  if (opts.integrity) {\n    initializeSsri()\n    // if verifying integrity, node-fetch must not decompress\n    opts.compress = false\n  }\n\n  const isCachable = (opts.method === 'GET' || opts.method === 'HEAD') &&\n    opts.cacheManager &&\n    opts.cache !== 'no-store' &&\n    opts.cache !== 'reload'\n\n  if (isCachable) {\n    const req = new fetch.Request(uri, {\n      method: opts.method,\n      headers: opts.headers\n    })\n\n    return opts.cacheManager.match(req, opts).then(res => {\n      if (res) {\n        const warningCode = (res.headers.get('Warning') || '').match(/^\\d+/)\n        if (warningCode && +warningCode >= 100 && +warningCode < 200) {\n          // https://tools.ietf.org/html/rfc7234#section-4.3.4\n          //\n          // If a stored response is selected for update, the cache MUST:\n          //\n          // * delete any Warning header fields in the stored response with\n          //   warn-code 1xx (see Section 5.5);\n          //\n          // * retain any Warning header fields in the stored response with\n          //   warn-code 2xx;\n          //\n          res.headers.delete('Warning')\n        }\n\n        if (opts.cache === 'default' && !isStale(req, res)) {\n          return res\n        }\n\n        if (opts.cache === 'default' || opts.cache === 'no-cache') {\n          return conditionalFetch(req, res, opts)\n        }\n\n        if (opts.cache === 'force-cache' || opts.cache === 'only-if-cached') {\n          //   112 Disconnected operation\n          // SHOULD be included if the cache is intentionally disconnected from\n          // the rest of the network for a period of time.\n          // (https://tools.ietf.org/html/rfc2616#section-14.46)\n          setWarning(res, 112, 'Disconnected operation')\n          return res\n        }\n      }\n\n      if (!res && opts.cache === 'only-if-cached') {\n        const errorMsg = `request to ${\n          uri\n        } failed: cache mode is 'only-if-cached' but no cached response available.`\n\n        const err = new Error(errorMsg)\n        err.code = 'ENOTCACHED'\n        throw err\n      }\n\n      // Missing cache entry, or mode is default (if stale), reload, no-store\n      return remoteFetch(req.url, opts)\n    })\n  }\n\n  return remoteFetch(uri, opts)\n}\n\nfunction iterableToObject (iter) {\n  const obj = {}\n  for (let k of iter.keys()) {\n    obj[k] = iter.get(k)\n  }\n  return obj\n}\n\nfunction makePolicy (req, res) {\n  const _req = {\n    url: req.url,\n    method: req.method,\n    headers: iterableToObject(req.headers)\n  }\n  const _res = {\n    status: res.status,\n    headers: iterableToObject(res.headers)\n  }\n\n  return new CachePolicy(_req, _res, { shared: false })\n}\n\n// https://tools.ietf.org/html/rfc7234#section-4.2\nfunction isStale (req, res) {\n  if (!res) {\n    return null\n  }\n\n  const _req = {\n    url: req.url,\n    method: req.method,\n    headers: iterableToObject(req.headers)\n  }\n\n  const policy = makePolicy(req, res)\n\n  const responseTime = res.headers.get('x-local-cache-time') ||\n    res.headers.get('date') ||\n    0\n\n  policy._responseTime = new Date(responseTime)\n\n  const bool = !policy.satisfiesWithoutRevalidation(_req)\n  return bool\n}\n\nfunction mustRevalidate (res) {\n  return (res.headers.get('cache-control') || '').match(/must-revalidate/i)\n}\n\nfunction conditionalFetch (req, cachedRes, opts) {\n  const _req = {\n    url: req.url,\n    method: req.method,\n    headers: Object.assign({}, opts.headers || {})\n  }\n\n  const policy = makePolicy(req, cachedRes)\n  opts.headers = policy.revalidationHeaders(_req)\n\n  return remoteFetch(req.url, opts)\n    .then(condRes => {\n      const revalidatedPolicy = policy.revalidatedPolicy(_req, {\n        status: condRes.status,\n        headers: iterableToObject(condRes.headers)\n      })\n\n      if (condRes.status >= 500 && !mustRevalidate(cachedRes)) {\n        //   111 Revalidation failed\n        // MUST be included if a cache returns a stale response because an\n        // attempt to revalidate the response failed, due to an inability to\n        // reach the server.\n        // (https://tools.ietf.org/html/rfc2616#section-14.46)\n        setWarning(cachedRes, 111, 'Revalidation failed')\n        return cachedRes\n      }\n\n      if (condRes.status === 304) { // 304 Not Modified\n        condRes.body = cachedRes.body\n        return opts.cacheManager.put(req, condRes, opts)\n          .then(newRes => {\n            newRes.headers = new fetch.Headers(revalidatedPolicy.policy.responseHeaders())\n            return newRes\n          })\n      }\n\n      return condRes\n    })\n    .then(res => res)\n    .catch(err => {\n      if (mustRevalidate(cachedRes)) {\n        throw err\n      } else {\n        //   111 Revalidation failed\n        // MUST be included if a cache returns a stale response because an\n        // attempt to revalidate the response failed, due to an inability to\n        // reach the server.\n        // (https://tools.ietf.org/html/rfc2616#section-14.46)\n        setWarning(cachedRes, 111, 'Revalidation failed')\n        //   199 Miscellaneous warning\n        // The warning text MAY include arbitrary information to be presented to\n        // a human user, or logged. A system receiving this warning MUST NOT take\n        // any automated action, besides presenting the warning to the user.\n        // (https://tools.ietf.org/html/rfc2616#section-14.46)\n        setWarning(\n          cachedRes,\n          199,\n          `Miscellaneous Warning ${err.code}: ${err.message}`\n        )\n\n        return cachedRes\n      }\n    })\n}\n\nfunction remoteFetchHandleIntegrity (res, integrity) {\n  const oldBod = res.body\n  const newBod = ssri.integrityStream({\n    integrity\n  })\n  oldBod.pipe(newBod)\n  res.body = newBod\n  oldBod.once('error', err => {\n    newBod.emit('error', err)\n  })\n  newBod.once('error', err => {\n    oldBod.emit('error', err)\n  })\n}\n\nfunction remoteFetch (uri, opts) {\n  const agent = getAgent(uri, opts)\n  const headers = Object.assign({\n    'connection': agent ? 'keep-alive' : 'close',\n    'user-agent': USER_AGENT\n  }, opts.headers || {})\n\n  const reqOpts = {\n    agent,\n    body: opts.body,\n    compress: opts.compress,\n    follow: opts.follow,\n    headers: new fetch.Headers(headers),\n    method: opts.method,\n    redirect: 'manual',\n    size: opts.size,\n    counter: opts.counter,\n    timeout: opts.timeout\n  }\n\n  return retry(\n    (retryHandler, attemptNum) => {\n      const req = new fetch.Request(uri, reqOpts)\n      return fetch(req)\n        .then(res => {\n          res.headers.set('x-fetch-attempts', attemptNum)\n\n          if (opts.integrity) {\n            remoteFetchHandleIntegrity(res, opts.integrity)\n          }\n\n          const isStream = req.body instanceof Stream\n\n          if (opts.cacheManager) {\n            const isMethodGetHead = req.method === 'GET' ||\n              req.method === 'HEAD'\n\n            const isCachable = opts.cache !== 'no-store' &&\n              isMethodGetHead &&\n              makePolicy(req, res).storable() &&\n              res.status === 200 // No other statuses should be stored!\n\n            if (isCachable) {\n              return opts.cacheManager.put(req, res, opts)\n            }\n\n            if (!isMethodGetHead) {\n              return opts.cacheManager.delete(req).then(() => {\n                if (res.status >= 500 && req.method !== 'POST' && !isStream) {\n                  if (typeof opts.onRetry === 'function') {\n                    opts.onRetry(res)\n                  }\n\n                  return retryHandler(res)\n                }\n\n                return res\n              })\n            }\n          }\n\n          const isRetriable = req.method !== 'POST' &&\n            !isStream && (\n              res.status === 408 || // Request Timeout\n              res.status === 420 || // Enhance Your Calm (usually Twitter rate-limit)\n              res.status === 429 || // Too Many Requests (\"standard\" rate-limiting)\n              res.status >= 500 // Assume server errors are momentary hiccups\n            )\n\n          if (isRetriable) {\n            if (typeof opts.onRetry === 'function') {\n              opts.onRetry(res)\n            }\n\n            return retryHandler(res)\n          }\n\n          if (!fetch.isRedirect(res.status) || opts.redirect === 'manual') {\n            return res\n          }\n\n          // handle redirects - matches behavior of npm-fetch: https://github.com/bitinn/node-fetch\n          if (opts.redirect === 'error') {\n            const err = new Error(`redirect mode is set to error: ${uri}`)\n            err.code = 'ENOREDIRECT'\n            throw err\n          }\n\n          if (!res.headers.get('location')) {\n            const err = new Error(`redirect location header missing at: ${uri}`)\n            err.code = 'EINVALIDREDIRECT'\n            throw err\n          }\n\n          if (req.counter >= req.follow) {\n            const err = new Error(`maximum redirect reached at: ${uri}`)\n            err.code = 'EMAXREDIRECT'\n            throw err\n          }\n\n          const resolvedUrl = url.resolve(req.url, res.headers.get('location'))\n          let redirectURL = url.parse(resolvedUrl)\n\n          if (isURL.test(res.headers.get('location'))) {\n            redirectURL = url.parse(res.headers.get('location'))\n          }\n\n          // Remove authorization if changing hostnames (but not if just\n          // changing ports or protocols).  This matches the behavior of request:\n          // https://github.com/request/request/blob/b12a6245/lib/redirect.js#L134-L138\n          if (url.parse(req.url).hostname !== redirectURL.hostname) {\n            req.headers.delete('authorization')\n          }\n\n          // for POST request with 301/302 response, or any request with 303 response,\n          // use GET when following redirect\n          if (res.status === 303 ||\n            ((res.status === 301 || res.status === 302) && req.method === 'POST')) {\n            opts.method = 'GET'\n            opts.body = null\n            req.headers.delete('content-length')\n          }\n\n          opts.headers = {}\n          req.headers.forEach((value, name) => {\n            opts.headers[name] = value\n          })\n\n          opts.counter = ++req.counter\n          return cachingFetch(resolvedUrl, opts)\n        })\n        .catch(err => {\n          const code = err.code === 'EPROMISERETRY' ? err.retried.code : err.code\n\n          const isRetryError = RETRY_ERRORS.indexOf(code) === -1 &&\n            RETRY_TYPES.indexOf(err.type) === -1\n\n          if (req.method === 'POST' || isRetryError) {\n            throw err\n          }\n\n          if (typeof opts.onRetry === 'function') {\n            opts.onRetry(err)\n          }\n\n          return retryHandler(err)\n        })\n    },\n    opts.retry\n  ).catch(err => {\n    if (err.status >= 400) {\n      return err\n    }\n\n    throw err\n  })\n}\n\nfunction isHeaderConditional (headers) {\n  if (!headers || typeof headers !== 'object') {\n    return false\n  }\n\n  const modifiers = [\n    'if-modified-since',\n    'if-none-match',\n    'if-unmodified-since',\n    'if-match',\n    'if-range'\n  ]\n\n  return Object.keys(headers)\n    .some(h => modifiers.indexOf(h.toLowerCase()) !== -1)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}