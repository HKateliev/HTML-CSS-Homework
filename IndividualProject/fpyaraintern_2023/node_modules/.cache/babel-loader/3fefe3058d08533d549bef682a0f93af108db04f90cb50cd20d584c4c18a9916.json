{"ast":null,"code":"'use strict';\n\nconst EE = require('events');\nconst Yallist = require('yallist');\nconst SD = require('string_decoder').StringDecoder;\nconst EOF = Symbol('EOF');\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd');\nconst EMITTED_END = Symbol('emittedEnd');\nconst EMITTING_END = Symbol('emittingEnd');\nconst CLOSED = Symbol('closed');\nconst READ = Symbol('read');\nconst FLUSH = Symbol('flush');\nconst FLUSHCHUNK = Symbol('flushChunk');\nconst ENCODING = Symbol('encoding');\nconst DECODER = Symbol('decoder');\nconst FLOWING = Symbol('flowing');\nconst PAUSED = Symbol('paused');\nconst RESUME = Symbol('resume');\nconst BUFFERLENGTH = Symbol('bufferLength');\nconst BUFFERPUSH = Symbol('bufferPush');\nconst BUFFERSHIFT = Symbol('bufferShift');\nconst OBJECTMODE = Symbol('objectMode');\nconst DESTROYED = Symbol('destroyed');\n\n// TODO remove when Node v8 support drops\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== '1';\nconst ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol('asyncIterator not implemented');\nconst ITERATOR = doIter && Symbol.iterator || Symbol('iterator not implemented');\n\n// Buffer in node 4.x < 4.5.0 doesn't have working Buffer.from\n// or Buffer.alloc, and Buffer in node 10 deprecated the ctor.\n// .M, this is fine .\\^/M..\nconst B = Buffer.alloc ? Buffer : /* istanbul ignore next */require('safe-buffer').Buffer;\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\nconst isEndish = ev => ev === 'end' || ev === 'finish' || ev === 'prefinish';\nconst isArrayBuffer = b => b instanceof ArrayBuffer || typeof b === 'object' && b.constructor && b.constructor.name === 'ArrayBuffer' && b.byteLength >= 0;\nconst isArrayBufferView = b => !B.isBuffer(b) && ArrayBuffer.isView(b);\nmodule.exports = class Minipass extends EE {\n  constructor(options) {\n    super();\n    this[FLOWING] = false;\n    // whether we're explicitly paused\n    this[PAUSED] = false;\n    this.pipes = new Yallist();\n    this.buffer = new Yallist();\n    this[OBJECTMODE] = options && options.objectMode || false;\n    if (this[OBJECTMODE]) this[ENCODING] = null;else this[ENCODING] = options && options.encoding || null;\n    if (this[ENCODING] === 'buffer') this[ENCODING] = null;\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;\n    this[EOF] = false;\n    this[EMITTED_END] = false;\n    this[EMITTING_END] = false;\n    this[CLOSED] = false;\n    this.writable = true;\n    this.readable = true;\n    this[BUFFERLENGTH] = 0;\n    this[DESTROYED] = false;\n  }\n  get bufferLength() {\n    return this[BUFFERLENGTH];\n  }\n  get encoding() {\n    return this[ENCODING];\n  }\n  set encoding(enc) {\n    if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode');\n    if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH])) throw new Error('cannot change encoding');\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null;\n      if (this.buffer.length) this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk));\n    }\n    this[ENCODING] = enc;\n  }\n  setEncoding(enc) {\n    this.encoding = enc;\n  }\n  get objectMode() {\n    return this[OBJECTMODE];\n  }\n  set objectMode(ॐ) {\n    this[OBJECTMODE] = this[OBJECTMODE] || !!ॐ;\n  }\n  write(chunk, encoding, cb) {\n    if (this[EOF]) throw new Error('write after end');\n    if (this[DESTROYED]) {\n      this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), {\n        code: 'ERR_STREAM_DESTROYED'\n      }));\n      return true;\n    }\n    if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n    if (!encoding) encoding = 'utf8';\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n    if (!this[OBJECTMODE] && !B.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk)) chunk = B.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);else if (isArrayBuffer(chunk)) chunk = B.from(chunk);else if (typeof chunk !== 'string')\n        // use the setter so we throw if we have encoding set\n        this.objectMode = true;\n    }\n\n    // this ensures at this point that the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!this.objectMode && !chunk.length) {\n      const ret = this.flowing;\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n      if (cb) cb();\n      return ret;\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (typeof chunk === 'string' && !this[OBJECTMODE] &&\n    // unless it is a string already ready for us to use\n    !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n      chunk = B.from(chunk, encoding);\n    }\n    if (B.isBuffer(chunk) && this[ENCODING]) chunk = this[DECODER].write(chunk);\n    try {\n      return this.flowing ? (this.emit('data', chunk), this.flowing) : (this[BUFFERPUSH](chunk), false);\n    } finally {\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n      if (cb) cb();\n    }\n  }\n  read(n) {\n    if (this[DESTROYED]) return null;\n    try {\n      if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) return null;\n      if (this[OBJECTMODE]) n = null;\n      if (this.buffer.length > 1 && !this[OBJECTMODE]) {\n        if (this.encoding) this.buffer = new Yallist([Array.from(this.buffer).join('')]);else this.buffer = new Yallist([B.concat(Array.from(this.buffer), this[BUFFERLENGTH])]);\n      }\n      return this[READ](n || null, this.buffer.head.value);\n    } finally {\n      this[MAYBE_EMIT_END]();\n    }\n  }\n  [READ](n, chunk) {\n    if (n === chunk.length || n === null) this[BUFFERSHIFT]();else {\n      this.buffer.head.value = chunk.slice(n);\n      chunk = chunk.slice(0, n);\n      this[BUFFERLENGTH] -= n;\n    }\n    this.emit('data', chunk);\n    if (!this.buffer.length && !this[EOF]) this.emit('drain');\n    return chunk;\n  }\n  end(chunk, encoding, cb) {\n    if (typeof chunk === 'function') cb = chunk, chunk = null;\n    if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n    if (chunk) this.write(chunk, encoding);\n    if (cb) this.once('end', cb);\n    this[EOF] = true;\n    this.writable = false;\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();\n    return this;\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME]() {\n    if (this[DESTROYED]) return;\n    this[PAUSED] = false;\n    this[FLOWING] = true;\n    this.emit('resume');\n    if (this.buffer.length) this[FLUSH]();else if (this[EOF]) this[MAYBE_EMIT_END]();else this.emit('drain');\n  }\n  resume() {\n    return this[RESUME]();\n  }\n  pause() {\n    this[FLOWING] = false;\n    this[PAUSED] = true;\n  }\n  get destroyed() {\n    return this[DESTROYED];\n  }\n  get flowing() {\n    return this[FLOWING];\n  }\n  get paused() {\n    return this[PAUSED];\n  }\n  [BUFFERPUSH](chunk) {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;else this[BUFFERLENGTH] += chunk.length;\n    return this.buffer.push(chunk);\n  }\n  [BUFFERSHIFT]() {\n    if (this.buffer.length) {\n      if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;else this[BUFFERLENGTH] -= this.buffer.head.value.length;\n    }\n    return this.buffer.shift();\n  }\n  [FLUSH]() {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));\n    if (!this.buffer.length && !this[EOF]) this.emit('drain');\n  }\n  [FLUSHCHUNK](chunk) {\n    return chunk ? (this.emit('data', chunk), this.flowing) : false;\n  }\n  pipe(dest, opts) {\n    if (this[DESTROYED]) return;\n    const ended = this[EMITTED_END];\n    opts = opts || {};\n    if (dest === process.stdout || dest === process.stderr) opts.end = false;else opts.end = opts.end !== false;\n    const p = {\n      dest: dest,\n      opts: opts,\n      ondrain: _ => this[RESUME]()\n    };\n    this.pipes.push(p);\n    dest.on('drain', p.ondrain);\n    this[RESUME]();\n    // piping an ended stream ends immediately\n    if (ended && p.opts.end) p.dest.end();\n    return dest;\n  }\n  addListener(ev, fn) {\n    return this.on(ev, fn);\n  }\n  on(ev, fn) {\n    try {\n      return super.on(ev, fn);\n    } finally {\n      if (ev === 'data' && !this.pipes.length && !this.flowing) this[RESUME]();else if (isEndish(ev) && this[EMITTED_END]) {\n        super.emit(ev);\n        this.removeAllListeners(ev);\n      }\n    }\n  }\n  get emittedEnd() {\n    return this[EMITTED_END];\n  }\n  [MAYBE_EMIT_END]() {\n    if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {\n      this[EMITTING_END] = true;\n      this.emit('end');\n      this.emit('prefinish');\n      this.emit('finish');\n      if (this[CLOSED]) this.emit('close');\n      this[EMITTING_END] = false;\n    }\n  }\n  emit(ev, data) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED]) return;else if (ev === 'data') {\n      if (!data) return;\n      if (this.pipes.length) this.pipes.forEach(p => p.dest.write(data) === false && this.pause());\n    } else if (ev === 'end') {\n      // only actual end gets this treatment\n      if (this[EMITTED_END] === true) return;\n      this[EMITTED_END] = true;\n      this.readable = false;\n      if (this[DECODER]) {\n        data = this[DECODER].end();\n        if (data) {\n          this.pipes.forEach(p => p.dest.write(data));\n          super.emit('data', data);\n        }\n      }\n      this.pipes.forEach(p => {\n        p.dest.removeListener('drain', p.ondrain);\n        if (p.opts.end) p.dest.end();\n      });\n    } else if (ev === 'close') {\n      this[CLOSED] = true;\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED]) return;\n    }\n\n    // TODO: replace with a spread operator when Node v4 support drops\n    const args = new Array(arguments.length);\n    args[0] = ev;\n    args[1] = data;\n    if (arguments.length > 2) {\n      for (let i = 2; i < arguments.length; i++) {\n        args[i] = arguments[i];\n      }\n    }\n    try {\n      return super.emit.apply(this, args);\n    } finally {\n      if (!isEndish(ev)) this[MAYBE_EMIT_END]();else this.removeAllListeners(ev);\n    }\n  }\n\n  // const all = await stream.collect()\n  collect() {\n    const buf = [];\n    buf.dataLength = 0;\n    this.on('data', c => {\n      buf.push(c);\n      buf.dataLength += c.length;\n    });\n    return this.promise().then(() => buf);\n  }\n\n  // const data = await stream.concat()\n  concat() {\n    return this[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : this.collect().then(buf => this[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : this[ENCODING] ? buf.join('') : B.concat(buf, buf.dataLength));\n  }\n\n  // stream.promise().then(() => done, er => emitted error)\n  promise() {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')));\n      this.on('end', () => resolve());\n      this.on('error', er => reject(er));\n    });\n  }\n\n  // for await (let chunk of stream)\n  [ASYNCITERATOR]() {\n    const next = () => {\n      const res = this.read();\n      if (res !== null) return Promise.resolve({\n        done: false,\n        value: res\n      });\n      if (this[EOF]) return Promise.resolve({\n        done: true\n      });\n      let resolve = null;\n      let reject = null;\n      const onerr = er => {\n        this.removeListener('data', ondata);\n        this.removeListener('end', onend);\n        reject(er);\n      };\n      const ondata = value => {\n        this.removeListener('error', onerr);\n        this.removeListener('end', onend);\n        this.pause();\n        resolve({\n          value: value,\n          done: !!this[EOF]\n        });\n      };\n      const onend = () => {\n        this.removeListener('error', onerr);\n        this.removeListener('data', ondata);\n        resolve({\n          done: true\n        });\n      };\n      const ondestroy = () => onerr(new Error('stream destroyed'));\n      return new Promise((res, rej) => {\n        reject = rej;\n        resolve = res;\n        this.once(DESTROYED, ondestroy);\n        this.once('error', onerr);\n        this.once('end', onend);\n        this.once('data', ondata);\n      });\n    };\n    return {\n      next\n    };\n  }\n\n  // for (let chunk of stream)\n  [ITERATOR]() {\n    const next = () => {\n      const value = this.read();\n      const done = value === null;\n      return {\n        value,\n        done\n      };\n    };\n    return {\n      next\n    };\n  }\n  destroy(er) {\n    if (this[DESTROYED]) {\n      if (er) this.emit('error', er);else this.emit(DESTROYED);\n      return this;\n    }\n    this[DESTROYED] = true;\n\n    // throw away all buffered data, it's never coming out\n    this.buffer = new Yallist();\n    this[BUFFERLENGTH] = 0;\n    if (typeof this.close === 'function' && !this[CLOSED]) this.close();\n    if (er) this.emit('error', er);else\n      // if no error to emit, still reject pending promises\n      this.emit(DESTROYED);\n    return this;\n  }\n  static isStream(s) {\n    return !!s && (s instanceof Minipass || s instanceof EE && (typeof s.pipe === 'function' ||\n    // readable\n    typeof s.write === 'function' && typeof s.end === 'function' // writable\n    ));\n  }\n};","map":{"version":3,"names":["EE","require","Yallist","SD","StringDecoder","EOF","Symbol","MAYBE_EMIT_END","EMITTED_END","EMITTING_END","CLOSED","READ","FLUSH","FLUSHCHUNK","ENCODING","DECODER","FLOWING","PAUSED","RESUME","BUFFERLENGTH","BUFFERPUSH","BUFFERSHIFT","OBJECTMODE","DESTROYED","doIter","global","_MP_NO_ITERATOR_SYMBOLS_","ASYNCITERATOR","asyncIterator","ITERATOR","iterator","B","Buffer","alloc","isEndish","ev","isArrayBuffer","b","ArrayBuffer","constructor","name","byteLength","isArrayBufferView","isBuffer","isView","module","exports","Minipass","options","pipes","buffer","objectMode","encoding","writable","readable","bufferLength","enc","Error","lastNeed","length","map","chunk","write","setEncoding","ॐ","cb","emit","Object","assign","code","from","byteOffset","ret","flowing","read","n","Array","join","concat","head","value","slice","end","once","resume","pause","destroyed","paused","push","shift","pipe","dest","opts","ended","process","stdout","stderr","p","ondrain","_","on","addListener","fn","removeAllListeners","emittedEnd","data","forEach","removeListener","args","arguments","i","apply","collect","buf","dataLength","c","promise","then","Promise","reject","resolve","er","next","res","done","onerr","ondata","onend","ondestroy","rej","destroy","close","isStream","s"],"sources":["/Users/hkateliev/node_modules/npm/node_modules/fs-minipass/node_modules/minipass/index.js"],"sourcesContent":["'use strict'\nconst EE = require('events')\nconst Yallist = require('yallist')\nconst SD = require('string_decoder').StringDecoder\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\nconst DESTROYED = Symbol('destroyed')\n\n// TODO remove when Node v8 support drops\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_  !== '1'\nconst ASYNCITERATOR = doIter && Symbol.asyncIterator\n  || Symbol('asyncIterator not implemented')\nconst ITERATOR = doIter && Symbol.iterator\n  || Symbol('iterator not implemented')\n\n// Buffer in node 4.x < 4.5.0 doesn't have working Buffer.from\n// or Buffer.alloc, and Buffer in node 10 deprecated the ctor.\n// .M, this is fine .\\^/M..\nconst B = Buffer.alloc ? Buffer\n  : /* istanbul ignore next */ require('safe-buffer').Buffer\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\nconst isEndish = ev =>\n  ev === 'end' ||\n  ev === 'finish' ||\n  ev === 'prefinish'\n\nconst isArrayBuffer = b => b instanceof ArrayBuffer ||\n  typeof b === 'object' &&\n  b.constructor &&\n  b.constructor.name === 'ArrayBuffer' &&\n  b.byteLength >= 0\n\nconst isArrayBufferView = b => !B.isBuffer(b) && ArrayBuffer.isView(b)\n\nmodule.exports = class Minipass extends EE {\n  constructor (options) {\n    super()\n    this[FLOWING] = false\n    // whether we're explicitly paused\n    this[PAUSED] = false\n    this.pipes = new Yallist()\n    this.buffer = new Yallist()\n    this[OBJECTMODE] = options && options.objectMode || false\n    if (this[OBJECTMODE])\n      this[ENCODING] = null\n    else\n      this[ENCODING] = options && options.encoding || null\n    if (this[ENCODING] === 'buffer')\n      this[ENCODING] = null\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null\n    this[EOF] = false\n    this[EMITTED_END] = false\n    this[EMITTING_END] = false\n    this[CLOSED] = false\n    this.writable = true\n    this.readable = true\n    this[BUFFERLENGTH] = 0\n    this[DESTROYED] = false\n  }\n\n  get bufferLength () { return this[BUFFERLENGTH] }\n\n  get encoding () { return this[ENCODING] }\n  set encoding (enc) {\n    if (this[OBJECTMODE])\n      throw new Error('cannot set encoding in objectMode')\n\n    if (this[ENCODING] && enc !== this[ENCODING] &&\n        (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))\n      throw new Error('cannot change encoding')\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null\n      if (this.buffer.length)\n        this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk))\n    }\n\n    this[ENCODING] = enc\n  }\n\n  setEncoding (enc) {\n    this.encoding = enc\n  }\n\n  get objectMode () { return this[OBJECTMODE] }\n  set objectMode (ॐ ) { this[OBJECTMODE] = this[OBJECTMODE] || !!ॐ  }\n\n  write (chunk, encoding, cb) {\n    if (this[EOF])\n      throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit('error', Object.assign(\n        new Error('Cannot call write after a stream was destroyed'),\n        { code: 'ERR_STREAM_DESTROYED' }\n      ))\n      return true\n    }\n\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (!encoding)\n      encoding = 'utf8'\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n    if (!this[OBJECTMODE] && !B.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk))\n        chunk = B.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\n      else if (isArrayBuffer(chunk))\n        chunk = B.from(chunk)\n      else if (typeof chunk !== 'string')\n        // use the setter so we throw if we have encoding set\n        this.objectMode = true\n    }\n\n    // this ensures at this point that the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!this.objectMode && !chunk.length) {\n      const ret = this.flowing\n      if (this[BUFFERLENGTH] !== 0)\n        this.emit('readable')\n      if (cb)\n        cb()\n      return ret\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (typeof chunk === 'string' && !this[OBJECTMODE] &&\n        // unless it is a string already ready for us to use\n        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n      chunk = B.from(chunk, encoding)\n    }\n\n    if (B.isBuffer(chunk) && this[ENCODING])\n      chunk = this[DECODER].write(chunk)\n\n    try {\n      return this.flowing\n        ? (this.emit('data', chunk), this.flowing)\n        : (this[BUFFERPUSH](chunk), false)\n    } finally {\n      if (this[BUFFERLENGTH] !== 0)\n        this.emit('readable')\n      if (cb)\n        cb()\n    }\n  }\n\n  read (n) {\n    if (this[DESTROYED])\n      return null\n\n    try {\n      if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH])\n        return null\n\n      if (this[OBJECTMODE])\n        n = null\n\n      if (this.buffer.length > 1 && !this[OBJECTMODE]) {\n        if (this.encoding)\n          this.buffer = new Yallist([\n            Array.from(this.buffer).join('')\n          ])\n        else\n          this.buffer = new Yallist([\n            B.concat(Array.from(this.buffer), this[BUFFERLENGTH])\n          ])\n      }\n\n      return this[READ](n || null, this.buffer.head.value)\n    } finally {\n      this[MAYBE_EMIT_END]()\n    }\n  }\n\n  [READ] (n, chunk) {\n    if (n === chunk.length || n === null)\n      this[BUFFERSHIFT]()\n    else {\n      this.buffer.head.value = chunk.slice(n)\n      chunk = chunk.slice(0, n)\n      this[BUFFERLENGTH] -= n\n    }\n\n    this.emit('data', chunk)\n\n    if (!this.buffer.length && !this[EOF])\n      this.emit('drain')\n\n    return chunk\n  }\n\n  end (chunk, encoding, cb) {\n    if (typeof chunk === 'function')\n      cb = chunk, chunk = null\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n    if (chunk)\n      this.write(chunk, encoding)\n    if (cb)\n      this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this.flowing || !this[PAUSED])\n      this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME] () {\n    if (this[DESTROYED])\n      return\n\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this.buffer.length)\n      this[FLUSH]()\n    else if (this[EOF])\n      this[MAYBE_EMIT_END]()\n    else\n      this.emit('drain')\n  }\n\n  resume () {\n    return this[RESUME]()\n  }\n\n  pause () {\n    this[FLOWING] = false\n    this[PAUSED] = true\n  }\n\n  get destroyed () {\n    return this[DESTROYED]\n  }\n\n  get flowing () {\n    return this[FLOWING]\n  }\n\n  get paused () {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH] (chunk) {\n    if (this[OBJECTMODE])\n      this[BUFFERLENGTH] += 1\n    else\n      this[BUFFERLENGTH] += chunk.length\n    return this.buffer.push(chunk)\n  }\n\n  [BUFFERSHIFT] () {\n    if (this.buffer.length) {\n      if (this[OBJECTMODE])\n        this[BUFFERLENGTH] -= 1\n      else\n        this[BUFFERLENGTH] -= this.buffer.head.value.length\n    }\n    return this.buffer.shift()\n  }\n\n  [FLUSH] () {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()))\n\n    if (!this.buffer.length && !this[EOF])\n      this.emit('drain')\n  }\n\n  [FLUSHCHUNK] (chunk) {\n    return chunk ? (this.emit('data', chunk), this.flowing) : false\n  }\n\n  pipe (dest, opts) {\n    if (this[DESTROYED])\n      return\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === process.stdout || dest === process.stderr)\n      opts.end = false\n    else\n      opts.end = opts.end !== false\n\n    const p = { dest: dest, opts: opts, ondrain: _ => this[RESUME]() }\n    this.pipes.push(p)\n\n    dest.on('drain', p.ondrain)\n    this[RESUME]()\n    // piping an ended stream ends immediately\n    if (ended && p.opts.end)\n      p.dest.end()\n    return dest\n  }\n\n  addListener (ev, fn) {\n    return this.on(ev, fn)\n  }\n\n  on (ev, fn) {\n    try {\n      return super.on(ev, fn)\n    } finally {\n      if (ev === 'data' && !this.pipes.length && !this.flowing)\n        this[RESUME]()\n      else if (isEndish(ev) && this[EMITTED_END]) {\n        super.emit(ev)\n        this.removeAllListeners(ev)\n      }\n    }\n  }\n\n  get emittedEnd () {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END] () {\n    if (!this[EMITTING_END] &&\n        !this[EMITTED_END] &&\n        !this[DESTROYED] &&\n        this.buffer.length === 0 &&\n        this[EOF]) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED])\n        this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  emit (ev, data) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])\n      return\n    else if (ev === 'data') {\n      if (!data)\n        return\n\n      if (this.pipes.length)\n        this.pipes.forEach(p =>\n          p.dest.write(data) === false && this.pause())\n    } else if (ev === 'end') {\n      // only actual end gets this treatment\n      if (this[EMITTED_END] === true)\n        return\n\n      this[EMITTED_END] = true\n      this.readable = false\n\n      if (this[DECODER]) {\n        data = this[DECODER].end()\n        if (data) {\n          this.pipes.forEach(p => p.dest.write(data))\n          super.emit('data', data)\n        }\n      }\n\n      this.pipes.forEach(p => {\n        p.dest.removeListener('drain', p.ondrain)\n        if (p.opts.end)\n          p.dest.end()\n      })\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED])\n        return\n    }\n\n    // TODO: replace with a spread operator when Node v4 support drops\n    const args = new Array(arguments.length)\n    args[0] = ev\n    args[1] = data\n    if (arguments.length > 2) {\n      for (let i = 2; i < arguments.length; i++) {\n        args[i] = arguments[i]\n      }\n    }\n\n    try {\n      return super.emit.apply(this, args)\n    } finally {\n      if (!isEndish(ev))\n        this[MAYBE_EMIT_END]()\n      else\n        this.removeAllListeners(ev)\n    }\n  }\n\n  // const all = await stream.collect()\n  collect () {\n    const buf = []\n    buf.dataLength = 0\n    this.on('data', c => {\n      buf.push(c)\n      buf.dataLength += c.length\n    })\n    return this.promise().then(() => buf)\n  }\n\n  // const data = await stream.concat()\n  concat () {\n    return this[OBJECTMODE]\n      ? Promise.reject(new Error('cannot concat in objectMode'))\n      : this.collect().then(buf =>\n          this[OBJECTMODE]\n            ? Promise.reject(new Error('cannot concat in objectMode'))\n            : this[ENCODING] ? buf.join('') : B.concat(buf, buf.dataLength))\n  }\n\n  // stream.promise().then(() => done, er => emitted error)\n  promise () {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('end', () => resolve())\n      this.on('error', er => reject(er))\n    })\n  }\n\n  // for await (let chunk of stream)\n  [ASYNCITERATOR] () {\n    const next = () => {\n      const res = this.read()\n      if (res !== null)\n        return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF])\n        return Promise.resolve({ done: true })\n\n      let resolve = null\n      let reject = null\n      const onerr = er => {\n        this.removeListener('data', ondata)\n        this.removeListener('end', onend)\n        reject(er)\n      }\n      const ondata = value => {\n        this.removeListener('error', onerr)\n        this.removeListener('end', onend)\n        this.pause()\n        resolve({ value: value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.removeListener('error', onerr)\n        this.removeListener('data', ondata)\n        resolve({ done: true })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return { next }\n  }\n\n  // for (let chunk of stream)\n  [ITERATOR] () {\n    const next = () => {\n      const value = this.read()\n      const done = value === null\n      return { value, done }\n    }\n    return { next }\n  }\n\n  destroy (er) {\n    if (this[DESTROYED]) {\n      if (er)\n        this.emit('error', er)\n      else\n        this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n\n    // throw away all buffered data, it's never coming out\n    this.buffer = new Yallist()\n    this[BUFFERLENGTH] = 0\n\n    if (typeof this.close === 'function' && !this[CLOSED])\n      this.close()\n\n    if (er)\n      this.emit('error', er)\n    else // if no error to emit, still reject pending promises\n      this.emit(DESTROYED)\n\n    return this\n  }\n\n  static isStream (s) {\n    return !!s && (s instanceof Minipass || s instanceof EE && (\n      typeof s.pipe === 'function' || // readable\n      (typeof s.write === 'function' && typeof s.end === 'function') // writable\n    ))\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}