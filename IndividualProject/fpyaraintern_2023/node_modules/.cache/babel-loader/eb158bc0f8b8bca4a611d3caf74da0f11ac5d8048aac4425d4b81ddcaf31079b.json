{"ast":null,"code":"// Note: since nyc uses this module to output coverage, any lines\n// that are in the direct sync flow of nyc's outputCoverage are\n// ignored, since we can never get coverage for them.\nvar assert = require('assert');\nvar signals = require('./signals.js');\nvar EE = require('events');\n/* istanbul ignore if */\nif (typeof EE !== 'function') {\n  EE = EE.EventEmitter;\n}\nvar emitter;\nif (process.__signal_exit_emitter__) {\n  emitter = process.__signal_exit_emitter__;\n} else {\n  emitter = process.__signal_exit_emitter__ = new EE();\n  emitter.count = 0;\n  emitter.emitted = {};\n}\n\n// Because this emitter is a global, we have to check to see if a\n// previous version of this library failed to enable infinite listeners.\n// I know what you're about to say.  But literally everything about\n// signal-exit is a compromise with evil.  Get used to it.\nif (!emitter.infinite) {\n  emitter.setMaxListeners(Infinity);\n  emitter.infinite = true;\n}\nmodule.exports = function (cb, opts) {\n  assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler');\n  if (loaded === false) {\n    load();\n  }\n  var ev = 'exit';\n  if (opts && opts.alwaysLast) {\n    ev = 'afterexit';\n  }\n  var remove = function () {\n    emitter.removeListener(ev, cb);\n    if (emitter.listeners('exit').length === 0 && emitter.listeners('afterexit').length === 0) {\n      unload();\n    }\n  };\n  emitter.on(ev, cb);\n  return remove;\n};\nmodule.exports.unload = unload;\nfunction unload() {\n  if (!loaded) {\n    return;\n  }\n  loaded = false;\n  signals.forEach(function (sig) {\n    try {\n      process.removeListener(sig, sigListeners[sig]);\n    } catch (er) {}\n  });\n  process.emit = originalProcessEmit;\n  process.reallyExit = originalProcessReallyExit;\n  emitter.count -= 1;\n}\nfunction emit(event, code, signal) {\n  if (emitter.emitted[event]) {\n    return;\n  }\n  emitter.emitted[event] = true;\n  emitter.emit(event, code, signal);\n}\n\n// { <signal>: <listener fn>, ... }\nvar sigListeners = {};\nsignals.forEach(function (sig) {\n  sigListeners[sig] = function listener() {\n    // If there are no other listeners, an exit is coming!\n    // Simplest way: remove us and then re-send the signal.\n    // We know that this will kill the process, so we can\n    // safely emit now.\n    var listeners = process.listeners(sig);\n    if (listeners.length === emitter.count) {\n      unload();\n      emit('exit', null, sig);\n      /* istanbul ignore next */\n      emit('afterexit', null, sig);\n      /* istanbul ignore next */\n      process.kill(process.pid, sig);\n    }\n  };\n});\nmodule.exports.signals = function () {\n  return signals;\n};\nmodule.exports.load = load;\nvar loaded = false;\nfunction load() {\n  if (loaded) {\n    return;\n  }\n  loaded = true;\n\n  // This is the number of onSignalExit's that are in play.\n  // It's important so that we can count the correct number of\n  // listeners on signals, and don't wait for the other one to\n  // handle it instead of us.\n  emitter.count += 1;\n  signals = signals.filter(function (sig) {\n    try {\n      process.on(sig, sigListeners[sig]);\n      return true;\n    } catch (er) {\n      return false;\n    }\n  });\n  process.emit = processEmit;\n  process.reallyExit = processReallyExit;\n}\nvar originalProcessReallyExit = process.reallyExit;\nfunction processReallyExit(code) {\n  process.exitCode = code || 0;\n  emit('exit', process.exitCode, null);\n  /* istanbul ignore next */\n  emit('afterexit', process.exitCode, null);\n  /* istanbul ignore next */\n  originalProcessReallyExit.call(process, process.exitCode);\n}\nvar originalProcessEmit = process.emit;\nfunction processEmit(ev, arg) {\n  if (ev === 'exit') {\n    if (arg !== undefined) {\n      process.exitCode = arg;\n    }\n    var ret = originalProcessEmit.apply(this, arguments);\n    emit('exit', process.exitCode, null);\n    /* istanbul ignore next */\n    emit('afterexit', process.exitCode, null);\n    return ret;\n  } else {\n    return originalProcessEmit.apply(this, arguments);\n  }\n}","map":{"version":3,"names":["assert","require","signals","EE","EventEmitter","emitter","process","__signal_exit_emitter__","count","emitted","infinite","setMaxListeners","Infinity","module","exports","cb","opts","equal","loaded","load","ev","alwaysLast","remove","removeListener","listeners","length","unload","on","forEach","sig","sigListeners","er","emit","originalProcessEmit","reallyExit","originalProcessReallyExit","event","code","signal","listener","kill","pid","filter","processEmit","processReallyExit","exitCode","call","arg","undefined","ret","apply","arguments"],"sources":["/Users/hkateliev/node_modules/npm/node_modules/signal-exit/index.js"],"sourcesContent":["// Note: since nyc uses this module to output coverage, any lines\n// that are in the direct sync flow of nyc's outputCoverage are\n// ignored, since we can never get coverage for them.\nvar assert = require('assert')\nvar signals = require('./signals.js')\n\nvar EE = require('events')\n/* istanbul ignore if */\nif (typeof EE !== 'function') {\n  EE = EE.EventEmitter\n}\n\nvar emitter\nif (process.__signal_exit_emitter__) {\n  emitter = process.__signal_exit_emitter__\n} else {\n  emitter = process.__signal_exit_emitter__ = new EE()\n  emitter.count = 0\n  emitter.emitted = {}\n}\n\n// Because this emitter is a global, we have to check to see if a\n// previous version of this library failed to enable infinite listeners.\n// I know what you're about to say.  But literally everything about\n// signal-exit is a compromise with evil.  Get used to it.\nif (!emitter.infinite) {\n  emitter.setMaxListeners(Infinity)\n  emitter.infinite = true\n}\n\nmodule.exports = function (cb, opts) {\n  assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler')\n\n  if (loaded === false) {\n    load()\n  }\n\n  var ev = 'exit'\n  if (opts && opts.alwaysLast) {\n    ev = 'afterexit'\n  }\n\n  var remove = function () {\n    emitter.removeListener(ev, cb)\n    if (emitter.listeners('exit').length === 0 &&\n        emitter.listeners('afterexit').length === 0) {\n      unload()\n    }\n  }\n  emitter.on(ev, cb)\n\n  return remove\n}\n\nmodule.exports.unload = unload\nfunction unload () {\n  if (!loaded) {\n    return\n  }\n  loaded = false\n\n  signals.forEach(function (sig) {\n    try {\n      process.removeListener(sig, sigListeners[sig])\n    } catch (er) {}\n  })\n  process.emit = originalProcessEmit\n  process.reallyExit = originalProcessReallyExit\n  emitter.count -= 1\n}\n\nfunction emit (event, code, signal) {\n  if (emitter.emitted[event]) {\n    return\n  }\n  emitter.emitted[event] = true\n  emitter.emit(event, code, signal)\n}\n\n// { <signal>: <listener fn>, ... }\nvar sigListeners = {}\nsignals.forEach(function (sig) {\n  sigListeners[sig] = function listener () {\n    // If there are no other listeners, an exit is coming!\n    // Simplest way: remove us and then re-send the signal.\n    // We know that this will kill the process, so we can\n    // safely emit now.\n    var listeners = process.listeners(sig)\n    if (listeners.length === emitter.count) {\n      unload()\n      emit('exit', null, sig)\n      /* istanbul ignore next */\n      emit('afterexit', null, sig)\n      /* istanbul ignore next */\n      process.kill(process.pid, sig)\n    }\n  }\n})\n\nmodule.exports.signals = function () {\n  return signals\n}\n\nmodule.exports.load = load\n\nvar loaded = false\n\nfunction load () {\n  if (loaded) {\n    return\n  }\n  loaded = true\n\n  // This is the number of onSignalExit's that are in play.\n  // It's important so that we can count the correct number of\n  // listeners on signals, and don't wait for the other one to\n  // handle it instead of us.\n  emitter.count += 1\n\n  signals = signals.filter(function (sig) {\n    try {\n      process.on(sig, sigListeners[sig])\n      return true\n    } catch (er) {\n      return false\n    }\n  })\n\n  process.emit = processEmit\n  process.reallyExit = processReallyExit\n}\n\nvar originalProcessReallyExit = process.reallyExit\nfunction processReallyExit (code) {\n  process.exitCode = code || 0\n  emit('exit', process.exitCode, null)\n  /* istanbul ignore next */\n  emit('afterexit', process.exitCode, null)\n  /* istanbul ignore next */\n  originalProcessReallyExit.call(process, process.exitCode)\n}\n\nvar originalProcessEmit = process.emit\nfunction processEmit (ev, arg) {\n  if (ev === 'exit') {\n    if (arg !== undefined) {\n      process.exitCode = arg\n    }\n    var ret = originalProcessEmit.apply(this, arguments)\n    emit('exit', process.exitCode, null)\n    /* istanbul ignore next */\n    emit('afterexit', process.exitCode, null)\n    return ret\n  } else {\n    return originalProcessEmit.apply(this, arguments)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}