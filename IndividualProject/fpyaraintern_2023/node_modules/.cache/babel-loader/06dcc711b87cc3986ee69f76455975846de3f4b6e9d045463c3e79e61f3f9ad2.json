{"ast":null,"code":"// Copyright (C) 2011-2015 John Hewson\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\nvar stream = require('stream'),\n  util = require('util'),\n  timers = require('timers');\n\n// convinience API\nmodule.exports = function (readStream, options) {\n  return module.exports.createStream(readStream, options);\n};\n\n// basic API\nmodule.exports.createStream = function (readStream, options) {\n  if (readStream) {\n    return createLineStream(readStream, options);\n  } else {\n    return new LineStream(options);\n  }\n};\n\n// deprecated API\nmodule.exports.createLineStream = function (readStream) {\n  console.log('WARNING: byline#createLineStream is deprecated and will be removed soon');\n  return createLineStream(readStream);\n};\nfunction createLineStream(readStream, options) {\n  if (!readStream) {\n    throw new Error('expected readStream');\n  }\n  if (!readStream.readable) {\n    throw new Error('readStream must be readable');\n  }\n  var ls = new LineStream(options);\n  readStream.pipe(ls);\n  return ls;\n}\n\n//\n// using the new node v0.10 \"streams2\" API\n//\n\nmodule.exports.LineStream = LineStream;\nfunction LineStream(options) {\n  stream.Transform.call(this, options);\n  options = options || {};\n\n  // use objectMode to stop the output from being buffered\n  // which re-concatanates the lines, just without newlines.\n  this._readableState.objectMode = true;\n  this._lineBuffer = [];\n  this._keepEmptyLines = options.keepEmptyLines || false;\n  this._lastChunkEndedWithCR = false;\n\n  // take the source's encoding if we don't have one\n  var self = this;\n  this.on('pipe', function (src) {\n    if (!self.encoding) {\n      // but we can't do this for old-style streams\n      if (src instanceof stream.Readable) {\n        self.encoding = src._readableState.encoding;\n      }\n    }\n  });\n}\nutil.inherits(LineStream, stream.Transform);\nLineStream.prototype._transform = function (chunk, encoding, done) {\n  // decode binary chunks as UTF-8\n  encoding = encoding || 'utf8';\n  if (Buffer.isBuffer(chunk)) {\n    if (encoding == 'buffer') {\n      chunk = chunk.toString(); // utf8\n      encoding = 'utf8';\n    } else {\n      chunk = chunk.toString(encoding);\n    }\n  }\n  this._chunkEncoding = encoding;\n\n  // see: http://www.unicode.org/reports/tr18/#Line_Boundaries\n  var lines = chunk.split(/\\r\\n|[\\n\\v\\f\\r\\x85\\u2028\\u2029]/g);\n\n  // don't split CRLF which spans chunks\n  if (this._lastChunkEndedWithCR && chunk[0] == '\\n') {\n    lines.shift();\n  }\n  if (this._lineBuffer.length > 0) {\n    this._lineBuffer[this._lineBuffer.length - 1] += lines[0];\n    lines.shift();\n  }\n  this._lastChunkEndedWithCR = chunk[chunk.length - 1] == '\\r';\n  this._lineBuffer = this._lineBuffer.concat(lines);\n  this._pushBuffer(encoding, 1, done);\n};\nLineStream.prototype._pushBuffer = function (encoding, keep, done) {\n  // always buffer the last (possibly partial) line\n  while (this._lineBuffer.length > keep) {\n    var line = this._lineBuffer.shift();\n    // skip empty lines\n    if (this._keepEmptyLines || line.length > 0) {\n      if (!this.push(this._reencode(line, encoding))) {\n        // when the high-water mark is reached, defer pushes until the next tick\n        var self = this;\n        timers.setImmediate(function () {\n          self._pushBuffer(encoding, keep, done);\n        });\n        return;\n      }\n    }\n  }\n  done();\n};\nLineStream.prototype._flush = function (done) {\n  this._pushBuffer(this._chunkEncoding, 0, done);\n};\n\n// see Readable::push\nLineStream.prototype._reencode = function (line, chunkEncoding) {\n  if (this.encoding && this.encoding != chunkEncoding) {\n    return new Buffer(line, chunkEncoding).toString(this.encoding);\n  } else if (this.encoding) {\n    // this should be the most common case, i.e. we're using an encoded source stream\n    return line;\n  } else {\n    return new Buffer(line, chunkEncoding);\n  }\n};","map":{"version":3,"names":["stream","require","util","timers","module","exports","readStream","options","createStream","createLineStream","LineStream","console","log","Error","readable","ls","pipe","Transform","call","_readableState","objectMode","_lineBuffer","_keepEmptyLines","keepEmptyLines","_lastChunkEndedWithCR","self","on","src","encoding","Readable","inherits","prototype","_transform","chunk","done","Buffer","isBuffer","toString","_chunkEncoding","lines","split","shift","length","concat","_pushBuffer","keep","line","push","_reencode","setImmediate","_flush","chunkEncoding"],"sources":["/Users/hkateliev/node_modules/npm/node_modules/byline/lib/byline.js"],"sourcesContent":["// Copyright (C) 2011-2015 John Hewson\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\nvar stream = require('stream'),\n    util = require('util'),\n    timers = require('timers');\n\n// convinience API\nmodule.exports = function(readStream, options) {\n  return module.exports.createStream(readStream, options);\n};\n\n// basic API\nmodule.exports.createStream = function(readStream, options) {\n  if (readStream) {\n    return createLineStream(readStream, options);\n  } else {\n    return new LineStream(options);\n  }\n};\n\n// deprecated API\nmodule.exports.createLineStream = function(readStream) {\n  console.log('WARNING: byline#createLineStream is deprecated and will be removed soon');\n  return createLineStream(readStream);\n};\n\nfunction createLineStream(readStream, options) {\n  if (!readStream) {\n    throw new Error('expected readStream');\n  }\n  if (!readStream.readable) {\n    throw new Error('readStream must be readable');\n  }\n  var ls = new LineStream(options);\n  readStream.pipe(ls);\n  return ls;\n}\n\n//\n// using the new node v0.10 \"streams2\" API\n//\n\nmodule.exports.LineStream = LineStream;\n\nfunction LineStream(options) {\n  stream.Transform.call(this, options);\n  options = options || {};\n\n  // use objectMode to stop the output from being buffered\n  // which re-concatanates the lines, just without newlines.\n  this._readableState.objectMode = true;\n  this._lineBuffer = [];\n  this._keepEmptyLines = options.keepEmptyLines || false;\n  this._lastChunkEndedWithCR = false;\n\n  // take the source's encoding if we don't have one\n  var self = this;\n  this.on('pipe', function(src) {\n    if (!self.encoding) {\n      // but we can't do this for old-style streams\n      if (src instanceof stream.Readable) {\n        self.encoding = src._readableState.encoding;\n      }\n    }\n  });\n}\nutil.inherits(LineStream, stream.Transform);\n\nLineStream.prototype._transform = function(chunk, encoding, done) {\n  // decode binary chunks as UTF-8\n  encoding = encoding || 'utf8';\n  \n  if (Buffer.isBuffer(chunk)) {\n    if (encoding == 'buffer') {\n      chunk = chunk.toString(); // utf8\n      encoding = 'utf8';\n    }\n    else {\n     chunk = chunk.toString(encoding);\n    }\n  }\n  this._chunkEncoding = encoding;\n  \n  // see: http://www.unicode.org/reports/tr18/#Line_Boundaries\n  var lines = chunk.split(/\\r\\n|[\\n\\v\\f\\r\\x85\\u2028\\u2029]/g);\n  \n  // don't split CRLF which spans chunks\n  if (this._lastChunkEndedWithCR && chunk[0] == '\\n') {\n    lines.shift();\n  }\n  \n  if (this._lineBuffer.length > 0) {\n    this._lineBuffer[this._lineBuffer.length - 1] += lines[0];\n    lines.shift();\n  }\n\n  this._lastChunkEndedWithCR = chunk[chunk.length - 1] == '\\r';\n  this._lineBuffer = this._lineBuffer.concat(lines);\n  this._pushBuffer(encoding, 1, done);\n};\n\nLineStream.prototype._pushBuffer = function(encoding, keep, done) {\n  // always buffer the last (possibly partial) line\n  while (this._lineBuffer.length > keep) {\n    var line = this._lineBuffer.shift();\n    // skip empty lines\n    if (this._keepEmptyLines || line.length > 0 ) {\n      if (!this.push(this._reencode(line, encoding))) {\n        // when the high-water mark is reached, defer pushes until the next tick\n        var self = this;\n        timers.setImmediate(function() {\n          self._pushBuffer(encoding, keep, done);\n        });\n        return;\n      }\n    }\n  }\n  done();\n};\n\nLineStream.prototype._flush = function(done) {\n  this._pushBuffer(this._chunkEncoding, 0, done);\n};\n\n// see Readable::push\nLineStream.prototype._reencode = function(line, chunkEncoding) {\n  if (this.encoding && this.encoding != chunkEncoding) {\n    return new Buffer(line, chunkEncoding).toString(this.encoding);\n  }\n  else if (this.encoding) {\n    // this should be the most common case, i.e. we're using an encoded source stream\n    return line;\n  }\n  else {\n    return new Buffer(line, chunkEncoding);\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}