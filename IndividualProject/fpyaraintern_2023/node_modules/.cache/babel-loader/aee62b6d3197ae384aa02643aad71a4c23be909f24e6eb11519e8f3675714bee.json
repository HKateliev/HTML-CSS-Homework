{"ast":null,"code":"'use strict';\n\nmodule.exports = writeFile;\nmodule.exports.sync = writeFileSync;\nmodule.exports._getTmpname = getTmpname; // for testing\nmodule.exports._cleanupOnExit = cleanupOnExit;\nvar fs = require('graceful-fs');\nvar MurmurHash3 = require('imurmurhash');\nvar onExit = require('signal-exit');\nvar path = require('path');\nvar activeFiles = {};\n\n// if we run inside of a worker_thread, `process.pid` is not unique\n/* istanbul ignore next */\nvar threadId = function getId() {\n  try {\n    var workerThreads = require('worker_threads');\n\n    /// if we are in main thread, this is set to `0`\n    return workerThreads.threadId;\n  } catch (e) {\n    // worker_threads are not available, fallback to 0\n    return 0;\n  }\n}();\nvar invocations = 0;\nfunction getTmpname(filename) {\n  return filename + '.' + MurmurHash3(__filename).hash(String(process.pid)).hash(String(threadId)).hash(String(++invocations)).result();\n}\nfunction cleanupOnExit(tmpfile) {\n  return function () {\n    try {\n      fs.unlinkSync(typeof tmpfile === 'function' ? tmpfile() : tmpfile);\n    } catch (_) {}\n  };\n}\nfunction writeFile(filename, data, options, callback) {\n  if (options) {\n    if (options instanceof Function) {\n      callback = options;\n      options = {};\n    } else if (typeof options === 'string') {\n      options = {\n        encoding: options\n      };\n    }\n  } else {\n    options = {};\n  }\n  var Promise = options.Promise || global.Promise;\n  var truename;\n  var fd;\n  var tmpfile;\n  /* istanbul ignore next -- The closure only gets called when onExit triggers */\n  var removeOnExitHandler = onExit(cleanupOnExit(() => tmpfile));\n  var absoluteName = path.resolve(filename);\n  new Promise(function serializeSameFile(resolve) {\n    // make a queue if it doesn't already exist\n    if (!activeFiles[absoluteName]) activeFiles[absoluteName] = [];\n    activeFiles[absoluteName].push(resolve); // add this job to the queue\n    if (activeFiles[absoluteName].length === 1) resolve(); // kick off the first one\n  }).then(function getRealPath() {\n    return new Promise(function (resolve) {\n      fs.realpath(filename, function (_, realname) {\n        truename = realname || filename;\n        tmpfile = getTmpname(truename);\n        resolve();\n      });\n    });\n  }).then(function stat() {\n    return new Promise(function stat(resolve) {\n      if (options.mode && options.chown) resolve();else {\n        // Either mode or chown is not explicitly set\n        // Default behavior is to copy it from original file\n        fs.stat(truename, function (err, stats) {\n          if (err || !stats) resolve();else {\n            options = Object.assign({}, options);\n            if (options.mode == null) {\n              options.mode = stats.mode;\n            }\n            if (options.chown == null && process.getuid) {\n              options.chown = {\n                uid: stats.uid,\n                gid: stats.gid\n              };\n            }\n            resolve();\n          }\n        });\n      }\n    });\n  }).then(function thenWriteFile() {\n    return new Promise(function (resolve, reject) {\n      fs.open(tmpfile, 'w', options.mode, function (err, _fd) {\n        fd = _fd;\n        if (err) reject(err);else resolve();\n      });\n    });\n  }).then(function write() {\n    return new Promise(function (resolve, reject) {\n      if (Buffer.isBuffer(data)) {\n        fs.write(fd, data, 0, data.length, 0, function (err) {\n          if (err) reject(err);else resolve();\n        });\n      } else if (data != null) {\n        fs.write(fd, String(data), 0, String(options.encoding || 'utf8'), function (err) {\n          if (err) reject(err);else resolve();\n        });\n      } else resolve();\n    });\n  }).then(function syncAndClose() {\n    return new Promise(function (resolve, reject) {\n      if (options.fsync !== false) {\n        fs.fsync(fd, function (err) {\n          if (err) fs.close(fd, () => reject(err));else fs.close(fd, resolve);\n        });\n      } else {\n        fs.close(fd, resolve);\n      }\n    });\n  }).then(function chown() {\n    fd = null;\n    if (options.chown) {\n      return new Promise(function (resolve, reject) {\n        fs.chown(tmpfile, options.chown.uid, options.chown.gid, function (err) {\n          if (err) reject(err);else resolve();\n        });\n      });\n    }\n  }).then(function chmod() {\n    if (options.mode) {\n      return new Promise(function (resolve, reject) {\n        fs.chmod(tmpfile, options.mode, function (err) {\n          if (err) reject(err);else resolve();\n        });\n      });\n    }\n  }).then(function rename() {\n    return new Promise(function (resolve, reject) {\n      fs.rename(tmpfile, truename, function (err) {\n        if (err) reject(err);else resolve();\n      });\n    });\n  }).then(function success() {\n    removeOnExitHandler();\n    callback();\n  }, function fail(err) {\n    return new Promise(resolve => {\n      return fd ? fs.close(fd, resolve) : resolve();\n    }).then(() => {\n      removeOnExitHandler();\n      fs.unlink(tmpfile, function () {\n        callback(err);\n      });\n    });\n  }).then(function checkQueue() {\n    activeFiles[absoluteName].shift(); // remove the element added by serializeSameFile\n    if (activeFiles[absoluteName].length > 0) {\n      activeFiles[absoluteName][0](); // start next job if one is pending\n    } else delete activeFiles[absoluteName];\n  });\n}\nfunction writeFileSync(filename, data, options) {\n  if (typeof options === 'string') options = {\n    encoding: options\n  };else if (!options) options = {};\n  try {\n    filename = fs.realpathSync(filename);\n  } catch (ex) {\n    // it's ok, it'll happen on a not yet existing file\n  }\n  var tmpfile = getTmpname(filename);\n  if (!options.mode || !options.chown) {\n    // Either mode or chown is not explicitly set\n    // Default behavior is to copy it from original file\n    try {\n      var stats = fs.statSync(filename);\n      options = Object.assign({}, options);\n      if (!options.mode) {\n        options.mode = stats.mode;\n      }\n      if (!options.chown && process.getuid) {\n        options.chown = {\n          uid: stats.uid,\n          gid: stats.gid\n        };\n      }\n    } catch (ex) {\n      // ignore stat errors\n    }\n  }\n  var fd;\n  var cleanup = cleanupOnExit(tmpfile);\n  var removeOnExitHandler = onExit(cleanup);\n  try {\n    fd = fs.openSync(tmpfile, 'w', options.mode);\n    if (Buffer.isBuffer(data)) {\n      fs.writeSync(fd, data, 0, data.length, 0);\n    } else if (data != null) {\n      fs.writeSync(fd, String(data), 0, String(options.encoding || 'utf8'));\n    }\n    if (options.fsync !== false) {\n      fs.fsyncSync(fd);\n    }\n    fs.closeSync(fd);\n    if (options.chown) fs.chownSync(tmpfile, options.chown.uid, options.chown.gid);\n    if (options.mode) fs.chmodSync(tmpfile, options.mode);\n    fs.renameSync(tmpfile, filename);\n    removeOnExitHandler();\n  } catch (err) {\n    if (fd) {\n      try {\n        fs.closeSync(fd);\n      } catch (ex) {\n        // ignore close errors at this stage, error may have closed fd already.\n      }\n    }\n    removeOnExitHandler();\n    cleanup();\n    throw err;\n  }\n}","map":{"version":3,"names":["module","exports","writeFile","sync","writeFileSync","_getTmpname","getTmpname","_cleanupOnExit","cleanupOnExit","fs","require","MurmurHash3","onExit","path","activeFiles","threadId","getId","workerThreads","e","invocations","filename","__filename","hash","String","process","pid","result","tmpfile","unlinkSync","_","data","options","callback","Function","encoding","Promise","global","truename","fd","removeOnExitHandler","absoluteName","resolve","serializeSameFile","push","length","then","getRealPath","realpath","realname","stat","mode","chown","err","stats","Object","assign","getuid","uid","gid","thenWriteFile","reject","open","_fd","write","Buffer","isBuffer","syncAndClose","fsync","close","chmod","rename","success","fail","unlink","checkQueue","shift","realpathSync","ex","statSync","cleanup","openSync","writeSync","fsyncSync","closeSync","chownSync","chmodSync","renameSync"],"sources":["/Users/hkateliev/node_modules/npm/node_modules/write-file-atomic/index.js"],"sourcesContent":["'use strict'\nmodule.exports = writeFile\nmodule.exports.sync = writeFileSync\nmodule.exports._getTmpname = getTmpname // for testing\nmodule.exports._cleanupOnExit = cleanupOnExit\n\nvar fs = require('graceful-fs')\nvar MurmurHash3 = require('imurmurhash')\nvar onExit = require('signal-exit')\nvar path = require('path')\nvar activeFiles = {}\n\n// if we run inside of a worker_thread, `process.pid` is not unique\n/* istanbul ignore next */\nvar threadId = (function getId () {\n  try {\n    var workerThreads = require('worker_threads')\n\n    /// if we are in main thread, this is set to `0`\n    return workerThreads.threadId\n  } catch (e) {\n    // worker_threads are not available, fallback to 0\n    return 0\n  }\n})()\n\nvar invocations = 0\nfunction getTmpname (filename) {\n  return filename + '.' +\n    MurmurHash3(__filename)\n      .hash(String(process.pid))\n      .hash(String(threadId))\n      .hash(String(++invocations))\n      .result()\n}\n\nfunction cleanupOnExit (tmpfile) {\n  return function () {\n    try {\n      fs.unlinkSync(typeof tmpfile === 'function' ? tmpfile() : tmpfile)\n    } catch (_) {}\n  }\n}\n\nfunction writeFile (filename, data, options, callback) {\n  if (options) {\n    if (options instanceof Function) {\n      callback = options\n      options = {}\n    } else if (typeof options === 'string') {\n      options = { encoding: options }\n    }\n  } else {\n    options = {}\n  }\n\n  var Promise = options.Promise || global.Promise\n  var truename\n  var fd\n  var tmpfile\n  /* istanbul ignore next -- The closure only gets called when onExit triggers */\n  var removeOnExitHandler = onExit(cleanupOnExit(() => tmpfile))\n  var absoluteName = path.resolve(filename)\n\n  new Promise(function serializeSameFile (resolve) {\n    // make a queue if it doesn't already exist\n    if (!activeFiles[absoluteName]) activeFiles[absoluteName] = []\n\n    activeFiles[absoluteName].push(resolve) // add this job to the queue\n    if (activeFiles[absoluteName].length === 1) resolve() // kick off the first one\n  }).then(function getRealPath () {\n    return new Promise(function (resolve) {\n      fs.realpath(filename, function (_, realname) {\n        truename = realname || filename\n        tmpfile = getTmpname(truename)\n        resolve()\n      })\n    })\n  }).then(function stat () {\n    return new Promise(function stat (resolve) {\n      if (options.mode && options.chown) resolve()\n      else {\n        // Either mode or chown is not explicitly set\n        // Default behavior is to copy it from original file\n        fs.stat(truename, function (err, stats) {\n          if (err || !stats) resolve()\n          else {\n            options = Object.assign({}, options)\n\n            if (options.mode == null) {\n              options.mode = stats.mode\n            }\n            if (options.chown == null && process.getuid) {\n              options.chown = { uid: stats.uid, gid: stats.gid }\n            }\n            resolve()\n          }\n        })\n      }\n    })\n  }).then(function thenWriteFile () {\n    return new Promise(function (resolve, reject) {\n      fs.open(tmpfile, 'w', options.mode, function (err, _fd) {\n        fd = _fd\n        if (err) reject(err)\n        else resolve()\n      })\n    })\n  }).then(function write () {\n    return new Promise(function (resolve, reject) {\n      if (Buffer.isBuffer(data)) {\n        fs.write(fd, data, 0, data.length, 0, function (err) {\n          if (err) reject(err)\n          else resolve()\n        })\n      } else if (data != null) {\n        fs.write(fd, String(data), 0, String(options.encoding || 'utf8'), function (err) {\n          if (err) reject(err)\n          else resolve()\n        })\n      } else resolve()\n    })\n  }).then(function syncAndClose () {\n    return new Promise(function (resolve, reject) {\n      if (options.fsync !== false) {\n        fs.fsync(fd, function (err) {\n          if (err) fs.close(fd, () => reject(err))\n          else fs.close(fd, resolve)\n        })\n      } else {\n        fs.close(fd, resolve)\n      }\n    })\n  }).then(function chown () {\n    fd = null\n    if (options.chown) {\n      return new Promise(function (resolve, reject) {\n        fs.chown(tmpfile, options.chown.uid, options.chown.gid, function (err) {\n          if (err) reject(err)\n          else resolve()\n        })\n      })\n    }\n  }).then(function chmod () {\n    if (options.mode) {\n      return new Promise(function (resolve, reject) {\n        fs.chmod(tmpfile, options.mode, function (err) {\n          if (err) reject(err)\n          else resolve()\n        })\n      })\n    }\n  }).then(function rename () {\n    return new Promise(function (resolve, reject) {\n      fs.rename(tmpfile, truename, function (err) {\n        if (err) reject(err)\n        else resolve()\n      })\n    })\n  }).then(function success () {\n    removeOnExitHandler()\n    callback()\n  }, function fail (err) {\n    return new Promise(resolve => {\n      return fd ? fs.close(fd, resolve) : resolve()\n    }).then(() => {\n      removeOnExitHandler()\n      fs.unlink(tmpfile, function () {\n        callback(err)\n      })\n    })\n  }).then(function checkQueue () {\n    activeFiles[absoluteName].shift() // remove the element added by serializeSameFile\n    if (activeFiles[absoluteName].length > 0) {\n      activeFiles[absoluteName][0]() // start next job if one is pending\n    } else delete activeFiles[absoluteName]\n  })\n}\n\nfunction writeFileSync (filename, data, options) {\n  if (typeof options === 'string') options = { encoding: options }\n  else if (!options) options = {}\n  try {\n    filename = fs.realpathSync(filename)\n  } catch (ex) {\n    // it's ok, it'll happen on a not yet existing file\n  }\n  var tmpfile = getTmpname(filename)\n\n  if (!options.mode || !options.chown) {\n    // Either mode or chown is not explicitly set\n    // Default behavior is to copy it from original file\n    try {\n      var stats = fs.statSync(filename)\n      options = Object.assign({}, options)\n      if (!options.mode) {\n        options.mode = stats.mode\n      }\n      if (!options.chown && process.getuid) {\n        options.chown = { uid: stats.uid, gid: stats.gid }\n      }\n    } catch (ex) {\n      // ignore stat errors\n    }\n  }\n\n  var fd\n  var cleanup = cleanupOnExit(tmpfile)\n  var removeOnExitHandler = onExit(cleanup)\n\n  try {\n    fd = fs.openSync(tmpfile, 'w', options.mode)\n    if (Buffer.isBuffer(data)) {\n      fs.writeSync(fd, data, 0, data.length, 0)\n    } else if (data != null) {\n      fs.writeSync(fd, String(data), 0, String(options.encoding || 'utf8'))\n    }\n    if (options.fsync !== false) {\n      fs.fsyncSync(fd)\n    }\n    fs.closeSync(fd)\n    if (options.chown) fs.chownSync(tmpfile, options.chown.uid, options.chown.gid)\n    if (options.mode) fs.chmodSync(tmpfile, options.mode)\n    fs.renameSync(tmpfile, filename)\n    removeOnExitHandler()\n  } catch (err) {\n    if (fd) {\n      try {\n        fs.closeSync(fd)\n      } catch (ex) {\n        // ignore close errors at this stage, error may have closed fd already.\n      }\n    }\n    removeOnExitHandler()\n    cleanup()\n    throw err\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}