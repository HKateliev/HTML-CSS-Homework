{"ast":null,"code":"'use strict';\n\n/**\n * body.js\n *\n * Body interface provides common methods for Request and Response\n */\nconst Buffer = require('safe-buffer').Buffer;\nconst Blob = require('./blob.js');\nconst BUFFER = Blob.BUFFER;\nconst convert = require('encoding').convert;\nconst parseJson = require('json-parse-better-errors');\nconst FetchError = require('./fetch-error.js');\nconst Stream = require('stream');\nconst PassThrough = Stream.PassThrough;\nconst DISTURBED = Symbol('disturbed');\n\n/**\n * Body class\n *\n * Cannot use ES6 class because Body must be called with .call().\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nexports = module.exports = Body;\nfunction Body(body, opts) {\n  if (!opts) opts = {};\n  const size = opts.size == null ? 0 : opts.size;\n  const timeout = opts.timeout == null ? 0 : opts.timeout;\n  if (body == null) {\n    // body is undefined or null\n    body = null;\n  } else if (typeof body === 'string') {\n    // body is string\n  } else if (body instanceof Blob) {\n    // body is blob\n  } else if (Buffer.isBuffer(body)) {\n    // body is buffer\n  } else if (body instanceof Stream) {\n    // body is stream\n  } else {\n    // none of the above\n    // coerce to string\n    body = String(body);\n  }\n  this.body = body;\n  this[DISTURBED] = false;\n  this.size = size;\n  this.timeout = timeout;\n}\nBody.prototype = {\n  get bodyUsed() {\n    return this[DISTURBED];\n  },\n  /**\n   * Decode response as ArrayBuffer\n   *\n   * @return  Promise\n   */\n  arrayBuffer() {\n    return consumeBody.call(this).then(buf => buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength));\n  },\n  /**\n   * Return raw response as Blob\n   *\n   * @return Promise\n   */\n  blob() {\n    let ct = this.headers && this.headers.get('content-type') || '';\n    return consumeBody.call(this).then(buf => Object.assign(\n    // Prevent copying\n    new Blob([], {\n      type: ct.toLowerCase()\n    }), {\n      [BUFFER]: buf\n    }));\n  },\n  /**\n   * Decode response as json\n   *\n   * @return  Promise\n   */\n  json() {\n    return consumeBody.call(this).then(buffer => parseJson(buffer.toString()));\n  },\n  /**\n   * Decode response as text\n   *\n   * @return  Promise\n   */\n  text() {\n    return consumeBody.call(this).then(buffer => buffer.toString());\n  },\n  /**\n   * Decode response as buffer (non-spec api)\n   *\n   * @return  Promise\n   */\n  buffer() {\n    return consumeBody.call(this);\n  },\n  /**\n   * Decode response as text, while automatically detecting the encoding and\n   * trying to decode to UTF-8 (non-spec api)\n   *\n   * @return  Promise\n   */\n  textConverted() {\n    return consumeBody.call(this).then(buffer => convertBody(buffer, this.headers));\n  }\n};\nBody.mixIn = function (proto) {\n  for (const name of Object.getOwnPropertyNames(Body.prototype)) {\n    // istanbul ignore else: future proof\n    if (!(name in proto)) {\n      const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);\n      Object.defineProperty(proto, name, desc);\n    }\n  }\n};\n\n/**\n * Decode buffers into utf-8 string\n *\n * @return  Promise\n */\nfunction consumeBody(body) {\n  if (this[DISTURBED]) {\n    return Body.Promise.reject(new Error(`body used already for: ${this.url}`));\n  }\n  this[DISTURBED] = true;\n\n  // body is null\n  if (this.body === null) {\n    return Body.Promise.resolve(Buffer.alloc(0));\n  }\n\n  // body is string\n  if (typeof this.body === 'string') {\n    return Body.Promise.resolve(Buffer.from(this.body));\n  }\n\n  // body is blob\n  if (this.body instanceof Blob) {\n    return Body.Promise.resolve(this.body[BUFFER]);\n  }\n\n  // body is buffer\n  if (Buffer.isBuffer(this.body)) {\n    return Body.Promise.resolve(this.body);\n  }\n\n  // istanbul ignore if: should never happen\n  if (!(this.body instanceof Stream)) {\n    return Body.Promise.resolve(Buffer.alloc(0));\n  }\n\n  // body is stream\n  // get ready to actually consume the body\n  let accum = [];\n  let accumBytes = 0;\n  let abort = false;\n  return new Body.Promise((resolve, reject) => {\n    let resTimeout;\n\n    // allow timeout on slow response body\n    if (this.timeout) {\n      resTimeout = setTimeout(() => {\n        abort = true;\n        reject(new FetchError(`Response timeout while trying to fetch ${this.url} (over ${this.timeout}ms)`, 'body-timeout'));\n      }, this.timeout);\n    }\n\n    // handle stream error, such as incorrect content-encoding\n    this.body.on('error', err => {\n      reject(new FetchError(`Invalid response body while trying to fetch ${this.url}: ${err.message}`, 'system', err));\n    });\n    this.body.on('data', chunk => {\n      if (abort || chunk === null) {\n        return;\n      }\n      if (this.size && accumBytes + chunk.length > this.size) {\n        abort = true;\n        reject(new FetchError(`content size at ${this.url} over limit: ${this.size}`, 'max-size'));\n        return;\n      }\n      accumBytes += chunk.length;\n      accum.push(chunk);\n    });\n    this.body.on('end', () => {\n      if (abort) {\n        return;\n      }\n      clearTimeout(resTimeout);\n      resolve(Buffer.concat(accum));\n    });\n  });\n}\n\n/**\n * Detect buffer encoding and convert to target encoding\n * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding\n *\n * @param   Buffer  buffer    Incoming buffer\n * @param   String  encoding  Target encoding\n * @return  String\n */\nfunction convertBody(buffer, headers) {\n  const ct = headers.get('content-type');\n  let charset = 'utf-8';\n  let res, str;\n\n  // header\n  if (ct) {\n    res = /charset=([^;]*)/i.exec(ct);\n  }\n\n  // no charset in content type, peek at response body for at most 1024 bytes\n  str = buffer.slice(0, 1024).toString();\n\n  // html5\n  if (!res && str) {\n    res = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n  }\n\n  // html4\n  if (!res && str) {\n    res = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n    if (res) {\n      res = /charset=(.*)/i.exec(res.pop());\n    }\n  }\n\n  // xml\n  if (!res && str) {\n    res = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n  }\n\n  // found charset\n  if (res) {\n    charset = res.pop();\n\n    // prevent decode issues when sites use incorrect encoding\n    // ref: https://hsivonen.fi/encoding-menu/\n    if (charset === 'gb2312' || charset === 'gbk') {\n      charset = 'gb18030';\n    }\n  }\n\n  // turn raw buffers into a single utf-8 buffer\n  return convert(buffer, 'UTF-8', charset).toString();\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed  instance  Response or Request instance\n * @return  Mixed\n */\nexports.clone = function clone(instance) {\n  let p1, p2;\n  let body = instance.body;\n\n  // don't allow cloning a used body\n  if (instance.bodyUsed) {\n    throw new Error('cannot clone body after it is used');\n  }\n\n  // check that body is a stream and not form-data object\n  // note: we can't clone the form-data object without having it as a dependency\n  if (body instanceof Stream && typeof body.getBoundary !== 'function') {\n    // tee instance body\n    p1 = new PassThrough();\n    p2 = new PassThrough();\n    body.pipe(p1);\n    body.pipe(p2);\n    // set instance body to teed body and return the other teed body\n    instance.body = p1;\n    body = p2;\n  }\n  return body;\n};\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present and non-null.\n *\n * @param   Mixed  instance  Response or Request instance\n */\nexports.extractContentType = function extractContentType(instance) {\n  const body = instance.body;\n\n  // istanbul ignore if: Currently, because of a guard in Request, body\n  // can never be null. Included here for completeness.\n  if (body === null) {\n    // body is null\n    return null;\n  } else if (typeof body === 'string') {\n    // body is string\n    return 'text/plain;charset=UTF-8';\n  } else if (body instanceof Blob) {\n    // body is blob\n    return body.type || null;\n  } else if (Buffer.isBuffer(body)) {\n    // body is buffer\n    return null;\n  } else if (typeof body.getBoundary === 'function') {\n    // detect form data input from form-data module\n    return `multipart/form-data;boundary=${body.getBoundary()}`;\n  } else {\n    // body is stream\n    // can't really do much about this\n    return null;\n  }\n};\nexports.getTotalBytes = function getTotalBytes(instance) {\n  const body = instance.body;\n\n  // istanbul ignore if: included for completion\n  if (body === null) {\n    // body is null\n    return 0;\n  } else if (typeof body === 'string') {\n    // body is string\n    return Buffer.byteLength(body);\n  } else if (body instanceof Blob) {\n    // body is blob\n    return body.size;\n  } else if (Buffer.isBuffer(body)) {\n    // body is buffer\n    return body.length;\n  } else if (body && typeof body.getLengthSync === 'function') {\n    // detect form data input from form-data module\n    if (\n    // 1.x\n    body._lengthRetrievers && body._lengthRetrievers.length === 0 ||\n    // 2.x\n    body.hasKnownLength && body.hasKnownLength()) {\n      return body.getLengthSync();\n    }\n    return null;\n  } else {\n    // body is stream\n    // can't really do much about this\n    return null;\n  }\n};\nexports.writeToStream = function writeToStream(dest, instance) {\n  const body = instance.body;\n  if (body === null) {\n    // body is null\n    dest.end();\n  } else if (typeof body === 'string') {\n    // body is string\n    dest.write(body);\n    dest.end();\n  } else if (body instanceof Blob) {\n    // body is blob\n    dest.write(body[BUFFER]);\n    dest.end();\n  } else if (Buffer.isBuffer(body)) {\n    // body is buffer\n    dest.write(body);\n    dest.end();\n  } else {\n    // body is stream\n    body.pipe(dest);\n  }\n};\n\n// expose Promise\nBody.Promise = global.Promise;","map":{"version":3,"names":["Buffer","require","Blob","BUFFER","convert","parseJson","FetchError","Stream","PassThrough","DISTURBED","Symbol","exports","module","Body","body","opts","size","timeout","isBuffer","String","prototype","bodyUsed","arrayBuffer","consumeBody","call","then","buf","buffer","slice","byteOffset","byteLength","blob","ct","headers","get","Object","assign","type","toLowerCase","json","toString","text","textConverted","convertBody","mixIn","proto","name","getOwnPropertyNames","desc","getOwnPropertyDescriptor","defineProperty","Promise","reject","Error","url","resolve","alloc","from","accum","accumBytes","abort","resTimeout","setTimeout","on","err","message","chunk","length","push","clearTimeout","concat","charset","res","str","exec","pop","clone","instance","p1","p2","getBoundary","pipe","extractContentType","getTotalBytes","getLengthSync","_lengthRetrievers","hasKnownLength","writeToStream","dest","end","write","global"],"sources":["/Users/hkateliev/node_modules/npm/node_modules/node-fetch-npm/src/body.js"],"sourcesContent":["'use strict'\n\n/**\n * body.js\n *\n * Body interface provides common methods for Request and Response\n */\n\nconst Buffer = require('safe-buffer').Buffer\n\nconst Blob = require('./blob.js')\nconst BUFFER = Blob.BUFFER\nconst convert = require('encoding').convert\nconst parseJson = require('json-parse-better-errors')\nconst FetchError = require('./fetch-error.js')\nconst Stream = require('stream')\n\nconst PassThrough = Stream.PassThrough\nconst DISTURBED = Symbol('disturbed')\n\n/**\n * Body class\n *\n * Cannot use ES6 class because Body must be called with .call().\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nexports = module.exports = Body\n\nfunction Body (body, opts) {\n  if (!opts) opts = {}\n  const size = opts.size == null ? 0 : opts.size\n  const timeout = opts.timeout == null ? 0 : opts.timeout\n  if (body == null) {\n    // body is undefined or null\n    body = null\n  } else if (typeof body === 'string') {\n    // body is string\n  } else if (body instanceof Blob) {\n    // body is blob\n  } else if (Buffer.isBuffer(body)) {\n    // body is buffer\n  } else if (body instanceof Stream) {\n    // body is stream\n  } else {\n    // none of the above\n    // coerce to string\n    body = String(body)\n  }\n  this.body = body\n  this[DISTURBED] = false\n  this.size = size\n  this.timeout = timeout\n}\n\nBody.prototype = {\n  get bodyUsed () {\n    return this[DISTURBED]\n  },\n\n  /**\n   * Decode response as ArrayBuffer\n   *\n   * @return  Promise\n   */\n  arrayBuffer () {\n    return consumeBody.call(this).then(buf => buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength))\n  },\n\n  /**\n   * Return raw response as Blob\n   *\n   * @return Promise\n   */\n  blob () {\n    let ct = (this.headers && this.headers.get('content-type')) || ''\n    return consumeBody.call(this).then(buf => Object.assign(\n      // Prevent copying\n      new Blob([], {\n        type: ct.toLowerCase()\n      }),\n      {\n        [BUFFER]: buf\n      }\n    ))\n  },\n\n  /**\n   * Decode response as json\n   *\n   * @return  Promise\n   */\n  json () {\n    return consumeBody.call(this).then(buffer => parseJson(buffer.toString()))\n  },\n\n  /**\n   * Decode response as text\n   *\n   * @return  Promise\n   */\n  text () {\n    return consumeBody.call(this).then(buffer => buffer.toString())\n  },\n\n  /**\n   * Decode response as buffer (non-spec api)\n   *\n   * @return  Promise\n   */\n  buffer () {\n    return consumeBody.call(this)\n  },\n\n  /**\n   * Decode response as text, while automatically detecting the encoding and\n   * trying to decode to UTF-8 (non-spec api)\n   *\n   * @return  Promise\n   */\n  textConverted () {\n    return consumeBody.call(this).then(buffer => convertBody(buffer, this.headers))\n  }\n\n}\n\nBody.mixIn = function (proto) {\n  for (const name of Object.getOwnPropertyNames(Body.prototype)) {\n    // istanbul ignore else: future proof\n    if (!(name in proto)) {\n      const desc = Object.getOwnPropertyDescriptor(Body.prototype, name)\n      Object.defineProperty(proto, name, desc)\n    }\n  }\n}\n\n/**\n * Decode buffers into utf-8 string\n *\n * @return  Promise\n */\nfunction consumeBody (body) {\n  if (this[DISTURBED]) {\n    return Body.Promise.reject(new Error(`body used already for: ${this.url}`))\n  }\n\n  this[DISTURBED] = true\n\n  // body is null\n  if (this.body === null) {\n    return Body.Promise.resolve(Buffer.alloc(0))\n  }\n\n  // body is string\n  if (typeof this.body === 'string') {\n    return Body.Promise.resolve(Buffer.from(this.body))\n  }\n\n  // body is blob\n  if (this.body instanceof Blob) {\n    return Body.Promise.resolve(this.body[BUFFER])\n  }\n\n  // body is buffer\n  if (Buffer.isBuffer(this.body)) {\n    return Body.Promise.resolve(this.body)\n  }\n\n  // istanbul ignore if: should never happen\n  if (!(this.body instanceof Stream)) {\n    return Body.Promise.resolve(Buffer.alloc(0))\n  }\n\n  // body is stream\n  // get ready to actually consume the body\n  let accum = []\n  let accumBytes = 0\n  let abort = false\n\n  return new Body.Promise((resolve, reject) => {\n    let resTimeout\n\n    // allow timeout on slow response body\n    if (this.timeout) {\n      resTimeout = setTimeout(() => {\n        abort = true\n        reject(new FetchError(`Response timeout while trying to fetch ${this.url} (over ${this.timeout}ms)`, 'body-timeout'))\n      }, this.timeout)\n    }\n\n    // handle stream error, such as incorrect content-encoding\n    this.body.on('error', err => {\n      reject(new FetchError(`Invalid response body while trying to fetch ${this.url}: ${err.message}`, 'system', err))\n    })\n\n    this.body.on('data', chunk => {\n      if (abort || chunk === null) {\n        return\n      }\n\n      if (this.size && accumBytes + chunk.length > this.size) {\n        abort = true\n        reject(new FetchError(`content size at ${this.url} over limit: ${this.size}`, 'max-size'))\n        return\n      }\n\n      accumBytes += chunk.length\n      accum.push(chunk)\n    })\n\n    this.body.on('end', () => {\n      if (abort) {\n        return\n      }\n\n      clearTimeout(resTimeout)\n      resolve(Buffer.concat(accum))\n    })\n  })\n}\n\n/**\n * Detect buffer encoding and convert to target encoding\n * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding\n *\n * @param   Buffer  buffer    Incoming buffer\n * @param   String  encoding  Target encoding\n * @return  String\n */\nfunction convertBody (buffer, headers) {\n  const ct = headers.get('content-type')\n  let charset = 'utf-8'\n  let res, str\n\n  // header\n  if (ct) {\n    res = /charset=([^;]*)/i.exec(ct)\n  }\n\n  // no charset in content type, peek at response body for at most 1024 bytes\n  str = buffer.slice(0, 1024).toString()\n\n  // html5\n  if (!res && str) {\n    res = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str)\n  }\n\n  // html4\n  if (!res && str) {\n    res = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str)\n\n    if (res) {\n      res = /charset=(.*)/i.exec(res.pop())\n    }\n  }\n\n  // xml\n  if (!res && str) {\n    res = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str)\n  }\n\n  // found charset\n  if (res) {\n    charset = res.pop()\n\n    // prevent decode issues when sites use incorrect encoding\n    // ref: https://hsivonen.fi/encoding-menu/\n    if (charset === 'gb2312' || charset === 'gbk') {\n      charset = 'gb18030'\n    }\n  }\n\n  // turn raw buffers into a single utf-8 buffer\n  return convert(\n    buffer\n    , 'UTF-8'\n    , charset\n  ).toString()\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed  instance  Response or Request instance\n * @return  Mixed\n */\nexports.clone = function clone (instance) {\n  let p1, p2\n  let body = instance.body\n\n  // don't allow cloning a used body\n  if (instance.bodyUsed) {\n    throw new Error('cannot clone body after it is used')\n  }\n\n  // check that body is a stream and not form-data object\n  // note: we can't clone the form-data object without having it as a dependency\n  if ((body instanceof Stream) && (typeof body.getBoundary !== 'function')) {\n    // tee instance body\n    p1 = new PassThrough()\n    p2 = new PassThrough()\n    body.pipe(p1)\n    body.pipe(p2)\n    // set instance body to teed body and return the other teed body\n    instance.body = p1\n    body = p2\n  }\n\n  return body\n}\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present and non-null.\n *\n * @param   Mixed  instance  Response or Request instance\n */\nexports.extractContentType = function extractContentType (instance) {\n  const body = instance.body\n\n  // istanbul ignore if: Currently, because of a guard in Request, body\n  // can never be null. Included here for completeness.\n  if (body === null) {\n    // body is null\n    return null\n  } else if (typeof body === 'string') {\n    // body is string\n    return 'text/plain;charset=UTF-8'\n  } else if (body instanceof Blob) {\n    // body is blob\n    return body.type || null\n  } else if (Buffer.isBuffer(body)) {\n    // body is buffer\n    return null\n  } else if (typeof body.getBoundary === 'function') {\n    // detect form data input from form-data module\n    return `multipart/form-data;boundary=${body.getBoundary()}`\n  } else {\n    // body is stream\n    // can't really do much about this\n    return null\n  }\n}\n\nexports.getTotalBytes = function getTotalBytes (instance) {\n  const body = instance.body\n\n  // istanbul ignore if: included for completion\n  if (body === null) {\n    // body is null\n    return 0\n  } else if (typeof body === 'string') {\n    // body is string\n    return Buffer.byteLength(body)\n  } else if (body instanceof Blob) {\n    // body is blob\n    return body.size\n  } else if (Buffer.isBuffer(body)) {\n    // body is buffer\n    return body.length\n  } else if (body && typeof body.getLengthSync === 'function') {\n    // detect form data input from form-data module\n    if ((\n      // 1.x\n      body._lengthRetrievers &&\n      body._lengthRetrievers.length === 0\n    ) || (\n      // 2.x\n      body.hasKnownLength && body.hasKnownLength()\n    )) {\n      return body.getLengthSync()\n    }\n    return null\n  } else {\n    // body is stream\n    // can't really do much about this\n    return null\n  }\n}\n\nexports.writeToStream = function writeToStream (dest, instance) {\n  const body = instance.body\n\n  if (body === null) {\n    // body is null\n    dest.end()\n  } else if (typeof body === 'string') {\n    // body is string\n    dest.write(body)\n    dest.end()\n  } else if (body instanceof Blob) {\n    // body is blob\n    dest.write(body[BUFFER])\n    dest.end()\n  } else if (Buffer.isBuffer(body)) {\n    // body is buffer\n    dest.write(body)\n    dest.end()\n  } else {\n    // body is stream\n    body.pipe(dest)\n  }\n}\n\n// expose Promise\nBody.Promise = global.Promise\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}