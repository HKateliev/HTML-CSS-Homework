{"ast":null,"code":"'use strict';\n\n/**\n * A set of utilities borrowed from Node.js' _http_common.js\n */\n\n/**\n * Verifies that the given val is a valid HTTP token\n * per the rules defined in RFC 7230\n * See https://tools.ietf.org/html/rfc7230#section-3.2.6\n *\n * Allowed characters in an HTTP token:\n * ^_`a-z  94-122\n * A-Z     65-90\n * -       45\n * 0-9     48-57\n * !       33\n * #$%&'   35-39\n * *+      42-43\n * .       46\n * |       124\n * ~       126\n *\n * This implementation of checkIsHttpToken() loops over the string instead of\n * using a regular expression since the former is up to 180% faster with v8 4.9\n * depending on the string length (the shorter the string, the larger the\n * performance difference)\n *\n * Additionally, checkIsHttpToken() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/\n/* istanbul ignore next */\nfunction isValidTokenChar(ch) {\n  if (ch >= 94 && ch <= 122) {\n    return true;\n  }\n  if (ch >= 65 && ch <= 90) {\n    return true;\n  }\n  if (ch === 45) {\n    return true;\n  }\n  if (ch >= 48 && ch <= 57) {\n    return true;\n  }\n  if (ch === 34 || ch === 40 || ch === 41 || ch === 44) {\n    return false;\n  }\n  if (ch >= 33 && ch <= 46) {\n    return true;\n  }\n  if (ch === 124 || ch === 126) {\n    return true;\n  }\n  return false;\n}\n/* istanbul ignore next */\nfunction checkIsHttpToken(val) {\n  if (typeof val !== 'string' || val.length === 0) {\n    return false;\n  }\n  if (!isValidTokenChar(val.charCodeAt(0))) {\n    return false;\n  }\n  const len = val.length;\n  if (len > 1) {\n    if (!isValidTokenChar(val.charCodeAt(1))) {\n      return false;\n    }\n    if (len > 2) {\n      if (!isValidTokenChar(val.charCodeAt(2))) {\n        return false;\n      }\n      if (len > 3) {\n        if (!isValidTokenChar(val.charCodeAt(3))) {\n          return false;\n        }\n        for (var i = 4; i < len; i++) {\n          if (!isValidTokenChar(val.charCodeAt(i))) {\n            return false;\n          }\n        }\n      }\n    }\n  }\n  return true;\n}\nexports.checkIsHttpToken = checkIsHttpToken;\n\n/**\n * True if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n *\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/\n/* istanbul ignore next */\nfunction checkInvalidHeaderChar(val) {\n  val += '';\n  if (val.length < 1) {\n    return false;\n  }\n  var c = val.charCodeAt(0);\n  if (c <= 31 && c !== 9 || c > 255 || c === 127) {\n    return true;\n  }\n  if (val.length < 2) {\n    return false;\n  }\n  c = val.charCodeAt(1);\n  if (c <= 31 && c !== 9 || c > 255 || c === 127) {\n    return true;\n  }\n  if (val.length < 3) {\n    return false;\n  }\n  c = val.charCodeAt(2);\n  if (c <= 31 && c !== 9 || c > 255 || c === 127) {\n    return true;\n  }\n  for (var i = 3; i < val.length; ++i) {\n    c = val.charCodeAt(i);\n    if (c <= 31 && c !== 9 || c > 255 || c === 127) {\n      return true;\n    }\n  }\n  return false;\n}\nexports.checkInvalidHeaderChar = checkInvalidHeaderChar;","map":{"version":3,"names":["isValidTokenChar","ch","checkIsHttpToken","val","length","charCodeAt","len","i","exports","checkInvalidHeaderChar","c"],"sources":["/Users/hkateliev/node_modules/npm/node_modules/node-fetch-npm/src/common.js"],"sourcesContent":["'use strict'\n/**\n * A set of utilities borrowed from Node.js' _http_common.js\n */\n\n/**\n * Verifies that the given val is a valid HTTP token\n * per the rules defined in RFC 7230\n * See https://tools.ietf.org/html/rfc7230#section-3.2.6\n *\n * Allowed characters in an HTTP token:\n * ^_`a-z  94-122\n * A-Z     65-90\n * -       45\n * 0-9     48-57\n * !       33\n * #$%&'   35-39\n * *+      42-43\n * .       46\n * |       124\n * ~       126\n *\n * This implementation of checkIsHttpToken() loops over the string instead of\n * using a regular expression since the former is up to 180% faster with v8 4.9\n * depending on the string length (the shorter the string, the larger the\n * performance difference)\n *\n * Additionally, checkIsHttpToken() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/\n/* istanbul ignore next */\nfunction isValidTokenChar (ch) {\n  if (ch >= 94 && ch <= 122) { return true }\n  if (ch >= 65 && ch <= 90) { return true }\n  if (ch === 45) { return true }\n  if (ch >= 48 && ch <= 57) { return true }\n  if (ch === 34 || ch === 40 || ch === 41 || ch === 44) { return false }\n  if (ch >= 33 && ch <= 46) { return true }\n  if (ch === 124 || ch === 126) { return true }\n  return false\n}\n/* istanbul ignore next */\nfunction checkIsHttpToken (val) {\n  if (typeof val !== 'string' || val.length === 0) { return false }\n  if (!isValidTokenChar(val.charCodeAt(0))) { return false }\n  const len = val.length\n  if (len > 1) {\n    if (!isValidTokenChar(val.charCodeAt(1))) { return false }\n    if (len > 2) {\n      if (!isValidTokenChar(val.charCodeAt(2))) { return false }\n      if (len > 3) {\n        if (!isValidTokenChar(val.charCodeAt(3))) { return false }\n        for (var i = 4; i < len; i++) {\n          if (!isValidTokenChar(val.charCodeAt(i))) { return false }\n        }\n      }\n    }\n  }\n  return true\n}\nexports.checkIsHttpToken = checkIsHttpToken\n\n/**\n * True if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n *\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/\n/* istanbul ignore next */\nfunction checkInvalidHeaderChar (val) {\n  val += ''\n  if (val.length < 1) { return false }\n  var c = val.charCodeAt(0)\n  if ((c <= 31 && c !== 9) || c > 255 || c === 127) { return true }\n  if (val.length < 2) { return false }\n  c = val.charCodeAt(1)\n  if ((c <= 31 && c !== 9) || c > 255 || c === 127) { return true }\n  if (val.length < 3) { return false }\n  c = val.charCodeAt(2)\n  if ((c <= 31 && c !== 9) || c > 255 || c === 127) { return true }\n  for (var i = 3; i < val.length; ++i) {\n    c = val.charCodeAt(i)\n    if ((c <= 31 && c !== 9) || c > 255 || c === 127) { return true }\n  }\n  return false\n}\nexports.checkInvalidHeaderChar = checkInvalidHeaderChar\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}