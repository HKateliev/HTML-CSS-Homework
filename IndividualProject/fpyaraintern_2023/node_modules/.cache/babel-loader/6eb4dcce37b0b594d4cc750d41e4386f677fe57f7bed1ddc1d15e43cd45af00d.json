{"ast":null,"code":"'use strict';\n\n/**\n * headers.js\n *\n * Headers class offers convenient helpers\n */\nconst common = require('./common.js');\nconst checkInvalidHeaderChar = common.checkInvalidHeaderChar;\nconst checkIsHttpToken = common.checkIsHttpToken;\nfunction sanitizeName(name) {\n  name += '';\n  if (!checkIsHttpToken(name)) {\n    throw new TypeError(`${name} is not a legal HTTP header name`);\n  }\n  return name.toLowerCase();\n}\nfunction sanitizeValue(value) {\n  value += '';\n  if (checkInvalidHeaderChar(value)) {\n    throw new TypeError(`${value} is not a legal HTTP header value`);\n  }\n  return value;\n}\nconst MAP = Symbol('map');\nclass Headers {\n  /**\n   * Headers class\n   *\n   * @param   Object  headers  Response headers\n   * @return  Void\n   */\n  constructor(init) {\n    this[MAP] = Object.create(null);\n    if (init instanceof Headers) {\n      const rawHeaders = init.raw();\n      const headerNames = Object.keys(rawHeaders);\n      for (const headerName of headerNames) {\n        for (const value of rawHeaders[headerName]) {\n          this.append(headerName, value);\n        }\n      }\n      return;\n    }\n\n    // We don't worry about converting prop to ByteString here as append()\n    // will handle it.\n    if (init == null) {\n      // no op\n    } else if (typeof init === 'object') {\n      const method = init[Symbol.iterator];\n      if (method != null) {\n        if (typeof method !== 'function') {\n          throw new TypeError('Header pairs must be iterable');\n        }\n\n        // sequence<sequence<ByteString>>\n        // Note: per spec we have to first exhaust the lists then process them\n        const pairs = [];\n        for (const pair of init) {\n          if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {\n            throw new TypeError('Each header pair must be iterable');\n          }\n          pairs.push(Array.from(pair));\n        }\n        for (const pair of pairs) {\n          if (pair.length !== 2) {\n            throw new TypeError('Each header pair must be a name/value tuple');\n          }\n          this.append(pair[0], pair[1]);\n        }\n      } else {\n        // record<ByteString, ByteString>\n        for (const key of Object.keys(init)) {\n          const value = init[key];\n          this.append(key, value);\n        }\n      }\n    } else {\n      throw new TypeError('Provided initializer must be an object');\n    }\n    Object.defineProperty(this, Symbol.toStringTag, {\n      value: 'Headers',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    });\n  }\n\n  /**\n   * Return first header value given name\n   *\n   * @param   String  name  Header name\n   * @return  Mixed\n   */\n  get(name) {\n    const list = this[MAP][sanitizeName(name)];\n    if (!list) {\n      return null;\n    }\n    return list.join(', ');\n  }\n\n  /**\n   * Iterate over all headers\n   *\n   * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)\n   * @param   Boolean   thisArg   `this` context for callback function\n   * @return  Void\n   */\n  forEach(callback, thisArg) {\n    let pairs = getHeaderPairs(this);\n    let i = 0;\n    while (i < pairs.length) {\n      const name = pairs[i][0];\n      const value = pairs[i][1];\n      callback.call(thisArg, value, name, this);\n      pairs = getHeaderPairs(this);\n      i++;\n    }\n  }\n\n  /**\n   * Overwrite header values given name\n   *\n   * @param   String  name   Header name\n   * @param   String  value  Header value\n   * @return  Void\n   */\n  set(name, value) {\n    this[MAP][sanitizeName(name)] = [sanitizeValue(value)];\n  }\n\n  /**\n   * Append a value onto existing header\n   *\n   * @param   String  name   Header name\n   * @param   String  value  Header value\n   * @return  Void\n   */\n  append(name, value) {\n    if (!this.has(name)) {\n      this.set(name, value);\n      return;\n    }\n    this[MAP][sanitizeName(name)].push(sanitizeValue(value));\n  }\n\n  /**\n   * Check for header name existence\n   *\n   * @param   String   name  Header name\n   * @return  Boolean\n   */\n  has(name) {\n    return !!this[MAP][sanitizeName(name)];\n  }\n\n  /**\n   * Delete all header values given name\n   *\n   * @param   String  name  Header name\n   * @return  Void\n   */\n  delete(name) {\n    delete this[MAP][sanitizeName(name)];\n  }\n  /**\n   * Return raw headers (non-spec api)\n   *\n   * @return  Object\n   */\n  raw() {\n    return this[MAP];\n  }\n\n  /**\n   * Get an iterator on keys.\n   *\n   * @return  Iterator\n   */\n  keys() {\n    return createHeadersIterator(this, 'key');\n  }\n\n  /**\n   * Get an iterator on values.\n   *\n   * @return  Iterator\n   */\n  values() {\n    return createHeadersIterator(this, 'value');\n  }\n\n  /**\n   * Get an iterator on entries.\n   *\n   * This is the default iterator of the Headers object.\n   *\n   * @return  Iterator\n   */\n  [Symbol.iterator]() {\n    return createHeadersIterator(this, 'key+value');\n  }\n}\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator];\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\n  value: 'HeadersPrototype',\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\nfunction getHeaderPairs(headers, kind) {\n  const keys = Object.keys(headers[MAP]).sort();\n  return keys.map(kind === 'key' ? k => [k] : k => [k, headers.get(k)]);\n}\nconst INTERNAL = Symbol('internal');\nfunction createHeadersIterator(target, kind) {\n  const iterator = Object.create(HeadersIteratorPrototype);\n  iterator[INTERNAL] = {\n    target,\n    kind,\n    index: 0\n  };\n  return iterator;\n}\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\n  next() {\n    // istanbul ignore if\n    if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\n      throw new TypeError('Value of `this` is not a HeadersIterator');\n    }\n    const target = this[INTERNAL].target;\n    const kind = this[INTERNAL].kind;\n    const index = this[INTERNAL].index;\n    const values = getHeaderPairs(target, kind);\n    const len = values.length;\n    if (index >= len) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    const pair = values[index];\n    this[INTERNAL].index = index + 1;\n    let result;\n    if (kind === 'key') {\n      result = pair[0];\n    } else if (kind === 'value') {\n      result = pair[1];\n    } else {\n      result = pair;\n    }\n    return {\n      value: result,\n      done: false\n    };\n  }\n}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\n  value: 'HeadersIterator',\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\nmodule.exports = Headers;","map":{"version":3,"names":["common","require","checkInvalidHeaderChar","checkIsHttpToken","sanitizeName","name","TypeError","toLowerCase","sanitizeValue","value","MAP","Symbol","Headers","constructor","init","Object","create","rawHeaders","raw","headerNames","keys","headerName","append","method","iterator","pairs","pair","push","Array","from","length","key","defineProperty","toStringTag","writable","enumerable","configurable","get","list","join","forEach","callback","thisArg","getHeaderPairs","i","call","set","has","delete","createHeadersIterator","values","prototype","entries","headers","kind","sort","map","k","INTERNAL","target","HeadersIteratorPrototype","index","setPrototypeOf","next","getPrototypeOf","len","undefined","done","result","module","exports"],"sources":["/Users/hkateliev/node_modules/npm/node_modules/node-fetch-npm/src/headers.js"],"sourcesContent":["'use strict'\n\n/**\n * headers.js\n *\n * Headers class offers convenient helpers\n */\n\nconst common = require('./common.js')\nconst checkInvalidHeaderChar = common.checkInvalidHeaderChar\nconst checkIsHttpToken = common.checkIsHttpToken\n\nfunction sanitizeName (name) {\n  name += ''\n  if (!checkIsHttpToken(name)) {\n    throw new TypeError(`${name} is not a legal HTTP header name`)\n  }\n  return name.toLowerCase()\n}\n\nfunction sanitizeValue (value) {\n  value += ''\n  if (checkInvalidHeaderChar(value)) {\n    throw new TypeError(`${value} is not a legal HTTP header value`)\n  }\n  return value\n}\n\nconst MAP = Symbol('map')\nclass Headers {\n  /**\n   * Headers class\n   *\n   * @param   Object  headers  Response headers\n   * @return  Void\n   */\n  constructor (init) {\n    this[MAP] = Object.create(null)\n\n    if (init instanceof Headers) {\n      const rawHeaders = init.raw()\n      const headerNames = Object.keys(rawHeaders)\n\n      for (const headerName of headerNames) {\n        for (const value of rawHeaders[headerName]) {\n          this.append(headerName, value)\n        }\n      }\n\n      return\n    }\n\n    // We don't worry about converting prop to ByteString here as append()\n    // will handle it.\n    if (init == null) {\n      // no op\n    } else if (typeof init === 'object') {\n      const method = init[Symbol.iterator]\n      if (method != null) {\n        if (typeof method !== 'function') {\n          throw new TypeError('Header pairs must be iterable')\n        }\n\n        // sequence<sequence<ByteString>>\n        // Note: per spec we have to first exhaust the lists then process them\n        const pairs = []\n        for (const pair of init) {\n          if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {\n            throw new TypeError('Each header pair must be iterable')\n          }\n          pairs.push(Array.from(pair))\n        }\n\n        for (const pair of pairs) {\n          if (pair.length !== 2) {\n            throw new TypeError('Each header pair must be a name/value tuple')\n          }\n          this.append(pair[0], pair[1])\n        }\n      } else {\n        // record<ByteString, ByteString>\n        for (const key of Object.keys(init)) {\n          const value = init[key]\n          this.append(key, value)\n        }\n      }\n    } else {\n      throw new TypeError('Provided initializer must be an object')\n    }\n\n    Object.defineProperty(this, Symbol.toStringTag, {\n      value: 'Headers',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    })\n  }\n\n  /**\n   * Return first header value given name\n   *\n   * @param   String  name  Header name\n   * @return  Mixed\n   */\n  get (name) {\n    const list = this[MAP][sanitizeName(name)]\n    if (!list) {\n      return null\n    }\n\n    return list.join(', ')\n  }\n\n  /**\n   * Iterate over all headers\n   *\n   * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)\n   * @param   Boolean   thisArg   `this` context for callback function\n   * @return  Void\n   */\n  forEach (callback, thisArg) {\n    let pairs = getHeaderPairs(this)\n    let i = 0\n    while (i < pairs.length) {\n      const name = pairs[i][0]\n      const value = pairs[i][1]\n      callback.call(thisArg, value, name, this)\n      pairs = getHeaderPairs(this)\n      i++\n    }\n  }\n\n  /**\n   * Overwrite header values given name\n   *\n   * @param   String  name   Header name\n   * @param   String  value  Header value\n   * @return  Void\n   */\n  set (name, value) {\n    this[MAP][sanitizeName(name)] = [sanitizeValue(value)]\n  }\n\n  /**\n   * Append a value onto existing header\n   *\n   * @param   String  name   Header name\n   * @param   String  value  Header value\n   * @return  Void\n   */\n  append (name, value) {\n    if (!this.has(name)) {\n      this.set(name, value)\n      return\n    }\n\n    this[MAP][sanitizeName(name)].push(sanitizeValue(value))\n  }\n\n  /**\n   * Check for header name existence\n   *\n   * @param   String   name  Header name\n   * @return  Boolean\n   */\n  has (name) {\n    return !!this[MAP][sanitizeName(name)]\n  }\n\n  /**\n   * Delete all header values given name\n   *\n   * @param   String  name  Header name\n   * @return  Void\n   */\n  delete (name) {\n    delete this[MAP][sanitizeName(name)]\n  };\n\n  /**\n   * Return raw headers (non-spec api)\n   *\n   * @return  Object\n   */\n  raw () {\n    return this[MAP]\n  }\n\n  /**\n   * Get an iterator on keys.\n   *\n   * @return  Iterator\n   */\n  keys () {\n    return createHeadersIterator(this, 'key')\n  }\n\n  /**\n   * Get an iterator on values.\n   *\n   * @return  Iterator\n   */\n  values () {\n    return createHeadersIterator(this, 'value')\n  }\n\n  /**\n   * Get an iterator on entries.\n   *\n   * This is the default iterator of the Headers object.\n   *\n   * @return  Iterator\n   */\n  [Symbol.iterator] () {\n    return createHeadersIterator(this, 'key+value')\n  }\n}\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator]\n\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\n  value: 'HeadersPrototype',\n  writable: false,\n  enumerable: false,\n  configurable: true\n})\n\nfunction getHeaderPairs (headers, kind) {\n  const keys = Object.keys(headers[MAP]).sort()\n  return keys.map(\n    kind === 'key'\n      ? k => [k]\n      : k => [k, headers.get(k)]\n  )\n}\n\nconst INTERNAL = Symbol('internal')\n\nfunction createHeadersIterator (target, kind) {\n  const iterator = Object.create(HeadersIteratorPrototype)\n  iterator[INTERNAL] = {\n    target,\n    kind,\n    index: 0\n  }\n  return iterator\n}\n\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\n  next () {\n    // istanbul ignore if\n    if (!this ||\n      Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\n      throw new TypeError('Value of `this` is not a HeadersIterator')\n    }\n\n    const target = this[INTERNAL].target\n    const kind = this[INTERNAL].kind\n    const index = this[INTERNAL].index\n    const values = getHeaderPairs(target, kind)\n    const len = values.length\n    if (index >= len) {\n      return {\n        value: undefined,\n        done: true\n      }\n    }\n\n    const pair = values[index]\n    this[INTERNAL].index = index + 1\n\n    let result\n    if (kind === 'key') {\n      result = pair[0]\n    } else if (kind === 'value') {\n      result = pair[1]\n    } else {\n      result = pair\n    }\n\n    return {\n      value: result,\n      done: false\n    }\n  }\n}, Object.getPrototypeOf(\n  Object.getPrototypeOf([][Symbol.iterator]())\n))\n\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\n  value: 'HeadersIterator',\n  writable: false,\n  enumerable: false,\n  configurable: true\n})\n\nmodule.exports = Headers\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}