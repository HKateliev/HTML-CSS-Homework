{"ast":null,"code":"'use strict';\n\nvar path = require('path');\nvar fs = require('graceful-fs');\nvar rimraf = require('rimraf');\nvar asyncMap = require('slide').asyncMap;\nvar mkdirp = require('gentle-fs').mkdir;\nvar npm = require('../../npm.js');\nvar andIgnoreErrors = require('../and-ignore-errors.js');\nvar move = require('../../utils/move.js');\nvar isInside = require('path-is-inside');\nvar vacuum = require('fs-vacuum');\n\n// This is weird because we want to remove the module but not it's node_modules folder\n// allowing for this allows us to not worry about the order of operations\nmodule.exports = function (staging, pkg, log, next) {\n  log.silly('remove', pkg.path);\n  if (pkg.target) {\n    removeLink(pkg, next);\n  } else {\n    removeDir(pkg, log, next);\n  }\n};\nfunction removeLink(pkg, next) {\n  var base = isInside(pkg.path, npm.prefix) ? npm.prefix : pkg.path;\n  rimraf(pkg.path, err => {\n    if (err) return next(err);\n    vacuum(pkg.path, {\n      base: base\n    }, next);\n  });\n}\nfunction removeDir(pkg, log, next) {\n  var modpath = path.join(path.dirname(pkg.path), '.' + path.basename(pkg.path) + '.MODULES');\n  move(path.join(pkg.path, 'node_modules'), modpath).then(unbuildPackage, unbuildPackage);\n  function unbuildPackage(moveEr) {\n    rimraf(pkg.path, moveEr ? andRemoveEmptyParents(pkg.path) : moveModulesBack);\n  }\n  function andRemoveEmptyParents(path) {\n    return function (er) {\n      if (er) return next(er);\n      removeEmptyParents(pkg.path);\n    };\n  }\n  function moveModulesBack() {\n    fs.readdir(modpath, makeTarget);\n  }\n  function makeTarget(readdirEr, files) {\n    if (readdirEr) return cleanup();\n    if (!files.length) return cleanup();\n    mkdirp(path.join(pkg.path, 'node_modules'), function (mkdirEr) {\n      moveModules(mkdirEr, files);\n    });\n  }\n  function moveModules(mkdirEr, files) {\n    if (mkdirEr) return next(mkdirEr);\n    asyncMap(files, function (file, done) {\n      var from = path.join(modpath, file);\n      var to = path.join(pkg.path, 'node_modules', file);\n      // we ignore errors here, because they can legitimately happen, for instance,\n      // bundled modules will be in both node_modules folders\n      move(from, to).then(andIgnoreErrors(done), andIgnoreErrors(done));\n    }, cleanup);\n  }\n  function cleanup() {\n    rimraf(modpath, afterCleanup);\n  }\n  function afterCleanup(rimrafEr) {\n    if (rimrafEr) log.warn('remove', rimrafEr);\n    removeEmptyParents(path.resolve(pkg.path, '..'));\n  }\n  function removeEmptyParents(pkgdir) {\n    fs.rmdir(pkgdir, function (er) {\n      // FIXME: Make sure windows does what we want here\n      if (er && er.code !== 'ENOENT') return next();\n      removeEmptyParents(path.resolve(pkgdir, '..'));\n    });\n  }\n}","map":{"version":3,"names":["path","require","fs","rimraf","asyncMap","mkdirp","mkdir","npm","andIgnoreErrors","move","isInside","vacuum","module","exports","staging","pkg","log","next","silly","target","removeLink","removeDir","base","prefix","err","modpath","join","dirname","basename","then","unbuildPackage","moveEr","andRemoveEmptyParents","moveModulesBack","er","removeEmptyParents","readdir","makeTarget","readdirEr","files","cleanup","length","mkdirEr","moveModules","file","done","from","to","afterCleanup","rimrafEr","warn","resolve","pkgdir","rmdir","code"],"sources":["/Users/hkateliev/node_modules/npm/lib/install/action/remove.js"],"sourcesContent":["'use strict'\nvar path = require('path')\nvar fs = require('graceful-fs')\nvar rimraf = require('rimraf')\nvar asyncMap = require('slide').asyncMap\nvar mkdirp = require('gentle-fs').mkdir\nvar npm = require('../../npm.js')\nvar andIgnoreErrors = require('../and-ignore-errors.js')\nvar move = require('../../utils/move.js')\nvar isInside = require('path-is-inside')\nvar vacuum = require('fs-vacuum')\n\n// This is weird because we want to remove the module but not it's node_modules folder\n// allowing for this allows us to not worry about the order of operations\nmodule.exports = function (staging, pkg, log, next) {\n  log.silly('remove', pkg.path)\n  if (pkg.target) {\n    removeLink(pkg, next)\n  } else {\n    removeDir(pkg, log, next)\n  }\n}\n\nfunction removeLink (pkg, next) {\n  var base = isInside(pkg.path, npm.prefix) ? npm.prefix : pkg.path\n  rimraf(pkg.path, (err) => {\n    if (err) return next(err)\n    vacuum(pkg.path, {base: base}, next)\n  })\n}\n\nfunction removeDir (pkg, log, next) {\n  var modpath = path.join(path.dirname(pkg.path), '.' + path.basename(pkg.path) + '.MODULES')\n\n  move(path.join(pkg.path, 'node_modules'), modpath).then(unbuildPackage, unbuildPackage)\n\n  function unbuildPackage (moveEr) {\n    rimraf(pkg.path, moveEr ? andRemoveEmptyParents(pkg.path) : moveModulesBack)\n  }\n\n  function andRemoveEmptyParents (path) {\n    return function (er) {\n      if (er) return next(er)\n      removeEmptyParents(pkg.path)\n    }\n  }\n\n  function moveModulesBack () {\n    fs.readdir(modpath, makeTarget)\n  }\n\n  function makeTarget (readdirEr, files) {\n    if (readdirEr) return cleanup()\n    if (!files.length) return cleanup()\n    mkdirp(path.join(pkg.path, 'node_modules'), function (mkdirEr) { moveModules(mkdirEr, files) })\n  }\n\n  function moveModules (mkdirEr, files) {\n    if (mkdirEr) return next(mkdirEr)\n    asyncMap(files, function (file, done) {\n      var from = path.join(modpath, file)\n      var to = path.join(pkg.path, 'node_modules', file)\n      // we ignore errors here, because they can legitimately happen, for instance,\n      // bundled modules will be in both node_modules folders\n      move(from, to).then(andIgnoreErrors(done), andIgnoreErrors(done))\n    }, cleanup)\n  }\n\n  function cleanup () {\n    rimraf(modpath, afterCleanup)\n  }\n\n  function afterCleanup (rimrafEr) {\n    if (rimrafEr) log.warn('remove', rimrafEr)\n    removeEmptyParents(path.resolve(pkg.path, '..'))\n  }\n\n  function removeEmptyParents (pkgdir) {\n    fs.rmdir(pkgdir, function (er) {\n      // FIXME: Make sure windows does what we want here\n      if (er && er.code !== 'ENOENT') return next()\n      removeEmptyParents(path.resolve(pkgdir, '..'))\n    })\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}