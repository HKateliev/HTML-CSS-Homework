{"ast":null,"code":"'use strict';\n\nconst BB = require('bluebird');\nvar fs = require('fs');\nvar assert = require('assert');\nvar path = require('path');\nvar semver = require('semver');\nvar asyncMap = require('slide').asyncMap;\nvar chain = require('slide').chain;\nvar iferr = require('iferr');\nvar npa = require('npm-package-arg');\nvar validate = require('aproba');\nvar dezalgo = require('dezalgo');\nvar fetchPackageMetadata = require('../fetch-package-metadata.js');\nvar andAddParentToErrors = require('./and-add-parent-to-errors.js');\nvar addBundled = require('../fetch-package-metadata.js').addBundled;\nvar readShrinkwrap = require('./read-shrinkwrap.js');\nvar inflateShrinkwrap = require('./inflate-shrinkwrap.js');\nvar inflateBundled = require('./inflate-bundled.js');\nvar andFinishTracker = require('./and-finish-tracker.js');\nvar npm = require('../npm.js');\nvar flatNameFromTree = require('./flatten-tree.js').flatNameFromTree;\nvar createChild = require('./node.js').create;\nvar resetMetadata = require('./node.js').reset;\nvar isInstallable = require('./validate-args.js').isInstallable;\nvar packageId = require('../utils/package-id.js');\nvar moduleName = require('../utils/module-name.js');\nvar isDevDep = require('./is-dev-dep.js');\nvar isProdDep = require('./is-prod-dep.js');\nvar reportOptionalFailure = require('./report-optional-failure.js');\nvar getSaveType = require('./save.js').getSaveType;\nvar unixFormatPath = require('../utils/unix-format-path.js');\nvar isExtraneous = require('./is-extraneous.js');\nvar isRegistry = require('../utils/is-registry.js');\nvar hasModernMeta = require('./has-modern-meta.js');\n\n// The export functions in this module mutate a dependency tree, adding\n// items to them.\n\nvar registryTypes = {\n  range: true,\n  version: true\n};\nfunction doesChildVersionMatch(child, requested, requestor) {\n  if (child.fromShrinkwrap && !child.hasRequiresFromLock) return true;\n  // ranges of * ALWAYS count as a match, because when downloading we allow\n  // prereleases to match * if there are ONLY prereleases\n  if (requested.type === 'range' && requested.fetchSpec === '*') return true;\n  if (requested.type === 'directory') {\n    if (!child.isLink) return false;\n    return path.relative(child.realpath, requested.fetchSpec) === '';\n  }\n  if (requested.type === 'git' && child.fromShrinkwrap) {\n    const fromSw = child.package._from ? npa(child.package._from) : child.fromShrinkwrap;\n    fromSw.name = requested.name; // we're only checking specifiers here\n    if (fromSw.toString() === requested.toString()) return true;\n  }\n  if (requested.type === 'git' && requested.gitRange) {\n    const sameRepo = npa(child.package._from).fetchSpec === requested.fetchSpec;\n    try {\n      return sameRepo && semver.satisfies(child.package.version, requested.gitRange, true);\n    } catch (e) {\n      return false;\n    }\n  }\n  if (requested.type === 'alias') {\n    return doesChildVersionMatch(child, requested.subSpec, requestor);\n  }\n  if (!registryTypes[requested.type]) {\n    var childReq = child.package._requested;\n    if (childReq) {\n      if (childReq.rawSpec === requested.rawSpec) return true;\n      if (childReq.type === requested.type) {\n        if (childReq.saveSpec === requested.saveSpec) return true;\n        if (childReq.fetchSpec === requested.fetchSpec && requested.type !== 'git') return true;\n      }\n    }\n    // If _requested didn't exist OR if it didn't match then we'll try using\n    // _from. We pass it through npa to normalize the specifier.\n    // This can happen when installing from an `npm-shrinkwrap.json` where `_requested` will\n    // be the tarball URL from `resolved` and thus can't match what's in the `package.json`.\n    // In those cases _from, will be preserved and we can compare that to ensure that they\n    // really came from the same sources.\n    // You'll see this scenario happen with at least tags and git dependencies.\n    // Some buggy clients will write spaces into the module name part of a _from.\n    if (child.package._from) {\n      var fromReq = npa(child.package._from);\n      if (fromReq.rawSpec === requested.rawSpec) return true;\n      if (fromReq.type === requested.type && fromReq.saveSpec && fromReq.saveSpec === requested.saveSpec) return true;\n    }\n    return false;\n  }\n  try {\n    return semver.satisfies(child.package.version, requested.fetchSpec, true);\n  } catch (e) {\n    return false;\n  }\n}\nfunction childDependencySpecifier(tree, name, spec, where) {\n  return npa.resolve(name, spec, where || packageRelativePath(tree));\n}\nexports.computeMetadata = computeMetadata;\nfunction computeMetadata(tree, seen) {\n  if (!seen) seen = new Set();\n  if (!tree || seen.has(tree)) return;\n  seen.add(tree);\n  if (tree.parent == null) {\n    resetMetadata(tree);\n    tree.isTop = true;\n  }\n  tree.location = flatNameFromTree(tree);\n  function findChild(name, spec, kind) {\n    try {\n      var req = childDependencySpecifier(tree, name, spec);\n    } catch (err) {\n      return;\n    }\n    var child = findRequirement(tree, req.name, req);\n    if (child) {\n      resolveWithExistingModule(child, tree);\n      return true;\n    }\n  }\n  const deps = tree.package.dependencies || {};\n  const reqs = tree.swRequires || {};\n  for (let name of Object.keys(deps)) {\n    if (findChild(name, deps[name])) continue;\n    if (name in reqs && findChild(name, reqs[name])) continue;\n    tree.missingDeps[name] = deps[name];\n  }\n  if (tree.isTop) {\n    const devDeps = tree.package.devDependencies || {};\n    for (let name of Object.keys(devDeps)) {\n      if (findChild(name, devDeps[name])) continue;\n      tree.missingDevDeps[name] = devDeps[name];\n    }\n  }\n  tree.children.filter(child => !child.removed).forEach(child => computeMetadata(child, seen));\n  return tree;\n}\nfunction isDep(tree, child) {\n  var name = moduleName(child);\n  var prodVer = isProdDep(tree, name);\n  var devVer = isDevDep(tree, name);\n  try {\n    var prodSpec = childDependencySpecifier(tree, name, prodVer);\n  } catch (err) {\n    return {\n      isDep: true,\n      isProdDep: false,\n      isDevDep: false\n    };\n  }\n  var matches;\n  if (prodSpec) matches = doesChildVersionMatch(child, prodSpec, tree);\n  if (matches) return {\n    isDep: true,\n    isProdDep: prodSpec,\n    isDevDep: false\n  };\n  if (devVer === prodVer) return {\n    isDep: child.fromShrinkwrap,\n    isProdDep: false,\n    isDevDep: false\n  };\n  try {\n    var devSpec = childDependencySpecifier(tree, name, devVer);\n    return {\n      isDep: doesChildVersionMatch(child, devSpec, tree) || child.fromShrinkwrap,\n      isProdDep: false,\n      isDevDep: devSpec\n    };\n  } catch (err) {\n    return {\n      isDep: child.fromShrinkwrap,\n      isProdDep: false,\n      isDevDep: false\n    };\n  }\n}\nfunction addRequiredDep(tree, child) {\n  var dep = isDep(tree, child);\n  if (!dep.isDep) return false;\n  replaceModuleByPath(child, 'requiredBy', tree);\n  replaceModuleByName(tree, 'requires', child);\n  if (dep.isProdDep && tree.missingDeps) delete tree.missingDeps[moduleName(child)];\n  if (dep.isDevDep && tree.missingDevDeps) delete tree.missingDevDeps[moduleName(child)];\n  return true;\n}\nexports.removeObsoleteDep = removeObsoleteDep;\nfunction removeObsoleteDep(child, log) {\n  if (child.removed) return;\n  child.removed = true;\n  if (log) {\n    log.silly('removeObsoleteDep', 'removing ' + packageId(child) + ' from the tree as its been replaced by a newer version or is no longer required');\n  }\n  // remove from physical tree\n  if (child.parent) {\n    child.parent.children = child.parent.children.filter(function (pchild) {\n      return pchild !== child;\n    });\n  }\n  // remove from logical tree\n  var requires = child.requires || [];\n  requires.forEach(function (requirement) {\n    requirement.requiredBy = requirement.requiredBy.filter(function (reqBy) {\n      return reqBy !== child;\n    });\n    // we don't just check requirement.requires because that doesn't account\n    // for circular deps.  isExtraneous does.\n    if (isExtraneous(requirement)) removeObsoleteDep(requirement, log);\n  });\n}\nexports.packageRelativePath = packageRelativePath;\nfunction packageRelativePath(tree) {\n  if (!tree) return '';\n  var requested = tree.package._requested || {};\n  if (requested.type === 'directory') {\n    return requested.fetchSpec;\n  } else if (requested.type === 'file') {\n    return path.dirname(requested.fetchSpec);\n  } else if ((tree.isLink || tree.isInLink) && !preserveSymlinks()) {\n    return tree.realpath;\n  } else {\n    return tree.path;\n  }\n}\nfunction matchingDep(tree, name) {\n  if (!tree || !tree.package) return;\n  if (tree.package.dependencies && tree.package.dependencies[name]) return tree.package.dependencies[name];\n  if (tree.package.devDependencies && tree.package.devDependencies[name]) return tree.package.devDependencies[name];\n}\nexports.getAllMetadata = function (args, tree, where, next) {\n  asyncMap(args, function (arg, done) {\n    let spec;\n    try {\n      spec = npa(arg);\n    } catch (e) {\n      return done(e);\n    }\n    if (spec.type !== 'file' && spec.type !== 'directory' && (spec.name == null || spec.rawSpec === '')) {\n      return fs.stat(path.join(arg, 'package.json'), err => {\n        if (err) {\n          var version = matchingDep(tree, spec.name);\n          if (version) {\n            try {\n              return fetchPackageMetadata(npa.resolve(spec.name, version), where, done);\n            } catch (e) {\n              return done(e);\n            }\n          } else {\n            return fetchPackageMetadata(spec, where, done);\n          }\n        } else {\n          try {\n            return fetchPackageMetadata(npa('file:' + arg), where, done);\n          } catch (e) {\n            return done(e);\n          }\n        }\n      });\n    } else {\n      return fetchPackageMetadata(spec, where, done);\n    }\n  }, next);\n};\n\n// Add a list of args to tree's top level dependencies\nexports.loadRequestedDeps = function (args, tree, saveToDependencies, log, next) {\n  validate('AOOF', [args, tree, log, next]);\n  asyncMap(args, function (pkg, done) {\n    var depLoaded = andAddParentToErrors(tree, done);\n    resolveWithNewModule(pkg, tree, log.newGroup('loadRequestedDeps'), iferr(depLoaded, function (child, tracker) {\n      validate('OO', arguments);\n      if (npm.config.get('global')) {\n        child.isGlobal = true;\n      }\n      var childName = moduleName(child);\n      child.saveSpec = computeVersionSpec(tree, child);\n      child.userRequired = true;\n      child.save = getSaveType(tree, child);\n      const types = ['dependencies', 'devDependencies', 'optionalDependencies'];\n      if (child.save) {\n        tree.package[child.save][childName] = child.saveSpec;\n        // Astute readers might notice that this exact same code exists in\n        // save.js under a different guise. That code is responsible for deps\n        // being removed from the final written `package.json`. The removal in\n        // this function is specifically to prevent \"installed as both X and Y\"\n        // warnings when moving an existing dep between different dep fields.\n        //\n        // Or, try it by removing this loop, and do `npm i -P x && npm i -D x`\n        for (let saveType of types) {\n          if (child.save !== saveType) {\n            delete tree.package[saveType][childName];\n          }\n        }\n        if (child.save === 'optionalDependencies') tree.package.dependencies[childName] = child.saveSpec;\n      }\n\n      // For things the user asked to install, that aren't a dependency (or\n      // won't be when we're done), flag it as \"depending\" on the user\n      // themselves, so we don't remove it as a dep that no longer exists\n      var childIsDep = addRequiredDep(tree, child);\n      if (!childIsDep) child.userRequired = true;\n      depLoaded(null, child, tracker);\n    }));\n  }, andForEachChild(loadDeps, andFinishTracker(log, next)));\n};\nfunction isNotEmpty(value) {\n  return value != null && value !== '';\n}\nexports.computeVersionSpec = computeVersionSpec;\nfunction computeVersionSpec(tree, child) {\n  validate('OO', arguments);\n  var requested;\n  var childReq = child.package._requested;\n  if (child.isLink) {\n    requested = npa.resolve(moduleName(child), 'file:' + child.realpath, getTop(tree).path);\n  } else if (childReq && (isNotEmpty(childReq.saveSpec) || isNotEmpty(childReq.rawSpec) && isNotEmpty(childReq.fetchSpec))) {\n    requested = child.package._requested;\n  } else if (child.package._from) {\n    requested = npa(child.package._from, tree.path);\n  } else if (child.name && child.name !== child.package.name) {\n    requested = npa.resolve(child.name, `npm:${child.package.name}@${child.package.version})`);\n  } else {\n    requested = npa.resolve(child.package.name, child.package.version);\n  }\n  if (isRegistry(requested)) {\n    var version = child.package.version;\n    var rangeDescriptor = '';\n    if (semver.valid(version, true) && semver.gte(version, '0.1.0', true) && !npm.config.get('save-exact')) {\n      rangeDescriptor = npm.config.get('save-prefix');\n    }\n    if (requested.type === 'alias') {\n      rangeDescriptor = `npm:${requested.subSpec.name}@${rangeDescriptor}`;\n    }\n    return rangeDescriptor + version;\n  } else if (requested.type === 'directory' || requested.type === 'file') {\n    return 'file:' + unixFormatPath(path.relative(getTop(tree).path, requested.fetchSpec));\n  } else {\n    return requested.saveSpec || requested.rawSpec;\n  }\n}\nfunction moduleNameMatches(name) {\n  return function (child) {\n    return moduleName(child) === name;\n  };\n}\n\n// while this implementation does not require async calling, doing so\n// gives this a consistent interface with loadDeps et al\nexports.removeDeps = function (args, tree, saveToDependencies, next) {\n  validate('AOSF|AOZF', [args, tree, saveToDependencies, next]);\n  for (let pkg of args) {\n    var pkgName = moduleName(pkg);\n    var toRemove = tree.children.filter(moduleNameMatches(pkgName));\n    var pkgToRemove = toRemove[0] || createChild({\n      name: pkgName\n    });\n    var saveType = getSaveType(tree, pkg) || 'dependencies';\n    if (tree.isTop && saveToDependencies) {\n      pkgToRemove.save = saveType;\n    }\n    if (tree.package[saveType][pkgName]) {\n      delete tree.package[saveType][pkgName];\n      if (saveType === 'optionalDependencies' && tree.package.dependencies[pkgName]) {\n        delete tree.package.dependencies[pkgName];\n      }\n    }\n    replaceModuleByPath(tree, 'removedChildren', pkgToRemove);\n    for (let parent of pkgToRemove.requiredBy) {\n      parent.requires = parent.requires.filter(child => child !== pkgToRemove);\n    }\n    pkgToRemove.requiredBy = pkgToRemove.requiredBy.filter(parent => parent !== tree);\n    flagAsRemoving(pkgToRemove);\n  }\n  next();\n};\nfunction flagAsRemoving(toRemove, seen) {\n  if (!seen) seen = new Set();\n  if (seen.has(toRemove)) return;\n  seen.add(toRemove);\n  toRemove.removing = true;\n  toRemove.requires.forEach(required => {\n    flagAsRemoving(required, seen);\n  });\n}\nexports.removeExtraneous = function (args, tree, next) {\n  for (let pkg of args) {\n    var pkgName = moduleName(pkg);\n    var toRemove = tree.children.filter(moduleNameMatches(pkgName));\n    if (toRemove.length) {\n      removeObsoleteDep(toRemove[0]);\n    }\n  }\n  next();\n};\nfunction andForEachChild(load, next) {\n  validate('F', [next]);\n  next = dezalgo(next);\n  return function (er, children, logs) {\n    // when children is empty, logs won't be passed in at all (asyncMap is weird)\n    // so shortcircuit before arg validation\n    if (!er && (!children || children.length === 0)) return next();\n    validate('EAA', arguments);\n    if (er) return next(er);\n    assert(children.length === logs.length);\n    var cmds = [];\n    for (var ii = 0; ii < children.length; ++ii) {\n      cmds.push([load, children[ii], logs[ii]]);\n    }\n    var sortedCmds = cmds.sort(function installOrder(aa, bb) {\n      return moduleName(aa[1]).localeCompare(moduleName(bb[1]));\n    });\n    chain(sortedCmds, next);\n  };\n}\nfunction isDepOptional(tree, name, pkg) {\n  if (pkg.package && pkg.package._optional) return true;\n  const optDeps = tree.package.optionalDependencies;\n  if (optDeps && optDeps[name] != null) return true;\n  const devDeps = tree.package.devDependencies;\n  if (devDeps && devDeps[name] != null) {\n    const includeDev = npm.config.get('dev') || !/^prod(uction)?$/.test(npm.config.get('only')) && !npm.config.get('production') || /^dev(elopment)?$/.test(npm.config.get('only')) || /^dev(elopment)?$/.test(npm.config.get('also'));\n    return !includeDev;\n  }\n  const prodDeps = tree.package.dependencies;\n  if (prodDeps && prodDeps[name] != null) {\n    const includeProd = !/^dev(elopment)?$/.test(npm.config.get('only'));\n    return !includeProd;\n  }\n  return false;\n}\nexports.failedDependency = failedDependency;\nfunction failedDependency(tree, name, pkg) {\n  if (name) {\n    if (isDepOptional(tree, name, pkg || {})) {\n      return false;\n    }\n  }\n  tree.failed = true;\n  if (tree.isTop) return true;\n  if (tree.userRequired) return true;\n  if (!tree.requiredBy) return false;\n  let anyFailed = false;\n  for (var ii = 0; ii < tree.requiredBy.length; ++ii) {\n    var requireParent = tree.requiredBy[ii];\n    if (failedDependency(requireParent, moduleName(tree), tree)) {\n      anyFailed = true;\n    }\n  }\n  return anyFailed;\n}\nfunction andHandleOptionalErrors(log, tree, name, done) {\n  validate('OOSF', arguments);\n  return function (er, child, childLog) {\n    if (!er) validate('OO', [child, childLog]);\n    if (!er) return done(er, child, childLog);\n    var isFatal = failedDependency(tree, name);\n    if (er && !isFatal) {\n      reportOptionalFailure(tree, name, er);\n      return done();\n    } else {\n      return done(er, child, childLog);\n    }\n  };\n}\nexports.prefetchDeps = prefetchDeps;\nfunction prefetchDeps(tree, deps, log, next) {\n  validate('OOOF', arguments);\n  var skipOptional = !npm.config.get('optional');\n  var seen = new Set();\n  const finished = andFinishTracker(log, next);\n  const fpm = BB.promisify(fetchPackageMetadata);\n  resolveBranchDeps(tree.package, deps).then(() => finished(), finished);\n  function resolveBranchDeps(pkg, deps) {\n    return BB.resolve(null).then(() => {\n      var allDependencies = Object.keys(deps).map(dep => {\n        return npa.resolve(dep, deps[dep]);\n      }).filter(dep => {\n        return isRegistry(dep) && !seen.has(dep.toString()) && !findRequirement(tree, dep.name, dep);\n      });\n      if (skipOptional) {\n        var optDeps = pkg.optionalDependencies || {};\n        allDependencies = allDependencies.filter(dep => !optDeps[dep.name]);\n      }\n      return BB.map(allDependencies, dep => {\n        seen.add(dep.toString());\n        return fpm(dep, '', {\n          tracker: log.newItem('fetchMetadata')\n        }).then(pkg => {\n          return pkg && pkg.dependencies && resolveBranchDeps(pkg, pkg.dependencies);\n        }, () => null);\n      });\n    });\n  }\n}\n\n// Load any missing dependencies in the given tree\nexports.loadDeps = loadDeps;\nfunction loadDeps(tree, log, next) {\n  validate('OOF', arguments);\n  if (tree.loaded || tree.parent && tree.parent.failed || tree.removed) return andFinishTracker.now(log, next);\n  if (tree.parent) tree.loaded = true;\n  if (!tree.package.dependencies) tree.package.dependencies = {};\n  asyncMap(Object.keys(tree.package.dependencies), function (dep, done) {\n    var version = tree.package.dependencies[dep];\n    addDependency(dep, version, tree, log.newGroup('loadDep:' + dep), andHandleOptionalErrors(log, tree, dep, done));\n  }, andForEachChild(loadDeps, andFinishTracker(log, next)));\n}\n\n// Load development dependencies into the given tree\nexports.loadDevDeps = function (tree, log, next) {\n  validate('OOF', arguments);\n  if (!tree.package.devDependencies) return andFinishTracker.now(log, next);\n  asyncMap(Object.keys(tree.package.devDependencies), function (dep, done) {\n    // things defined as both dev dependencies and regular dependencies are treated\n    // as the former\n    if (tree.package.dependencies[dep]) return done();\n    var logGroup = log.newGroup('loadDevDep:' + dep);\n    addDependency(dep, tree.package.devDependencies[dep], tree, logGroup, andHandleOptionalErrors(log, tree, dep, done));\n  }, andForEachChild(loadDeps, andFinishTracker(log, next)));\n};\nvar loadExtraneous = exports.loadExtraneous = function (tree, log, next) {\n  var seen = new Set();\n  function loadExtraneous(tree) {\n    if (seen.has(tree)) return;\n    seen.add(tree);\n    for (var child of tree.children) {\n      if (child.loaded) continue;\n      resolveWithExistingModule(child, tree);\n      loadExtraneous(child);\n    }\n  }\n  loadExtraneous(tree);\n  log.finish();\n  next();\n};\nexports.loadExtraneous.andResolveDeps = function (tree, log, next) {\n  validate('OOF', arguments);\n  // For canonicalized trees (eg from shrinkwrap) we don't want to bother\n  // resolving the dependencies of extraneous deps.\n  if (tree.loaded) return loadExtraneous(tree, log, next);\n  asyncMap(tree.children.filter(function (child) {\n    return !child.loaded;\n  }), function (child, done) {\n    resolveWithExistingModule(child, tree);\n    done(null, child, log);\n  }, andForEachChild(loadDeps, andFinishTracker(log, next)));\n};\nfunction addDependency(name, versionSpec, tree, log, done) {\n  validate('SSOOF', arguments);\n  var next = andAddParentToErrors(tree, done);\n  try {\n    var req = childDependencySpecifier(tree, name, versionSpec);\n    if (tree.swRequires && tree.swRequires[name]) {\n      var swReq = childDependencySpecifier(tree, name, tree.swRequires[name]);\n    }\n  } catch (err) {\n    return done(err);\n  }\n  var child = findRequirement(tree, name, req);\n  if (!child && swReq) child = findRequirement(tree, name, swReq);\n  if (hasModernMeta(child)) {\n    resolveWithExistingModule(child, tree);\n    if (child.package._shrinkwrap === undefined) {\n      readShrinkwrap.andInflate(child, function (er) {\n        next(er, child, log);\n      });\n    } else {\n      next(null, child, log);\n    }\n  } else {\n    if (child) {\n      if (req.registry) {\n        req = childDependencySpecifier(tree, name, child.package.version);\n      }\n      if (child.fromBundle) reportBundleOverride(child, log);\n      removeObsoleteDep(child, log);\n    }\n    fetchPackageMetadata(req, packageRelativePath(tree), {\n      tracker: log.newItem('fetchMetadata')\n    }, iferr(next, function (pkg) {\n      resolveWithNewModule(pkg, tree, log, next);\n    }));\n  }\n}\nfunction getTop(pkg) {\n  const seen = new Set();\n  while (pkg.parent && !seen.has(pkg.parent)) {\n    pkg = pkg.parent;\n    seen.add(pkg);\n  }\n  return pkg;\n}\nfunction reportBundleOverride(child, log) {\n  const code = 'EBUNDLEOVERRIDE';\n  const top = getTop(child.fromBundle);\n  const bundlerId = packageId(child.fromBundle);\n  if (!top.warnings.some(w => {\n    return w.code === code;\n  })) {\n    const err = new Error(`${bundlerId} had bundled packages that do not match the required version(s). They have been replaced with non-bundled versions.`);\n    err.code = code;\n    top.warnings.push(err);\n  }\n  if (log) log.verbose('bundle', `${code}: Replacing ${bundlerId}'s bundled version of ${moduleName(child)} with ${packageId(child)}.`);\n}\nfunction resolveWithExistingModule(child, tree) {\n  validate('OO', arguments);\n  addRequiredDep(tree, child);\n  if (tree.parent && child.parent !== tree) updatePhantomChildren(tree.parent, child);\n}\nvar updatePhantomChildren = exports.updatePhantomChildren = function (current, child) {\n  validate('OO', arguments);\n  while (current && current !== child.parent) {\n    if (!current.phantomChildren) current.phantomChildren = {};\n    current.phantomChildren[moduleName(child)] = child;\n    current = current.parent;\n  }\n};\nexports._replaceModuleByPath = replaceModuleByPath;\nfunction replaceModuleByPath(obj, key, child) {\n  return replaceModule(obj, key, child, function (replacing, child) {\n    return replacing.path === child.path;\n  });\n}\nexports._replaceModuleByName = replaceModuleByName;\nfunction replaceModuleByName(obj, key, child) {\n  var childName = moduleName(child);\n  return replaceModule(obj, key, child, function (replacing, child) {\n    return moduleName(replacing) === childName;\n  });\n}\nfunction replaceModule(obj, key, child, matchBy) {\n  validate('OSOF', arguments);\n  if (!obj[key]) obj[key] = [];\n  // we replace children with a new array object instead of mutating it\n  // because mutating it results in weird failure states.\n  // I would very much like to know _why_ this is. =/\n  var children = [].concat(obj[key]);\n  for (var replaceAt = 0; replaceAt < children.length; ++replaceAt) {\n    if (matchBy(children[replaceAt], child)) break;\n  }\n  var replacing = children.splice(replaceAt, 1, child);\n  obj[key] = children;\n  return replacing[0];\n}\nfunction resolveWithNewModule(pkg, tree, log, next) {\n  validate('OOOF', arguments);\n  log.silly('resolveWithNewModule', packageId(pkg), 'checking installable status');\n  return isInstallable(tree, pkg, err => {\n    let installable = !err;\n    addBundled(pkg, bundleErr => {\n      var parent = earliestInstallable(tree, tree, pkg, log) || tree;\n      var isLink = pkg._requested.type === 'directory';\n      var name = pkg._requested.name || pkg.name;\n      var child = createChild({\n        name,\n        package: pkg,\n        parent: parent,\n        path: path.join(parent.isLink ? parent.realpath : parent.path, 'node_modules', name),\n        realpath: isLink ? pkg._requested.fetchSpec : path.join(parent.realpath, 'node_modules', name),\n        children: pkg._bundled || [],\n        isLink: isLink,\n        isInLink: parent.isLink,\n        knownInstallable: installable\n      });\n      if (!installable || bundleErr) child.failed = true;\n      delete pkg._bundled;\n      var hasBundled = child.children.length;\n      var replaced = replaceModuleByName(parent, 'children', child);\n      if (replaced) {\n        if (replaced.fromBundle) reportBundleOverride(replaced, log);\n        removeObsoleteDep(replaced);\n      }\n      addRequiredDep(tree, child);\n      child.location = flatNameFromTree(child);\n      if (tree.parent && parent !== tree) updatePhantomChildren(tree.parent, child);\n      if (hasBundled) {\n        inflateBundled(child, child, child.children);\n      }\n      if (pkg._shrinkwrap && pkg._shrinkwrap.dependencies) {\n        return inflateShrinkwrap(child, pkg._shrinkwrap, swErr => {\n          if (swErr) child.failed = true;\n          next(err || bundleErr || swErr, child, log);\n        });\n      }\n      next(err || bundleErr, child, log);\n    });\n  });\n}\nvar isOptionalPeerDep = exports.isOptionalPeerDep = function (tree, pkgname) {\n  if (!tree.package.peerDependenciesMeta) return;\n  if (!tree.package.peerDependenciesMeta[pkgname]) return;\n  return !!tree.package.peerDependenciesMeta[pkgname].optional;\n};\nvar validatePeerDeps = exports.validatePeerDeps = function (tree, onInvalid) {\n  if (!tree.package.peerDependencies) return;\n  Object.keys(tree.package.peerDependencies).forEach(function (pkgname) {\n    var version = tree.package.peerDependencies[pkgname];\n    try {\n      var spec = npa.resolve(pkgname, version);\n    } catch (e) {}\n    var match = spec && findRequirement(tree.parent || tree, pkgname, spec);\n    if (!match && !isOptionalPeerDep(tree, pkgname)) onInvalid(tree, pkgname, version);\n  });\n};\nexports.validateAllPeerDeps = function (tree, onInvalid) {\n  validateAllPeerDeps(tree, onInvalid, new Set());\n};\nfunction validateAllPeerDeps(tree, onInvalid, seen) {\n  validate('OFO', arguments);\n  if (seen.has(tree)) return;\n  seen.add(tree);\n  validatePeerDeps(tree, onInvalid);\n  tree.children.forEach(function (child) {\n    validateAllPeerDeps(child, onInvalid, seen);\n  });\n}\n\n// Determine if a module requirement is already met by the tree at or above\n// our current location in the tree.\nvar findRequirement = exports.findRequirement = function (tree, name, requested, requestor) {\n  validate('OSO', [tree, name, requested]);\n  if (!requestor) requestor = tree;\n  var nameMatch = function (child) {\n    return moduleName(child) === name && child.parent && !child.removed;\n  };\n  var versionMatch = function (child) {\n    return doesChildVersionMatch(child, requested, requestor);\n  };\n  if (nameMatch(tree)) {\n    // this *is* the module, but it doesn't match the version, so a\n    // new copy will have to be installed\n    return versionMatch(tree) ? tree : null;\n  }\n  var matches = tree.children.filter(nameMatch);\n  if (matches.length) {\n    matches = matches.filter(versionMatch);\n    // the module exists as a dependent, but the version doesn't match, so\n    // a new copy will have to be installed above here\n    if (matches.length) return matches[0];\n    return null;\n  }\n  if (tree.isTop) return null;\n  if (!preserveSymlinks() && /^[.][.][\\\\/]/.test(path.relative(tree.parent.realpath, tree.realpath))) return null;\n  return findRequirement(tree.parent, name, requested, requestor);\n};\nfunction preserveSymlinks() {\n  if (!('NODE_PRESERVE_SYMLINKS' in process.env)) return false;\n  const value = process.env.NODE_PRESERVE_SYMLINKS;\n  if (value == null || value === '' || value === 'false' || value === 'no' || value === '0') return false;\n  return true;\n}\n\n// Find the highest level in the tree that we can install this module in.\n// If the module isn't installed above us yet, that'd be the very top.\n// If it is, then it's the level below where its installed.\nvar earliestInstallable = exports.earliestInstallable = function (requiredBy, tree, pkg, log) {\n  validate('OOOO', arguments);\n  function undeletedModuleMatches(child) {\n    return !child.removed && moduleName(child) === (pkg._requested && pkg._requested.name || pkg.name);\n  }\n  const undeletedMatches = tree.children.filter(undeletedModuleMatches);\n  if (undeletedMatches.length) {\n    // if there's a conflict with another child AT THE SAME level then we're replacing it, so\n    // mark it as removed and continue with resolution normally.\n    if (tree === requiredBy) {\n      undeletedMatches.forEach(pkg => {\n        if (pkg.fromBundle) reportBundleOverride(pkg, log);\n        removeObsoleteDep(pkg, log);\n      });\n    } else {\n      return null;\n    }\n  }\n\n  // If any of the children of this tree have conflicting\n  // binaries then we need to decline to install this package here.\n  var binaryMatches = pkg.bin && tree.children.some(function (child) {\n    if (child.removed || !child.package.bin) return false;\n    return Object.keys(child.package.bin).some(function (bin) {\n      return pkg.bin[bin];\n    });\n  });\n  if (binaryMatches) return null;\n\n  // if this tree location requested the same module then we KNOW it\n  // isn't compatible because if it were findRequirement would have\n  // found that version.\n  var deps = tree.package.dependencies || {};\n  if (!tree.removed && requiredBy !== tree && deps[pkg.name]) {\n    return null;\n  }\n  var devDeps = tree.package.devDependencies || {};\n  if (tree.isTop && devDeps[pkg.name]) {\n    var requested = childDependencySpecifier(tree, pkg.name, devDeps[pkg.name]);\n    if (!doesChildVersionMatch({\n      package: pkg\n    }, requested, tree)) {\n      return null;\n    }\n  }\n  if (tree.phantomChildren && tree.phantomChildren[pkg.name]) return null;\n  if (tree.isTop) return tree;\n  if (tree.isGlobal) return tree;\n  if (npm.config.get('global-style') && tree.parent.isTop) return tree;\n  if (npm.config.get('legacy-bundling')) return tree;\n  if (!preserveSymlinks() && /^[.][.][\\\\/]/.test(path.relative(tree.parent.realpath, tree.realpath))) return tree;\n  return earliestInstallable(requiredBy, tree.parent, pkg, log) || tree;\n};","map":{"version":3,"names":["BB","require","fs","assert","path","semver","asyncMap","chain","iferr","npa","validate","dezalgo","fetchPackageMetadata","andAddParentToErrors","addBundled","readShrinkwrap","inflateShrinkwrap","inflateBundled","andFinishTracker","npm","flatNameFromTree","createChild","create","resetMetadata","reset","isInstallable","packageId","moduleName","isDevDep","isProdDep","reportOptionalFailure","getSaveType","unixFormatPath","isExtraneous","isRegistry","hasModernMeta","registryTypes","range","version","doesChildVersionMatch","child","requested","requestor","fromShrinkwrap","hasRequiresFromLock","type","fetchSpec","isLink","relative","realpath","fromSw","package","_from","name","toString","gitRange","sameRepo","satisfies","e","subSpec","childReq","_requested","rawSpec","saveSpec","fromReq","childDependencySpecifier","tree","spec","where","resolve","packageRelativePath","exports","computeMetadata","seen","Set","has","add","parent","isTop","location","findChild","kind","req","err","findRequirement","resolveWithExistingModule","deps","dependencies","reqs","swRequires","Object","keys","missingDeps","devDeps","devDependencies","missingDevDeps","children","filter","removed","forEach","isDep","prodVer","devVer","prodSpec","matches","devSpec","addRequiredDep","dep","replaceModuleByPath","replaceModuleByName","removeObsoleteDep","log","silly","pchild","requires","requirement","requiredBy","reqBy","dirname","isInLink","preserveSymlinks","matchingDep","getAllMetadata","args","next","arg","done","stat","join","loadRequestedDeps","saveToDependencies","pkg","depLoaded","resolveWithNewModule","newGroup","tracker","arguments","config","get","isGlobal","childName","computeVersionSpec","userRequired","save","types","saveType","childIsDep","andForEachChild","loadDeps","isNotEmpty","value","getTop","rangeDescriptor","valid","gte","moduleNameMatches","removeDeps","pkgName","toRemove","pkgToRemove","flagAsRemoving","removing","required","removeExtraneous","length","load","er","logs","cmds","ii","push","sortedCmds","sort","installOrder","aa","bb","localeCompare","isDepOptional","_optional","optDeps","optionalDependencies","includeDev","test","prodDeps","includeProd","failedDependency","failed","anyFailed","requireParent","andHandleOptionalErrors","childLog","isFatal","prefetchDeps","skipOptional","finished","fpm","promisify","resolveBranchDeps","then","allDependencies","map","newItem","loaded","now","addDependency","loadDevDeps","logGroup","loadExtraneous","finish","andResolveDeps","versionSpec","swReq","_shrinkwrap","undefined","andInflate","registry","fromBundle","reportBundleOverride","code","top","bundlerId","warnings","some","w","Error","verbose","updatePhantomChildren","current","phantomChildren","_replaceModuleByPath","obj","key","replaceModule","replacing","_replaceModuleByName","matchBy","concat","replaceAt","splice","installable","bundleErr","earliestInstallable","_bundled","knownInstallable","hasBundled","replaced","swErr","isOptionalPeerDep","pkgname","peerDependenciesMeta","optional","validatePeerDeps","onInvalid","peerDependencies","match","validateAllPeerDeps","nameMatch","versionMatch","process","env","NODE_PRESERVE_SYMLINKS","undeletedModuleMatches","undeletedMatches","binaryMatches","bin"],"sources":["/Users/hkateliev/node_modules/npm/lib/install/deps.js"],"sourcesContent":["'use strict'\n\nconst BB = require('bluebird')\n\nvar fs = require('fs')\nvar assert = require('assert')\nvar path = require('path')\nvar semver = require('semver')\nvar asyncMap = require('slide').asyncMap\nvar chain = require('slide').chain\nvar iferr = require('iferr')\nvar npa = require('npm-package-arg')\nvar validate = require('aproba')\nvar dezalgo = require('dezalgo')\nvar fetchPackageMetadata = require('../fetch-package-metadata.js')\nvar andAddParentToErrors = require('./and-add-parent-to-errors.js')\nvar addBundled = require('../fetch-package-metadata.js').addBundled\nvar readShrinkwrap = require('./read-shrinkwrap.js')\nvar inflateShrinkwrap = require('./inflate-shrinkwrap.js')\nvar inflateBundled = require('./inflate-bundled.js')\nvar andFinishTracker = require('./and-finish-tracker.js')\nvar npm = require('../npm.js')\nvar flatNameFromTree = require('./flatten-tree.js').flatNameFromTree\nvar createChild = require('./node.js').create\nvar resetMetadata = require('./node.js').reset\nvar isInstallable = require('./validate-args.js').isInstallable\nvar packageId = require('../utils/package-id.js')\nvar moduleName = require('../utils/module-name.js')\nvar isDevDep = require('./is-dev-dep.js')\nvar isProdDep = require('./is-prod-dep.js')\nvar reportOptionalFailure = require('./report-optional-failure.js')\nvar getSaveType = require('./save.js').getSaveType\nvar unixFormatPath = require('../utils/unix-format-path.js')\nvar isExtraneous = require('./is-extraneous.js')\nvar isRegistry = require('../utils/is-registry.js')\nvar hasModernMeta = require('./has-modern-meta.js')\n\n// The export functions in this module mutate a dependency tree, adding\n// items to them.\n\nvar registryTypes = { range: true, version: true }\n\nfunction doesChildVersionMatch (child, requested, requestor) {\n  if (child.fromShrinkwrap && !child.hasRequiresFromLock) return true\n  // ranges of * ALWAYS count as a match, because when downloading we allow\n  // prereleases to match * if there are ONLY prereleases\n  if (requested.type === 'range' && requested.fetchSpec === '*') return true\n\n  if (requested.type === 'directory') {\n    if (!child.isLink) return false\n    return path.relative(child.realpath, requested.fetchSpec) === ''\n  }\n\n  if (requested.type === 'git' && child.fromShrinkwrap) {\n    const fromSw = child.package._from ? npa(child.package._from) : child.fromShrinkwrap\n    fromSw.name = requested.name // we're only checking specifiers here\n    if (fromSw.toString() === requested.toString()) return true\n  }\n\n  if (requested.type === 'git' && requested.gitRange) {\n    const sameRepo = npa(child.package._from).fetchSpec === requested.fetchSpec\n    try {\n      return sameRepo && semver.satisfies(child.package.version, requested.gitRange, true)\n    } catch (e) {\n      return false\n    }\n  }\n\n  if (requested.type === 'alias') {\n    return doesChildVersionMatch(child, requested.subSpec, requestor)\n  }\n\n  if (!registryTypes[requested.type]) {\n    var childReq = child.package._requested\n    if (childReq) {\n      if (childReq.rawSpec === requested.rawSpec) return true\n      if (childReq.type === requested.type) {\n        if (childReq.saveSpec === requested.saveSpec) return true\n        if ((childReq.fetchSpec === requested.fetchSpec) && requested.type !== 'git') return true\n      }\n    }\n    // If _requested didn't exist OR if it didn't match then we'll try using\n    // _from. We pass it through npa to normalize the specifier.\n    // This can happen when installing from an `npm-shrinkwrap.json` where `_requested` will\n    // be the tarball URL from `resolved` and thus can't match what's in the `package.json`.\n    // In those cases _from, will be preserved and we can compare that to ensure that they\n    // really came from the same sources.\n    // You'll see this scenario happen with at least tags and git dependencies.\n    // Some buggy clients will write spaces into the module name part of a _from.\n    if (child.package._from) {\n      var fromReq = npa(child.package._from)\n      if (fromReq.rawSpec === requested.rawSpec) return true\n      if (fromReq.type === requested.type && fromReq.saveSpec && fromReq.saveSpec === requested.saveSpec) return true\n    }\n    return false\n  }\n  try {\n    return semver.satisfies(child.package.version, requested.fetchSpec, true)\n  } catch (e) {\n    return false\n  }\n}\n\nfunction childDependencySpecifier (tree, name, spec, where) {\n  return npa.resolve(name, spec, where || packageRelativePath(tree))\n}\n\nexports.computeMetadata = computeMetadata\nfunction computeMetadata (tree, seen) {\n  if (!seen) seen = new Set()\n  if (!tree || seen.has(tree)) return\n  seen.add(tree)\n  if (tree.parent == null) {\n    resetMetadata(tree)\n    tree.isTop = true\n  }\n  tree.location = flatNameFromTree(tree)\n\n  function findChild (name, spec, kind) {\n    try {\n      var req = childDependencySpecifier(tree, name, spec)\n    } catch (err) {\n      return\n    }\n    var child = findRequirement(tree, req.name, req)\n    if (child) {\n      resolveWithExistingModule(child, tree)\n      return true\n    }\n  }\n\n  const deps = tree.package.dependencies || {}\n  const reqs = tree.swRequires || {}\n  for (let name of Object.keys(deps)) {\n    if (findChild(name, deps[name])) continue\n    if (name in reqs && findChild(name, reqs[name])) continue\n    tree.missingDeps[name] = deps[name]\n  }\n  if (tree.isTop) {\n    const devDeps = tree.package.devDependencies || {}\n    for (let name of Object.keys(devDeps)) {\n      if (findChild(name, devDeps[name])) continue\n      tree.missingDevDeps[name] = devDeps[name]\n    }\n  }\n\n  tree.children.filter((child) => !child.removed).forEach((child) => computeMetadata(child, seen))\n\n  return tree\n}\n\nfunction isDep (tree, child) {\n  var name = moduleName(child)\n  var prodVer = isProdDep(tree, name)\n  var devVer = isDevDep(tree, name)\n\n  try {\n    var prodSpec = childDependencySpecifier(tree, name, prodVer)\n  } catch (err) {\n    return {isDep: true, isProdDep: false, isDevDep: false}\n  }\n  var matches\n  if (prodSpec) matches = doesChildVersionMatch(child, prodSpec, tree)\n  if (matches) return {isDep: true, isProdDep: prodSpec, isDevDep: false}\n  if (devVer === prodVer) return {isDep: child.fromShrinkwrap, isProdDep: false, isDevDep: false}\n  try {\n    var devSpec = childDependencySpecifier(tree, name, devVer)\n    return {isDep: doesChildVersionMatch(child, devSpec, tree) || child.fromShrinkwrap, isProdDep: false, isDevDep: devSpec}\n  } catch (err) {\n    return {isDep: child.fromShrinkwrap, isProdDep: false, isDevDep: false}\n  }\n}\n\nfunction addRequiredDep (tree, child) {\n  var dep = isDep(tree, child)\n  if (!dep.isDep) return false\n  replaceModuleByPath(child, 'requiredBy', tree)\n  replaceModuleByName(tree, 'requires', child)\n  if (dep.isProdDep && tree.missingDeps) delete tree.missingDeps[moduleName(child)]\n  if (dep.isDevDep && tree.missingDevDeps) delete tree.missingDevDeps[moduleName(child)]\n  return true\n}\n\nexports.removeObsoleteDep = removeObsoleteDep\nfunction removeObsoleteDep (child, log) {\n  if (child.removed) return\n  child.removed = true\n  if (log) {\n    log.silly('removeObsoleteDep', 'removing ' + packageId(child) +\n      ' from the tree as its been replaced by a newer version or is no longer required')\n  }\n  // remove from physical tree\n  if (child.parent) {\n    child.parent.children = child.parent.children.filter(function (pchild) { return pchild !== child })\n  }\n  // remove from logical tree\n  var requires = child.requires || []\n  requires.forEach(function (requirement) {\n    requirement.requiredBy = requirement.requiredBy.filter(function (reqBy) { return reqBy !== child })\n    // we don't just check requirement.requires because that doesn't account\n    // for circular deps.  isExtraneous does.\n    if (isExtraneous(requirement)) removeObsoleteDep(requirement, log)\n  })\n}\n\nexports.packageRelativePath = packageRelativePath\nfunction packageRelativePath (tree) {\n  if (!tree) return ''\n  var requested = tree.package._requested || {}\n  if (requested.type === 'directory') {\n    return requested.fetchSpec\n  } else if (requested.type === 'file') {\n    return path.dirname(requested.fetchSpec)\n  } else if ((tree.isLink || tree.isInLink) && !preserveSymlinks()) {\n    return tree.realpath\n  } else {\n    return tree.path\n  }\n}\n\nfunction matchingDep (tree, name) {\n  if (!tree || !tree.package) return\n  if (tree.package.dependencies && tree.package.dependencies[name]) return tree.package.dependencies[name]\n  if (tree.package.devDependencies && tree.package.devDependencies[name]) return tree.package.devDependencies[name]\n}\n\nexports.getAllMetadata = function (args, tree, where, next) {\n  asyncMap(args, function (arg, done) {\n    let spec\n    try {\n      spec = npa(arg)\n    } catch (e) {\n      return done(e)\n    }\n    if (spec.type !== 'file' && spec.type !== 'directory' && (spec.name == null || spec.rawSpec === '')) {\n      return fs.stat(path.join(arg, 'package.json'), (err) => {\n        if (err) {\n          var version = matchingDep(tree, spec.name)\n          if (version) {\n            try {\n              return fetchPackageMetadata(npa.resolve(spec.name, version), where, done)\n            } catch (e) {\n              return done(e)\n            }\n          } else {\n            return fetchPackageMetadata(spec, where, done)\n          }\n        } else {\n          try {\n            return fetchPackageMetadata(npa('file:' + arg), where, done)\n          } catch (e) {\n            return done(e)\n          }\n        }\n      })\n    } else {\n      return fetchPackageMetadata(spec, where, done)\n    }\n  }, next)\n}\n\n// Add a list of args to tree's top level dependencies\nexports.loadRequestedDeps = function (args, tree, saveToDependencies, log, next) {\n  validate('AOOF', [args, tree, log, next])\n  asyncMap(args, function (pkg, done) {\n    var depLoaded = andAddParentToErrors(tree, done)\n    resolveWithNewModule(pkg, tree, log.newGroup('loadRequestedDeps'), iferr(depLoaded, function (child, tracker) {\n      validate('OO', arguments)\n      if (npm.config.get('global')) {\n        child.isGlobal = true\n      }\n      var childName = moduleName(child)\n      child.saveSpec = computeVersionSpec(tree, child)\n      child.userRequired = true\n      child.save = getSaveType(tree, child)\n      const types = ['dependencies', 'devDependencies', 'optionalDependencies']\n      if (child.save) {\n        tree.package[child.save][childName] = child.saveSpec\n        // Astute readers might notice that this exact same code exists in\n        // save.js under a different guise. That code is responsible for deps\n        // being removed from the final written `package.json`. The removal in\n        // this function is specifically to prevent \"installed as both X and Y\"\n        // warnings when moving an existing dep between different dep fields.\n        //\n        // Or, try it by removing this loop, and do `npm i -P x && npm i -D x`\n        for (let saveType of types) {\n          if (child.save !== saveType) {\n            delete tree.package[saveType][childName]\n          }\n        }\n        if (child.save === 'optionalDependencies') tree.package.dependencies[childName] = child.saveSpec\n      }\n\n      // For things the user asked to install, that aren't a dependency (or\n      // won't be when we're done), flag it as \"depending\" on the user\n      // themselves, so we don't remove it as a dep that no longer exists\n      var childIsDep = addRequiredDep(tree, child)\n      if (!childIsDep) child.userRequired = true\n      depLoaded(null, child, tracker)\n    }))\n  }, andForEachChild(loadDeps, andFinishTracker(log, next)))\n}\n\nfunction isNotEmpty (value) {\n  return value != null && value !== ''\n}\n\nexports.computeVersionSpec = computeVersionSpec\nfunction computeVersionSpec (tree, child) {\n  validate('OO', arguments)\n  var requested\n  var childReq = child.package._requested\n  if (child.isLink) {\n    requested = npa.resolve(moduleName(child), 'file:' + child.realpath, getTop(tree).path)\n  } else if (childReq && (isNotEmpty(childReq.saveSpec) || (isNotEmpty(childReq.rawSpec) && isNotEmpty(childReq.fetchSpec)))) {\n    requested = child.package._requested\n  } else if (child.package._from) {\n    requested = npa(child.package._from, tree.path)\n  } else if (child.name && child.name !== child.package.name) {\n    requested = npa.resolve(child.name, `npm:${child.package.name}@${child.package.version})`)\n  } else {\n    requested = npa.resolve(child.package.name, child.package.version)\n  }\n  if (isRegistry(requested)) {\n    var version = child.package.version\n    var rangeDescriptor = ''\n    if (semver.valid(version, true) &&\n        semver.gte(version, '0.1.0', true) &&\n        !npm.config.get('save-exact')) {\n      rangeDescriptor = npm.config.get('save-prefix')\n    }\n    if (requested.type === 'alias') {\n      rangeDescriptor = `npm:${requested.subSpec.name}@${rangeDescriptor}`\n    }\n    return rangeDescriptor + version\n  } else if (requested.type === 'directory' || requested.type === 'file') {\n    return 'file:' + unixFormatPath(path.relative(getTop(tree).path, requested.fetchSpec))\n  } else {\n    return requested.saveSpec || requested.rawSpec\n  }\n}\n\nfunction moduleNameMatches (name) {\n  return function (child) { return moduleName(child) === name }\n}\n\n// while this implementation does not require async calling, doing so\n// gives this a consistent interface with loadDeps et al\nexports.removeDeps = function (args, tree, saveToDependencies, next) {\n  validate('AOSF|AOZF', [args, tree, saveToDependencies, next])\n  for (let pkg of args) {\n    var pkgName = moduleName(pkg)\n    var toRemove = tree.children.filter(moduleNameMatches(pkgName))\n    var pkgToRemove = toRemove[0] || createChild({name: pkgName})\n    var saveType = getSaveType(tree, pkg) || 'dependencies'\n    if (tree.isTop && saveToDependencies) {\n      pkgToRemove.save = saveType\n    }\n    if (tree.package[saveType][pkgName]) {\n      delete tree.package[saveType][pkgName]\n      if (saveType === 'optionalDependencies' && tree.package.dependencies[pkgName]) {\n        delete tree.package.dependencies[pkgName]\n      }\n    }\n    replaceModuleByPath(tree, 'removedChildren', pkgToRemove)\n    for (let parent of pkgToRemove.requiredBy) {\n      parent.requires = parent.requires.filter((child) => child !== pkgToRemove)\n    }\n    pkgToRemove.requiredBy = pkgToRemove.requiredBy.filter((parent) => parent !== tree)\n    flagAsRemoving(pkgToRemove)\n  }\n  next()\n}\n\nfunction flagAsRemoving (toRemove, seen) {\n  if (!seen) seen = new Set()\n  if (seen.has(toRemove)) return\n  seen.add(toRemove)\n  toRemove.removing = true\n  toRemove.requires.forEach((required) => {\n    flagAsRemoving(required, seen)\n  })\n}\n\nexports.removeExtraneous = function (args, tree, next) {\n  for (let pkg of args) {\n    var pkgName = moduleName(pkg)\n    var toRemove = tree.children.filter(moduleNameMatches(pkgName))\n    if (toRemove.length) {\n      removeObsoleteDep(toRemove[0])\n    }\n  }\n  next()\n}\n\nfunction andForEachChild (load, next) {\n  validate('F', [next])\n  next = dezalgo(next)\n  return function (er, children, logs) {\n    // when children is empty, logs won't be passed in at all (asyncMap is weird)\n    // so shortcircuit before arg validation\n    if (!er && (!children || children.length === 0)) return next()\n    validate('EAA', arguments)\n    if (er) return next(er)\n    assert(children.length === logs.length)\n    var cmds = []\n    for (var ii = 0; ii < children.length; ++ii) {\n      cmds.push([load, children[ii], logs[ii]])\n    }\n    var sortedCmds = cmds.sort(function installOrder (aa, bb) {\n      return moduleName(aa[1]).localeCompare(moduleName(bb[1]))\n    })\n    chain(sortedCmds, next)\n  }\n}\n\nfunction isDepOptional (tree, name, pkg) {\n  if (pkg.package && pkg.package._optional) return true\n  const optDeps = tree.package.optionalDependencies\n  if (optDeps && optDeps[name] != null) return true\n\n  const devDeps = tree.package.devDependencies\n  if (devDeps && devDeps[name] != null) {\n    const includeDev = npm.config.get('dev') ||\n      (!/^prod(uction)?$/.test(npm.config.get('only')) && !npm.config.get('production')) ||\n      /^dev(elopment)?$/.test(npm.config.get('only')) ||\n      /^dev(elopment)?$/.test(npm.config.get('also'))\n    return !includeDev\n  }\n  const prodDeps = tree.package.dependencies\n  if (prodDeps && prodDeps[name] != null) {\n    const includeProd = !/^dev(elopment)?$/.test(npm.config.get('only'))\n    return !includeProd\n  }\n  return false\n}\n\nexports.failedDependency = failedDependency\nfunction failedDependency (tree, name, pkg) {\n  if (name) {\n    if (isDepOptional(tree, name, pkg || {})) {\n      return false\n    }\n  }\n\n  tree.failed = true\n\n  if (tree.isTop) return true\n\n  if (tree.userRequired) return true\n\n  if (!tree.requiredBy) return false\n\n  let anyFailed = false\n  for (var ii = 0; ii < tree.requiredBy.length; ++ii) {\n    var requireParent = tree.requiredBy[ii]\n    if (failedDependency(requireParent, moduleName(tree), tree)) {\n      anyFailed = true\n    }\n  }\n  return anyFailed\n}\n\nfunction andHandleOptionalErrors (log, tree, name, done) {\n  validate('OOSF', arguments)\n  return function (er, child, childLog) {\n    if (!er) validate('OO', [child, childLog])\n    if (!er) return done(er, child, childLog)\n    var isFatal = failedDependency(tree, name)\n    if (er && !isFatal) {\n      reportOptionalFailure(tree, name, er)\n      return done()\n    } else {\n      return done(er, child, childLog)\n    }\n  }\n}\n\nexports.prefetchDeps = prefetchDeps\nfunction prefetchDeps (tree, deps, log, next) {\n  validate('OOOF', arguments)\n  var skipOptional = !npm.config.get('optional')\n  var seen = new Set()\n  const finished = andFinishTracker(log, next)\n  const fpm = BB.promisify(fetchPackageMetadata)\n  resolveBranchDeps(tree.package, deps).then(\n    () => finished(), finished\n  )\n\n  function resolveBranchDeps (pkg, deps) {\n    return BB.resolve(null).then(() => {\n      var allDependencies = Object.keys(deps).map((dep) => {\n        return npa.resolve(dep, deps[dep])\n      }).filter((dep) => {\n        return isRegistry(dep) &&\n               !seen.has(dep.toString()) &&\n               !findRequirement(tree, dep.name, dep)\n      })\n      if (skipOptional) {\n        var optDeps = pkg.optionalDependencies || {}\n        allDependencies = allDependencies.filter((dep) => !optDeps[dep.name])\n      }\n      return BB.map(allDependencies, (dep) => {\n        seen.add(dep.toString())\n        return fpm(dep, '', {tracker: log.newItem('fetchMetadata')}).then(\n          (pkg) => {\n            return pkg && pkg.dependencies && resolveBranchDeps(pkg, pkg.dependencies)\n          },\n          () => null\n        )\n      })\n    })\n  }\n}\n\n// Load any missing dependencies in the given tree\nexports.loadDeps = loadDeps\nfunction loadDeps (tree, log, next) {\n  validate('OOF', arguments)\n  if (tree.loaded || (tree.parent && tree.parent.failed) || tree.removed) return andFinishTracker.now(log, next)\n  if (tree.parent) tree.loaded = true\n  if (!tree.package.dependencies) tree.package.dependencies = {}\n  asyncMap(Object.keys(tree.package.dependencies), function (dep, done) {\n    var version = tree.package.dependencies[dep]\n    addDependency(dep, version, tree, log.newGroup('loadDep:' + dep), andHandleOptionalErrors(log, tree, dep, done))\n  }, andForEachChild(loadDeps, andFinishTracker(log, next)))\n}\n\n// Load development dependencies into the given tree\nexports.loadDevDeps = function (tree, log, next) {\n  validate('OOF', arguments)\n  if (!tree.package.devDependencies) return andFinishTracker.now(log, next)\n  asyncMap(Object.keys(tree.package.devDependencies), function (dep, done) {\n    // things defined as both dev dependencies and regular dependencies are treated\n    // as the former\n    if (tree.package.dependencies[dep]) return done()\n\n    var logGroup = log.newGroup('loadDevDep:' + dep)\n    addDependency(dep, tree.package.devDependencies[dep], tree, logGroup, andHandleOptionalErrors(log, tree, dep, done))\n  }, andForEachChild(loadDeps, andFinishTracker(log, next)))\n}\n\nvar loadExtraneous = exports.loadExtraneous = function (tree, log, next) {\n  var seen = new Set()\n\n  function loadExtraneous (tree) {\n    if (seen.has(tree)) return\n    seen.add(tree)\n    for (var child of tree.children) {\n      if (child.loaded) continue\n      resolveWithExistingModule(child, tree)\n      loadExtraneous(child)\n    }\n  }\n  loadExtraneous(tree)\n  log.finish()\n  next()\n}\n\nexports.loadExtraneous.andResolveDeps = function (tree, log, next) {\n  validate('OOF', arguments)\n  // For canonicalized trees (eg from shrinkwrap) we don't want to bother\n  // resolving the dependencies of extraneous deps.\n  if (tree.loaded) return loadExtraneous(tree, log, next)\n  asyncMap(tree.children.filter(function (child) { return !child.loaded }), function (child, done) {\n    resolveWithExistingModule(child, tree)\n    done(null, child, log)\n  }, andForEachChild(loadDeps, andFinishTracker(log, next)))\n}\n\nfunction addDependency (name, versionSpec, tree, log, done) {\n  validate('SSOOF', arguments)\n  var next = andAddParentToErrors(tree, done)\n  try {\n    var req = childDependencySpecifier(tree, name, versionSpec)\n    if (tree.swRequires && tree.swRequires[name]) {\n      var swReq = childDependencySpecifier(tree, name, tree.swRequires[name])\n    }\n  } catch (err) {\n    return done(err)\n  }\n  var child = findRequirement(tree, name, req)\n  if (!child && swReq) child = findRequirement(tree, name, swReq)\n  if (hasModernMeta(child)) {\n    resolveWithExistingModule(child, tree)\n    if (child.package._shrinkwrap === undefined) {\n      readShrinkwrap.andInflate(child, function (er) { next(er, child, log) })\n    } else {\n      next(null, child, log)\n    }\n  } else {\n    if (child) {\n      if (req.registry) {\n        req = childDependencySpecifier(tree, name, child.package.version)\n      }\n      if (child.fromBundle) reportBundleOverride(child, log)\n      removeObsoleteDep(child, log)\n    }\n    fetchPackageMetadata(req, packageRelativePath(tree), {tracker: log.newItem('fetchMetadata')}, iferr(next, function (pkg) {\n      resolveWithNewModule(pkg, tree, log, next)\n    }))\n  }\n}\n\nfunction getTop (pkg) {\n  const seen = new Set()\n  while (pkg.parent && !seen.has(pkg.parent)) {\n    pkg = pkg.parent\n    seen.add(pkg)\n  }\n  return pkg\n}\n\nfunction reportBundleOverride (child, log) {\n  const code = 'EBUNDLEOVERRIDE'\n  const top = getTop(child.fromBundle)\n  const bundlerId = packageId(child.fromBundle)\n  if (!top.warnings.some((w) => {\n    return w.code === code\n  })) {\n    const err = new Error(`${bundlerId} had bundled packages that do not match the required version(s). They have been replaced with non-bundled versions.`)\n    err.code = code\n    top.warnings.push(err)\n  }\n  if (log) log.verbose('bundle', `${code}: Replacing ${bundlerId}'s bundled version of ${moduleName(child)} with ${packageId(child)}.`)\n}\n\nfunction resolveWithExistingModule (child, tree) {\n  validate('OO', arguments)\n  addRequiredDep(tree, child)\n  if (tree.parent && child.parent !== tree) updatePhantomChildren(tree.parent, child)\n}\n\nvar updatePhantomChildren = exports.updatePhantomChildren = function (current, child) {\n  validate('OO', arguments)\n  while (current && current !== child.parent) {\n    if (!current.phantomChildren) current.phantomChildren = {}\n    current.phantomChildren[moduleName(child)] = child\n    current = current.parent\n  }\n}\n\nexports._replaceModuleByPath = replaceModuleByPath\nfunction replaceModuleByPath (obj, key, child) {\n  return replaceModule(obj, key, child, function (replacing, child) {\n    return replacing.path === child.path\n  })\n}\n\nexports._replaceModuleByName = replaceModuleByName\nfunction replaceModuleByName (obj, key, child) {\n  var childName = moduleName(child)\n  return replaceModule(obj, key, child, function (replacing, child) {\n    return moduleName(replacing) === childName\n  })\n}\n\nfunction replaceModule (obj, key, child, matchBy) {\n  validate('OSOF', arguments)\n  if (!obj[key]) obj[key] = []\n  // we replace children with a new array object instead of mutating it\n  // because mutating it results in weird failure states.\n  // I would very much like to know _why_ this is. =/\n  var children = [].concat(obj[key])\n  for (var replaceAt = 0; replaceAt < children.length; ++replaceAt) {\n    if (matchBy(children[replaceAt], child)) break\n  }\n  var replacing = children.splice(replaceAt, 1, child)\n  obj[key] = children\n  return replacing[0]\n}\n\nfunction resolveWithNewModule (pkg, tree, log, next) {\n  validate('OOOF', arguments)\n\n  log.silly('resolveWithNewModule', packageId(pkg), 'checking installable status')\n  return isInstallable(tree, pkg, (err) => {\n    let installable = !err\n    addBundled(pkg, (bundleErr) => {\n      var parent = earliestInstallable(tree, tree, pkg, log) || tree\n      var isLink = pkg._requested.type === 'directory'\n      var name = pkg._requested.name || pkg.name\n      var child = createChild({\n        name,\n        package: pkg,\n        parent: parent,\n        path: path.join(parent.isLink ? parent.realpath : parent.path, 'node_modules', name),\n        realpath: isLink ? pkg._requested.fetchSpec : path.join(parent.realpath, 'node_modules', name),\n        children: pkg._bundled || [],\n        isLink: isLink,\n        isInLink: parent.isLink,\n        knownInstallable: installable\n      })\n      if (!installable || bundleErr) child.failed = true\n      delete pkg._bundled\n      var hasBundled = child.children.length\n\n      var replaced = replaceModuleByName(parent, 'children', child)\n      if (replaced) {\n        if (replaced.fromBundle) reportBundleOverride(replaced, log)\n        removeObsoleteDep(replaced)\n      }\n      addRequiredDep(tree, child)\n      child.location = flatNameFromTree(child)\n\n      if (tree.parent && parent !== tree) updatePhantomChildren(tree.parent, child)\n\n      if (hasBundled) {\n        inflateBundled(child, child, child.children)\n      }\n\n      if (pkg._shrinkwrap && pkg._shrinkwrap.dependencies) {\n        return inflateShrinkwrap(child, pkg._shrinkwrap, (swErr) => {\n          if (swErr) child.failed = true\n          next(err || bundleErr || swErr, child, log)\n        })\n      }\n      next(err || bundleErr, child, log)\n    })\n  })\n}\n\nvar isOptionalPeerDep = exports.isOptionalPeerDep = function (tree, pkgname) {\n  if (!tree.package.peerDependenciesMeta) return\n  if (!tree.package.peerDependenciesMeta[pkgname]) return\n  return !!tree.package.peerDependenciesMeta[pkgname].optional\n}\n\nvar validatePeerDeps = exports.validatePeerDeps = function (tree, onInvalid) {\n  if (!tree.package.peerDependencies) return\n  Object.keys(tree.package.peerDependencies).forEach(function (pkgname) {\n    var version = tree.package.peerDependencies[pkgname]\n    try {\n      var spec = npa.resolve(pkgname, version)\n    } catch (e) {}\n    var match = spec && findRequirement(tree.parent || tree, pkgname, spec)\n    if (!match && !isOptionalPeerDep(tree, pkgname)) onInvalid(tree, pkgname, version)\n  })\n}\n\nexports.validateAllPeerDeps = function (tree, onInvalid) {\n  validateAllPeerDeps(tree, onInvalid, new Set())\n}\n\nfunction validateAllPeerDeps (tree, onInvalid, seen) {\n  validate('OFO', arguments)\n  if (seen.has(tree)) return\n  seen.add(tree)\n  validatePeerDeps(tree, onInvalid)\n  tree.children.forEach(function (child) { validateAllPeerDeps(child, onInvalid, seen) })\n}\n\n// Determine if a module requirement is already met by the tree at or above\n// our current location in the tree.\nvar findRequirement = exports.findRequirement = function (tree, name, requested, requestor) {\n  validate('OSO', [tree, name, requested])\n  if (!requestor) requestor = tree\n  var nameMatch = function (child) {\n    return moduleName(child) === name && child.parent && !child.removed\n  }\n  var versionMatch = function (child) {\n    return doesChildVersionMatch(child, requested, requestor)\n  }\n  if (nameMatch(tree)) {\n    // this *is* the module, but it doesn't match the version, so a\n    // new copy will have to be installed\n    return versionMatch(tree) ? tree : null\n  }\n\n  var matches = tree.children.filter(nameMatch)\n  if (matches.length) {\n    matches = matches.filter(versionMatch)\n    // the module exists as a dependent, but the version doesn't match, so\n    // a new copy will have to be installed above here\n    if (matches.length) return matches[0]\n    return null\n  }\n  if (tree.isTop) return null\n  if (!preserveSymlinks() && /^[.][.][\\\\/]/.test(path.relative(tree.parent.realpath, tree.realpath))) return null\n  return findRequirement(tree.parent, name, requested, requestor)\n}\n\nfunction preserveSymlinks () {\n  if (!('NODE_PRESERVE_SYMLINKS' in process.env)) return false\n  const value = process.env.NODE_PRESERVE_SYMLINKS\n  if (value == null || value === '' || value === 'false' || value === 'no' || value === '0') return false\n  return true\n}\n\n// Find the highest level in the tree that we can install this module in.\n// If the module isn't installed above us yet, that'd be the very top.\n// If it is, then it's the level below where its installed.\nvar earliestInstallable = exports.earliestInstallable = function (requiredBy, tree, pkg, log) {\n  validate('OOOO', arguments)\n\n  function undeletedModuleMatches (child) {\n    return !child.removed && moduleName(child) === ((pkg._requested && pkg._requested.name) || pkg.name)\n  }\n  const undeletedMatches = tree.children.filter(undeletedModuleMatches)\n  if (undeletedMatches.length) {\n    // if there's a conflict with another child AT THE SAME level then we're replacing it, so\n    // mark it as removed and continue with resolution normally.\n    if (tree === requiredBy) {\n      undeletedMatches.forEach((pkg) => {\n        if (pkg.fromBundle) reportBundleOverride(pkg, log)\n        removeObsoleteDep(pkg, log)\n      })\n    } else {\n      return null\n    }\n  }\n\n  // If any of the children of this tree have conflicting\n  // binaries then we need to decline to install this package here.\n  var binaryMatches = pkg.bin && tree.children.some(function (child) {\n    if (child.removed || !child.package.bin) return false\n    return Object.keys(child.package.bin).some(function (bin) {\n      return pkg.bin[bin]\n    })\n  })\n\n  if (binaryMatches) return null\n\n  // if this tree location requested the same module then we KNOW it\n  // isn't compatible because if it were findRequirement would have\n  // found that version.\n  var deps = tree.package.dependencies || {}\n  if (!tree.removed && requiredBy !== tree && deps[pkg.name]) {\n    return null\n  }\n\n  var devDeps = tree.package.devDependencies || {}\n  if (tree.isTop && devDeps[pkg.name]) {\n    var requested = childDependencySpecifier(tree, pkg.name, devDeps[pkg.name])\n    if (!doesChildVersionMatch({package: pkg}, requested, tree)) {\n      return null\n    }\n  }\n\n  if (tree.phantomChildren && tree.phantomChildren[pkg.name]) return null\n\n  if (tree.isTop) return tree\n  if (tree.isGlobal) return tree\n\n  if (npm.config.get('global-style') && tree.parent.isTop) return tree\n  if (npm.config.get('legacy-bundling')) return tree\n\n  if (!preserveSymlinks() && /^[.][.][\\\\/]/.test(path.relative(tree.parent.realpath, tree.realpath))) return tree\n\n  return (earliestInstallable(requiredBy, tree.parent, pkg, log) || tree)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}