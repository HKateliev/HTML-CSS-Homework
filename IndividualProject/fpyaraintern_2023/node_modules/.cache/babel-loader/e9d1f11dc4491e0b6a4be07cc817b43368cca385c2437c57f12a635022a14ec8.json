{"ast":null,"code":"'use strict';\n\nconst URL = require('url').URL;\nexports.getFundingInfo = getFundingInfo;\nexports.retrieveFunding = retrieveFunding;\nexports.validFundingField = validFundingField;\nconst flatCacheSymbol = Symbol('npm flat cache');\nexports.flatCacheSymbol = flatCacheSymbol;\n\n// supports object funding and string shorthand, or an array of these\n// if original was an array, returns an array; else returns the lone item\nfunction retrieveFunding(funding) {\n  const sources = [].concat(funding || []).map(item => typeof item === 'string' ? {\n    url: item\n  } : item);\n  return Array.isArray(funding) ? sources : sources[0];\n}\n\n// Is the value of a `funding` property of a `package.json`\n// a valid type+url for `npm fund` to display?\nfunction validFundingField(funding) {\n  if (!funding) return false;\n  if (Array.isArray(funding)) {\n    return funding.every(f => !Array.isArray(f) && validFundingField(f));\n  }\n  try {\n    var parsed = new URL(funding.url || funding);\n  } catch (error) {\n    return false;\n  }\n  if (parsed.protocol !== 'https:' && parsed.protocol !== 'http:') return false;\n  return Boolean(parsed.host);\n}\nconst empty = () => Object.create(null);\nfunction getFundingInfo(idealTree, opts) {\n  let packageWithFundingCount = 0;\n  const flat = empty();\n  const seen = new Set();\n  const {\n    countOnly\n  } = opts || {};\n  const _trailingDependencies = Symbol('trailingDependencies');\n  function tracked(name, version) {\n    const key = String(name) + String(version);\n    if (seen.has(key)) {\n      return true;\n    }\n    seen.add(key);\n  }\n  function retrieveDependencies(dependencies) {\n    const trailing = dependencies[_trailingDependencies];\n    if (trailing) {\n      return Object.assign(empty(), dependencies, trailing);\n    }\n    return dependencies;\n  }\n  function hasDependencies(dependencies) {\n    return dependencies && (Object.keys(dependencies).length || dependencies[_trailingDependencies]);\n  }\n  function addToFlatCache(funding, dep) {\n    [].concat(funding || []).forEach(f => {\n      const key = f.url;\n      if (!Array.isArray(flat[key])) {\n        flat[key] = [];\n      }\n      flat[key].push(dep);\n    });\n  }\n  function attachFundingInfo(target, funding, dep) {\n    if (funding && validFundingField(funding)) {\n      target.funding = retrieveFunding(funding);\n      if (!countOnly) {\n        addToFlatCache(target.funding, dep);\n      }\n      packageWithFundingCount++;\n    }\n  }\n  function getFundingDependencies(tree) {\n    const deps = tree && tree.dependencies;\n    if (!deps) return empty();\n    const directDepsWithFunding = Object.keys(deps).map(key => {\n      const dep = deps[key];\n      const {\n        name,\n        funding,\n        version\n      } = dep;\n\n      // avoids duplicated items within the funding tree\n      if (tracked(name, version)) return empty();\n      const fundingItem = {};\n      if (version) {\n        fundingItem.version = version;\n      }\n      attachFundingInfo(fundingItem, funding, dep);\n      return {\n        dep,\n        fundingItem\n      };\n    });\n    return directDepsWithFunding.reduce((res, _ref, i) => {\n      let {\n        dep: directDep,\n        fundingItem\n      } = _ref;\n      if (!fundingItem || fundingItem.length === 0) return res;\n\n      // recurse\n      const transitiveDependencies = directDep.dependencies && Object.keys(directDep.dependencies).length > 0 && getFundingDependencies(directDep);\n\n      // if we're only counting items there's no need\n      // to add all the data to the resulting object\n      if (countOnly) return null;\n      if (hasDependencies(transitiveDependencies)) {\n        fundingItem.dependencies = retrieveDependencies(transitiveDependencies);\n      }\n      if (fundingItem.funding && fundingItem.funding.length !== 0) {\n        res[directDep.name] = fundingItem;\n      } else if (fundingItem.dependencies) {\n        res[_trailingDependencies] = Object.assign(empty(), res[_trailingDependencies], fundingItem.dependencies);\n      }\n      return res;\n    }, countOnly ? null : empty());\n  }\n  const idealTreeDependencies = getFundingDependencies(idealTree);\n  const result = {\n    length: packageWithFundingCount\n  };\n  if (!countOnly) {\n    result.name = idealTree.name || idealTree.path;\n    if (idealTree && idealTree.version) {\n      result.version = idealTree.version;\n    }\n    if (idealTree && idealTree.funding) {\n      result.funding = retrieveFunding(idealTree.funding);\n    }\n    result.dependencies = retrieveDependencies(idealTreeDependencies);\n    result[flatCacheSymbol] = flat;\n  }\n  return result;\n}","map":{"version":3,"names":["URL","require","exports","getFundingInfo","retrieveFunding","validFundingField","flatCacheSymbol","Symbol","funding","sources","concat","map","item","url","Array","isArray","every","f","parsed","error","protocol","Boolean","host","empty","Object","create","idealTree","opts","packageWithFundingCount","flat","seen","Set","countOnly","_trailingDependencies","tracked","name","version","key","String","has","add","retrieveDependencies","dependencies","trailing","assign","hasDependencies","keys","length","addToFlatCache","dep","forEach","push","attachFundingInfo","target","getFundingDependencies","tree","deps","directDepsWithFunding","fundingItem","reduce","res","_ref","i","directDep","transitiveDependencies","idealTreeDependencies","result","path"],"sources":["/Users/hkateliev/node_modules/npm/lib/utils/funding.js"],"sourcesContent":["'use strict'\n\nconst URL = require('url').URL\n\nexports.getFundingInfo = getFundingInfo\nexports.retrieveFunding = retrieveFunding\nexports.validFundingField = validFundingField\n\nconst flatCacheSymbol = Symbol('npm flat cache')\nexports.flatCacheSymbol = flatCacheSymbol\n\n// supports object funding and string shorthand, or an array of these\n// if original was an array, returns an array; else returns the lone item\nfunction retrieveFunding (funding) {\n  const sources = [].concat(funding || []).map(item => (\n    typeof item === 'string'\n      ? { url: item }\n      : item\n  ))\n  return Array.isArray(funding) ? sources : sources[0]\n}\n\n// Is the value of a `funding` property of a `package.json`\n// a valid type+url for `npm fund` to display?\nfunction validFundingField (funding) {\n  if (!funding) return false\n\n  if (Array.isArray(funding)) {\n    return funding.every(f => !Array.isArray(f) && validFundingField(f))\n  }\n\n  try {\n    var parsed = new URL(funding.url || funding)\n  } catch (error) {\n    return false\n  }\n\n  if (\n    parsed.protocol !== 'https:' &&\n    parsed.protocol !== 'http:'\n  ) return false\n\n  return Boolean(parsed.host)\n}\n\nconst empty = () => Object.create(null)\n\nfunction getFundingInfo (idealTree, opts) {\n  let packageWithFundingCount = 0\n  const flat = empty()\n  const seen = new Set()\n  const { countOnly } = opts || {}\n  const _trailingDependencies = Symbol('trailingDependencies')\n\n  function tracked (name, version) {\n    const key = String(name) + String(version)\n    if (seen.has(key)) {\n      return true\n    }\n    seen.add(key)\n  }\n\n  function retrieveDependencies (dependencies) {\n    const trailing = dependencies[_trailingDependencies]\n\n    if (trailing) {\n      return Object.assign(\n        empty(),\n        dependencies,\n        trailing\n      )\n    }\n\n    return dependencies\n  }\n\n  function hasDependencies (dependencies) {\n    return dependencies && (\n      Object.keys(dependencies).length ||\n      dependencies[_trailingDependencies]\n    )\n  }\n\n  function addToFlatCache (funding, dep) {\n    [].concat(funding || []).forEach((f) => {\n      const key = f.url\n      if (!Array.isArray(flat[key])) {\n        flat[key] = []\n      }\n      flat[key].push(dep)\n    })\n  }\n\n  function attachFundingInfo (target, funding, dep) {\n    if (funding && validFundingField(funding)) {\n      target.funding = retrieveFunding(funding)\n      if (!countOnly) {\n        addToFlatCache(target.funding, dep)\n      }\n\n      packageWithFundingCount++\n    }\n  }\n\n  function getFundingDependencies (tree) {\n    const deps = tree && tree.dependencies\n    if (!deps) return empty()\n\n    const directDepsWithFunding = Object.keys(deps).map((key) => {\n      const dep = deps[key]\n      const { name, funding, version } = dep\n\n      // avoids duplicated items within the funding tree\n      if (tracked(name, version)) return empty()\n\n      const fundingItem = {}\n\n      if (version) {\n        fundingItem.version = version\n      }\n\n      attachFundingInfo(fundingItem, funding, dep)\n\n      return {\n        dep,\n        fundingItem\n      }\n    })\n\n    return directDepsWithFunding.reduce((res, { dep: directDep, fundingItem }, i) => {\n      if (!fundingItem || fundingItem.length === 0) return res\n\n      // recurse\n      const transitiveDependencies = directDep.dependencies &&\n        Object.keys(directDep.dependencies).length > 0 &&\n        getFundingDependencies(directDep)\n\n      // if we're only counting items there's no need\n      // to add all the data to the resulting object\n      if (countOnly) return null\n\n      if (hasDependencies(transitiveDependencies)) {\n        fundingItem.dependencies = retrieveDependencies(transitiveDependencies)\n      }\n\n      if (fundingItem.funding && fundingItem.funding.length !== 0) {\n        res[directDep.name] = fundingItem\n      } else if (fundingItem.dependencies) {\n        res[_trailingDependencies] =\n          Object.assign(\n            empty(),\n            res[_trailingDependencies],\n            fundingItem.dependencies\n          )\n      }\n\n      return res\n    }, countOnly ? null : empty())\n  }\n\n  const idealTreeDependencies = getFundingDependencies(idealTree)\n  const result = {\n    length: packageWithFundingCount\n  }\n\n  if (!countOnly) {\n    result.name = idealTree.name || idealTree.path\n\n    if (idealTree && idealTree.version) {\n      result.version = idealTree.version\n    }\n\n    if (idealTree && idealTree.funding) {\n      result.funding = retrieveFunding(idealTree.funding)\n    }\n\n    result.dependencies = retrieveDependencies(idealTreeDependencies)\n\n    result[flatCacheSymbol] = flat\n  }\n\n  return result\n}\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,GAAG,GAAGC,OAAO,CAAC,KAAK,CAAC,CAACD,GAAG;AAE9BE,OAAO,CAACC,cAAc,GAAGA,cAAc;AACvCD,OAAO,CAACE,eAAe,GAAGA,eAAe;AACzCF,OAAO,CAACG,iBAAiB,GAAGA,iBAAiB;AAE7C,MAAMC,eAAe,GAAGC,MAAM,CAAC,gBAAgB,CAAC;AAChDL,OAAO,CAACI,eAAe,GAAGA,eAAe;;AAEzC;AACA;AACA,SAASF,eAAeA,CAAEI,OAAO,EAAE;EACjC,MAAMC,OAAO,GAAG,EAAE,CAACC,MAAM,CAACF,OAAO,IAAI,EAAE,CAAC,CAACG,GAAG,CAACC,IAAI,IAC/C,OAAOA,IAAI,KAAK,QAAQ,GACpB;IAAEC,GAAG,EAAED;EAAK,CAAC,GACbA,IACL,CAAC;EACF,OAAOE,KAAK,CAACC,OAAO,CAACP,OAAO,CAAC,GAAGC,OAAO,GAAGA,OAAO,CAAC,CAAC,CAAC;AACtD;;AAEA;AACA;AACA,SAASJ,iBAAiBA,CAAEG,OAAO,EAAE;EACnC,IAAI,CAACA,OAAO,EAAE,OAAO,KAAK;EAE1B,IAAIM,KAAK,CAACC,OAAO,CAACP,OAAO,CAAC,EAAE;IAC1B,OAAOA,OAAO,CAACQ,KAAK,CAACC,CAAC,IAAI,CAACH,KAAK,CAACC,OAAO,CAACE,CAAC,CAAC,IAAIZ,iBAAiB,CAACY,CAAC,CAAC,CAAC;EACtE;EAEA,IAAI;IACF,IAAIC,MAAM,GAAG,IAAIlB,GAAG,CAACQ,OAAO,CAACK,GAAG,IAAIL,OAAO,CAAC;EAC9C,CAAC,CAAC,OAAOW,KAAK,EAAE;IACd,OAAO,KAAK;EACd;EAEA,IACED,MAAM,CAACE,QAAQ,KAAK,QAAQ,IAC5BF,MAAM,CAACE,QAAQ,KAAK,OAAO,EAC3B,OAAO,KAAK;EAEd,OAAOC,OAAO,CAACH,MAAM,CAACI,IAAI,CAAC;AAC7B;AAEA,MAAMC,KAAK,GAAGA,CAAA,KAAMC,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;AAEvC,SAAStB,cAAcA,CAAEuB,SAAS,EAAEC,IAAI,EAAE;EACxC,IAAIC,uBAAuB,GAAG,CAAC;EAC/B,MAAMC,IAAI,GAAGN,KAAK,EAAE;EACpB,MAAMO,IAAI,GAAG,IAAIC,GAAG,EAAE;EACtB,MAAM;IAAEC;EAAU,CAAC,GAAGL,IAAI,IAAI,CAAC,CAAC;EAChC,MAAMM,qBAAqB,GAAG1B,MAAM,CAAC,sBAAsB,CAAC;EAE5D,SAAS2B,OAAOA,CAAEC,IAAI,EAAEC,OAAO,EAAE;IAC/B,MAAMC,GAAG,GAAGC,MAAM,CAACH,IAAI,CAAC,GAAGG,MAAM,CAACF,OAAO,CAAC;IAC1C,IAAIN,IAAI,CAACS,GAAG,CAACF,GAAG,CAAC,EAAE;MACjB,OAAO,IAAI;IACb;IACAP,IAAI,CAACU,GAAG,CAACH,GAAG,CAAC;EACf;EAEA,SAASI,oBAAoBA,CAAEC,YAAY,EAAE;IAC3C,MAAMC,QAAQ,GAAGD,YAAY,CAACT,qBAAqB,CAAC;IAEpD,IAAIU,QAAQ,EAAE;MACZ,OAAOnB,MAAM,CAACoB,MAAM,CAClBrB,KAAK,EAAE,EACPmB,YAAY,EACZC,QAAQ,CACT;IACH;IAEA,OAAOD,YAAY;EACrB;EAEA,SAASG,eAAeA,CAAEH,YAAY,EAAE;IACtC,OAAOA,YAAY,KACjBlB,MAAM,CAACsB,IAAI,CAACJ,YAAY,CAAC,CAACK,MAAM,IAChCL,YAAY,CAACT,qBAAqB,CAAC,CACpC;EACH;EAEA,SAASe,cAAcA,CAAExC,OAAO,EAAEyC,GAAG,EAAE;IACrC,EAAE,CAACvC,MAAM,CAACF,OAAO,IAAI,EAAE,CAAC,CAAC0C,OAAO,CAAEjC,CAAC,IAAK;MACtC,MAAMoB,GAAG,GAAGpB,CAAC,CAACJ,GAAG;MACjB,IAAI,CAACC,KAAK,CAACC,OAAO,CAACc,IAAI,CAACQ,GAAG,CAAC,CAAC,EAAE;QAC7BR,IAAI,CAACQ,GAAG,CAAC,GAAG,EAAE;MAChB;MACAR,IAAI,CAACQ,GAAG,CAAC,CAACc,IAAI,CAACF,GAAG,CAAC;IACrB,CAAC,CAAC;EACJ;EAEA,SAASG,iBAAiBA,CAAEC,MAAM,EAAE7C,OAAO,EAAEyC,GAAG,EAAE;IAChD,IAAIzC,OAAO,IAAIH,iBAAiB,CAACG,OAAO,CAAC,EAAE;MACzC6C,MAAM,CAAC7C,OAAO,GAAGJ,eAAe,CAACI,OAAO,CAAC;MACzC,IAAI,CAACwB,SAAS,EAAE;QACdgB,cAAc,CAACK,MAAM,CAAC7C,OAAO,EAAEyC,GAAG,CAAC;MACrC;MAEArB,uBAAuB,EAAE;IAC3B;EACF;EAEA,SAAS0B,sBAAsBA,CAAEC,IAAI,EAAE;IACrC,MAAMC,IAAI,GAAGD,IAAI,IAAIA,IAAI,CAACb,YAAY;IACtC,IAAI,CAACc,IAAI,EAAE,OAAOjC,KAAK,EAAE;IAEzB,MAAMkC,qBAAqB,GAAGjC,MAAM,CAACsB,IAAI,CAACU,IAAI,CAAC,CAAC7C,GAAG,CAAE0B,GAAG,IAAK;MAC3D,MAAMY,GAAG,GAAGO,IAAI,CAACnB,GAAG,CAAC;MACrB,MAAM;QAAEF,IAAI;QAAE3B,OAAO;QAAE4B;MAAQ,CAAC,GAAGa,GAAG;;MAEtC;MACA,IAAIf,OAAO,CAACC,IAAI,EAAEC,OAAO,CAAC,EAAE,OAAOb,KAAK,EAAE;MAE1C,MAAMmC,WAAW,GAAG,CAAC,CAAC;MAEtB,IAAItB,OAAO,EAAE;QACXsB,WAAW,CAACtB,OAAO,GAAGA,OAAO;MAC/B;MAEAgB,iBAAiB,CAACM,WAAW,EAAElD,OAAO,EAAEyC,GAAG,CAAC;MAE5C,OAAO;QACLA,GAAG;QACHS;MACF,CAAC;IACH,CAAC,CAAC;IAEF,OAAOD,qBAAqB,CAACE,MAAM,CAAC,CAACC,GAAG,EAAAC,IAAA,EAAmCC,CAAC,KAAK;MAAA,IAAvC;QAAEb,GAAG,EAAEc,SAAS;QAAEL;MAAY,CAAC,GAAAG,IAAA;MACvE,IAAI,CAACH,WAAW,IAAIA,WAAW,CAACX,MAAM,KAAK,CAAC,EAAE,OAAOa,GAAG;;MAExD;MACA,MAAMI,sBAAsB,GAAGD,SAAS,CAACrB,YAAY,IACnDlB,MAAM,CAACsB,IAAI,CAACiB,SAAS,CAACrB,YAAY,CAAC,CAACK,MAAM,GAAG,CAAC,IAC9CO,sBAAsB,CAACS,SAAS,CAAC;;MAEnC;MACA;MACA,IAAI/B,SAAS,EAAE,OAAO,IAAI;MAE1B,IAAIa,eAAe,CAACmB,sBAAsB,CAAC,EAAE;QAC3CN,WAAW,CAAChB,YAAY,GAAGD,oBAAoB,CAACuB,sBAAsB,CAAC;MACzE;MAEA,IAAIN,WAAW,CAAClD,OAAO,IAAIkD,WAAW,CAAClD,OAAO,CAACuC,MAAM,KAAK,CAAC,EAAE;QAC3Da,GAAG,CAACG,SAAS,CAAC5B,IAAI,CAAC,GAAGuB,WAAW;MACnC,CAAC,MAAM,IAAIA,WAAW,CAAChB,YAAY,EAAE;QACnCkB,GAAG,CAAC3B,qBAAqB,CAAC,GACxBT,MAAM,CAACoB,MAAM,CACXrB,KAAK,EAAE,EACPqC,GAAG,CAAC3B,qBAAqB,CAAC,EAC1ByB,WAAW,CAAChB,YAAY,CACzB;MACL;MAEA,OAAOkB,GAAG;IACZ,CAAC,EAAE5B,SAAS,GAAG,IAAI,GAAGT,KAAK,EAAE,CAAC;EAChC;EAEA,MAAM0C,qBAAqB,GAAGX,sBAAsB,CAAC5B,SAAS,CAAC;EAC/D,MAAMwC,MAAM,GAAG;IACbnB,MAAM,EAAEnB;EACV,CAAC;EAED,IAAI,CAACI,SAAS,EAAE;IACdkC,MAAM,CAAC/B,IAAI,GAAGT,SAAS,CAACS,IAAI,IAAIT,SAAS,CAACyC,IAAI;IAE9C,IAAIzC,SAAS,IAAIA,SAAS,CAACU,OAAO,EAAE;MAClC8B,MAAM,CAAC9B,OAAO,GAAGV,SAAS,CAACU,OAAO;IACpC;IAEA,IAAIV,SAAS,IAAIA,SAAS,CAAClB,OAAO,EAAE;MAClC0D,MAAM,CAAC1D,OAAO,GAAGJ,eAAe,CAACsB,SAAS,CAAClB,OAAO,CAAC;IACrD;IAEA0D,MAAM,CAACxB,YAAY,GAAGD,oBAAoB,CAACwB,qBAAqB,CAAC;IAEjEC,MAAM,CAAC5D,eAAe,CAAC,GAAGuB,IAAI;EAChC;EAEA,OAAOqC,MAAM;AACf"},"metadata":{},"sourceType":"script","externalDependencies":[]}