{"ast":null,"code":"'use strict';\n\nconst BB = require('bluebird');\nlet addBundled;\nconst childPath = require('../utils/child-path.js');\nconst createChild = require('./node.js').create;\nlet fetchPackageMetadata;\nconst inflateBundled = require('./inflate-bundled.js');\nconst moduleName = require('../utils/module-name.js');\nconst normalizePackageData = require('normalize-package-data');\nconst npm = require('../npm.js');\nconst realizeShrinkwrapSpecifier = require('./realize-shrinkwrap-specifier.js');\nconst validate = require('aproba');\nconst path = require('path');\nconst isRegistry = require('../utils/is-registry.js');\nconst hasModernMeta = require('./has-modern-meta.js');\nconst ssri = require('ssri');\nconst npa = require('npm-package-arg');\nmodule.exports = function (tree, sw, opts, finishInflating) {\n  if (!fetchPackageMetadata) {\n    fetchPackageMetadata = BB.promisify(require('../fetch-package-metadata.js'));\n    addBundled = BB.promisify(fetchPackageMetadata.addBundled);\n  }\n  if (arguments.length === 3) {\n    finishInflating = opts;\n    opts = {};\n  }\n  if (!npm.config.get('shrinkwrap') || !npm.config.get('package-lock')) {\n    return finishInflating();\n  }\n  tree.loaded = false;\n  tree.hasRequiresFromLock = sw.requires;\n  return inflateShrinkwrap(tree.path, tree, sw.dependencies, opts).then(() => finishInflating(), finishInflating);\n};\nfunction inflateShrinkwrap(topPath, tree, swdeps, opts) {\n  if (!swdeps) return Promise.resolve();\n  if (!opts) opts = {};\n  const onDisk = {};\n  tree.children.forEach(child => {\n    onDisk[moduleName(child)] = child;\n  });\n  tree.children = [];\n  return BB.each(Object.keys(swdeps), name => {\n    const sw = swdeps[name];\n    const dependencies = sw.dependencies || {};\n    const requested = realizeShrinkwrapSpecifier(name, sw, topPath);\n    if (Object.keys(sw).length === 0) {\n      let message = `Object for dependency \"${name}\" is empty.\\n`;\n      message += 'Something went wrong. Regenerate the package-lock.json with \"npm install\".\\n';\n      message += 'If using a shrinkwrap, regenerate with \"npm shrinkwrap\".';\n      return Promise.reject(new Error(message));\n    }\n    return inflatableChild(onDisk[name], name, topPath, tree, sw, requested, opts).then(child => {\n      child.hasRequiresFromLock = tree.hasRequiresFromLock;\n      return inflateShrinkwrap(topPath, child, dependencies);\n    });\n  });\n}\nfunction normalizePackageDataNoErrors(pkg) {\n  try {\n    normalizePackageData(pkg);\n  } catch (ex) {\n    // don't care\n  }\n}\nfunction quotemeta(str) {\n  return str.replace(/([^A-Za-z_0-9/])/g, '\\\\$1');\n}\nfunction tarballToVersion(name, tb) {\n  const registry = quotemeta(npm.config.get('registry') || '').replace(/https?:/, 'https?:').replace(/([^/])$/, '$1/');\n  let matchRegTarball;\n  if (name) {\n    const nameMatch = quotemeta(name);\n    matchRegTarball = new RegExp(`^${registry}${nameMatch}/-/${nameMatch}-(.*)[.]tgz$`);\n  } else {\n    matchRegTarball = new RegExp(`^${registry}(.*)?/-/\\\\1-(.*)[.]tgz$`);\n  }\n  const match = tb.match(matchRegTarball);\n  if (!match) return;\n  return match[2] || match[1];\n}\nfunction relativizeLink(name, spec, topPath, requested) {\n  if (!spec.startsWith('file:')) {\n    return;\n  }\n  let requestedPath = requested.fetchSpec;\n  if (requested.type === 'file') {\n    requestedPath = path.dirname(requestedPath);\n  }\n  const relativized = path.relative(requestedPath, path.resolve(topPath, spec.slice(5)));\n  return 'file:' + relativized;\n}\nfunction inflatableChild(onDiskChild, name, topPath, tree, sw, requested, opts) {\n  validate('OSSOOOO|ZSSOOOO', arguments);\n  const usesIntegrity = requested.registry || requested.type === 'remote' || requested.type === 'file';\n  const regTarball = tarballToVersion(name, sw.version);\n  if (regTarball) {\n    sw.resolved = sw.version;\n    sw.version = regTarball;\n  }\n  if (sw.requires) {\n    Object.keys(sw.requires).forEach(name => {\n      const spec = sw.requires[name];\n      sw.requires[name] = tarballToVersion(name, spec) || relativizeLink(name, spec, topPath, requested) || spec;\n    });\n  }\n  const modernLink = requested.type === 'directory' && !sw.from;\n  if (hasModernMeta(onDiskChild) && childIsEquivalent(sw, requested, onDiskChild)) {\n    // The version on disk matches the shrinkwrap entry.\n    if (!onDiskChild.fromShrinkwrap) onDiskChild.fromShrinkwrap = requested;\n    onDiskChild.package._requested = requested;\n    onDiskChild.package._spec = requested.rawSpec;\n    onDiskChild.package._where = topPath;\n    onDiskChild.package._optional = sw.optional;\n    onDiskChild.package._development = sw.dev;\n    onDiskChild.package._inBundle = sw.bundled;\n    onDiskChild.fromBundle = sw.bundled || onDiskChild.package._inBundle ? tree.fromBundle || tree : null;\n    if (!onDiskChild.package._args) onDiskChild.package._args = [];\n    onDiskChild.package._args.push([String(requested), topPath]);\n    // non-npm registries can and will return unnormalized data, plus\n    // even the npm registry may have package data normalized with older\n    // normalization rules. This ensures we get package data in a consistent,\n    // stable format.\n    normalizePackageDataNoErrors(onDiskChild.package);\n    onDiskChild.swRequires = sw.requires;\n    tree.children.push(onDiskChild);\n    return BB.resolve(onDiskChild);\n  } else if (sw.version && (sw.integrity || !usesIntegrity) && (requested.type !== 'directory' || modernLink) || sw.bundled) {\n    // The shrinkwrap entry has an integrity field. We can fake a pkg to get\n    // the installer to do a content-address fetch from the cache, if possible.\n    return BB.resolve(makeFakeChild(name, topPath, tree, sw, requested));\n  } else {\n    // It's not on disk, and we can't just look it up by address -- do a full\n    // fpm/inflate bundle pass. For registry deps, this will go straight to the\n    // tarball URL, as if it were a remote tarball dep.\n    return fetchChild(topPath, tree, sw, requested);\n  }\n}\nfunction isGit(sw) {\n  const version = npa.resolve(sw.name, sw.version);\n  return version && version.type === 'git';\n}\nfunction makeFakeChild(name, topPath, tree, sw, requested) {\n  const isDirectory = requested.type === 'directory';\n  const from = sw.from || requested.raw;\n  const pkg = {\n    name: name,\n    version: sw.version,\n    _id: name + '@' + sw.version,\n    _resolved: sw.resolved || isGit(sw) && sw.version,\n    _requested: requested,\n    _optional: sw.optional,\n    _development: sw.dev,\n    _inBundle: sw.bundled,\n    _integrity: sw.integrity,\n    _from: from,\n    _spec: requested.rawSpec,\n    _where: topPath,\n    _args: [[requested.toString(), topPath]],\n    dependencies: sw.requires\n  };\n  if (!sw.bundled) {\n    const bundleDependencies = Object.keys(sw.dependencies || {}).filter(d => sw.dependencies[d].bundled);\n    if (bundleDependencies.length === 0) {\n      pkg.bundleDependencies = bundleDependencies;\n    }\n  }\n  const child = createChild({\n    package: pkg,\n    loaded: isDirectory,\n    parent: tree,\n    children: [],\n    fromShrinkwrap: requested,\n    fakeChild: sw,\n    fromBundle: sw.bundled ? tree.fromBundle || tree : null,\n    path: childPath(tree.path, pkg),\n    realpath: isDirectory ? requested.fetchSpec : childPath(tree.realpath, pkg),\n    location: (tree.location === '/' ? '' : tree.location + '/') + pkg.name,\n    isLink: isDirectory,\n    isInLink: tree.isLink || tree.isInLink,\n    swRequires: sw.requires\n  });\n  tree.children.push(child);\n  return child;\n}\nfunction fetchChild(topPath, tree, sw, requested) {\n  return fetchPackageMetadata(requested, topPath).then(pkg => {\n    pkg._from = sw.from || requested.raw;\n    pkg._optional = sw.optional;\n    pkg._development = sw.dev;\n    pkg._inBundle = false;\n    return addBundled(pkg).then(() => pkg);\n  }).then(pkg => {\n    var isLink = pkg._requested.type === 'directory';\n    const child = createChild({\n      package: pkg,\n      loaded: false,\n      parent: tree,\n      fromShrinkwrap: requested,\n      path: childPath(tree.path, pkg),\n      realpath: isLink ? requested.fetchSpec : childPath(tree.realpath, pkg),\n      children: pkg._bundled || [],\n      location: (tree.location === '/' ? '' : tree.location + '/') + pkg.name,\n      fromBundle: null,\n      isLink: isLink,\n      isInLink: tree.isLink,\n      swRequires: sw.requires\n    });\n    tree.children.push(child);\n    if (pkg._bundled) {\n      delete pkg._bundled;\n      inflateBundled(child, child, child.children);\n    }\n    return child;\n  });\n}\nfunction childIsEquivalent(sw, requested, child) {\n  if (!child) return false;\n  if (child.fromShrinkwrap) return true;\n  if (sw.integrity && child.package._integrity && ssri.parse(sw.integrity).match(child.package._integrity)) return true;\n  if (child.isLink && requested.type === 'directory') return path.relative(child.realpath, requested.fetchSpec) === '';\n  if (sw.resolved) return child.package._resolved === sw.resolved;\n  if (!isRegistry(requested) && sw.from) return child.package._from === sw.from;\n  if (!isRegistry(requested) && child.package._resolved) return sw.version === child.package._resolved;\n  return child.package.version === sw.version;\n}","map":{"version":3,"names":["BB","require","addBundled","childPath","createChild","create","fetchPackageMetadata","inflateBundled","moduleName","normalizePackageData","npm","realizeShrinkwrapSpecifier","validate","path","isRegistry","hasModernMeta","ssri","npa","module","exports","tree","sw","opts","finishInflating","promisify","arguments","length","config","get","loaded","hasRequiresFromLock","requires","inflateShrinkwrap","dependencies","then","topPath","swdeps","Promise","resolve","onDisk","children","forEach","child","each","Object","keys","name","requested","message","reject","Error","inflatableChild","normalizePackageDataNoErrors","pkg","ex","quotemeta","str","replace","tarballToVersion","tb","registry","matchRegTarball","nameMatch","RegExp","match","relativizeLink","spec","startsWith","requestedPath","fetchSpec","type","dirname","relativized","relative","slice","onDiskChild","usesIntegrity","regTarball","version","resolved","modernLink","from","childIsEquivalent","fromShrinkwrap","package","_requested","_spec","rawSpec","_where","_optional","optional","_development","dev","_inBundle","bundled","fromBundle","_args","push","String","swRequires","integrity","makeFakeChild","fetchChild","isGit","isDirectory","raw","_id","_resolved","_integrity","_from","toString","bundleDependencies","filter","d","parent","fakeChild","realpath","location","isLink","isInLink","_bundled","parse"],"sources":["/Users/hkateliev/node_modules/npm/lib/install/inflate-shrinkwrap.js"],"sourcesContent":["'use strict'\n\nconst BB = require('bluebird')\n\nlet addBundled\nconst childPath = require('../utils/child-path.js')\nconst createChild = require('./node.js').create\nlet fetchPackageMetadata\nconst inflateBundled = require('./inflate-bundled.js')\nconst moduleName = require('../utils/module-name.js')\nconst normalizePackageData = require('normalize-package-data')\nconst npm = require('../npm.js')\nconst realizeShrinkwrapSpecifier = require('./realize-shrinkwrap-specifier.js')\nconst validate = require('aproba')\nconst path = require('path')\nconst isRegistry = require('../utils/is-registry.js')\nconst hasModernMeta = require('./has-modern-meta.js')\nconst ssri = require('ssri')\nconst npa = require('npm-package-arg')\n\nmodule.exports = function (tree, sw, opts, finishInflating) {\n  if (!fetchPackageMetadata) {\n    fetchPackageMetadata = BB.promisify(require('../fetch-package-metadata.js'))\n    addBundled = BB.promisify(fetchPackageMetadata.addBundled)\n  }\n  if (arguments.length === 3) {\n    finishInflating = opts\n    opts = {}\n  }\n  if (!npm.config.get('shrinkwrap') || !npm.config.get('package-lock')) {\n    return finishInflating()\n  }\n  tree.loaded = false\n  tree.hasRequiresFromLock = sw.requires\n  return inflateShrinkwrap(tree.path, tree, sw.dependencies, opts).then(\n    () => finishInflating(),\n    finishInflating\n  )\n}\n\nfunction inflateShrinkwrap (topPath, tree, swdeps, opts) {\n  if (!swdeps) return Promise.resolve()\n  if (!opts) opts = {}\n  const onDisk = {}\n  tree.children.forEach((child) => {\n    onDisk[moduleName(child)] = child\n  })\n\n  tree.children = []\n\n  return BB.each(Object.keys(swdeps), (name) => {\n    const sw = swdeps[name]\n    const dependencies = sw.dependencies || {}\n    const requested = realizeShrinkwrapSpecifier(name, sw, topPath)\n\n    if (Object.keys(sw).length === 0) {\n      let message = `Object for dependency \"${name}\" is empty.\\n`\n      message += 'Something went wrong. Regenerate the package-lock.json with \"npm install\".\\n'\n      message += 'If using a shrinkwrap, regenerate with \"npm shrinkwrap\".'\n      return Promise.reject(new Error(message))\n    }\n\n    return inflatableChild(\n      onDisk[name], name, topPath, tree, sw, requested, opts\n    ).then((child) => {\n      child.hasRequiresFromLock = tree.hasRequiresFromLock\n      return inflateShrinkwrap(topPath, child, dependencies)\n    })\n  })\n}\n\nfunction normalizePackageDataNoErrors (pkg) {\n  try {\n    normalizePackageData(pkg)\n  } catch (ex) {\n    // don't care\n  }\n}\n\nfunction quotemeta (str) {\n  return str.replace(/([^A-Za-z_0-9/])/g, '\\\\$1')\n}\n\nfunction tarballToVersion (name, tb) {\n  const registry = quotemeta(npm.config.get('registry') || '')\n    .replace(/https?:/, 'https?:')\n    .replace(/([^/])$/, '$1/')\n  let matchRegTarball\n  if (name) {\n    const nameMatch = quotemeta(name)\n    matchRegTarball = new RegExp(`^${registry}${nameMatch}/-/${nameMatch}-(.*)[.]tgz$`)\n  } else {\n    matchRegTarball = new RegExp(`^${registry}(.*)?/-/\\\\1-(.*)[.]tgz$`)\n  }\n  const match = tb.match(matchRegTarball)\n  if (!match) return\n  return match[2] || match[1]\n}\n\nfunction relativizeLink (name, spec, topPath, requested) {\n  if (!spec.startsWith('file:')) {\n    return\n  }\n\n  let requestedPath = requested.fetchSpec\n  if (requested.type === 'file') {\n    requestedPath = path.dirname(requestedPath)\n  }\n\n  const relativized = path.relative(requestedPath, path.resolve(topPath, spec.slice(5)))\n  return 'file:' + relativized\n}\n\nfunction inflatableChild (onDiskChild, name, topPath, tree, sw, requested, opts) {\n  validate('OSSOOOO|ZSSOOOO', arguments)\n  const usesIntegrity = (\n    requested.registry ||\n    requested.type === 'remote' ||\n    requested.type === 'file'\n  )\n  const regTarball = tarballToVersion(name, sw.version)\n  if (regTarball) {\n    sw.resolved = sw.version\n    sw.version = regTarball\n  }\n  if (sw.requires) {\n    Object.keys(sw.requires).forEach(name => {\n      const spec = sw.requires[name]\n      sw.requires[name] = tarballToVersion(name, spec) ||\n        relativizeLink(name, spec, topPath, requested) ||\n        spec\n    })\n  }\n  const modernLink = requested.type === 'directory' && !sw.from\n  if (hasModernMeta(onDiskChild) && childIsEquivalent(sw, requested, onDiskChild)) {\n    // The version on disk matches the shrinkwrap entry.\n    if (!onDiskChild.fromShrinkwrap) onDiskChild.fromShrinkwrap = requested\n    onDiskChild.package._requested = requested\n    onDiskChild.package._spec = requested.rawSpec\n    onDiskChild.package._where = topPath\n    onDiskChild.package._optional = sw.optional\n    onDiskChild.package._development = sw.dev\n    onDiskChild.package._inBundle = sw.bundled\n    onDiskChild.fromBundle = (sw.bundled || onDiskChild.package._inBundle) ? tree.fromBundle || tree : null\n    if (!onDiskChild.package._args) onDiskChild.package._args = []\n    onDiskChild.package._args.push([String(requested), topPath])\n    // non-npm registries can and will return unnormalized data, plus\n    // even the npm registry may have package data normalized with older\n    // normalization rules. This ensures we get package data in a consistent,\n    // stable format.\n    normalizePackageDataNoErrors(onDiskChild.package)\n    onDiskChild.swRequires = sw.requires\n    tree.children.push(onDiskChild)\n    return BB.resolve(onDiskChild)\n  } else if ((sw.version && (sw.integrity || !usesIntegrity) && (requested.type !== 'directory' || modernLink)) || sw.bundled) {\n    // The shrinkwrap entry has an integrity field. We can fake a pkg to get\n    // the installer to do a content-address fetch from the cache, if possible.\n    return BB.resolve(makeFakeChild(name, topPath, tree, sw, requested))\n  } else {\n    // It's not on disk, and we can't just look it up by address -- do a full\n    // fpm/inflate bundle pass. For registry deps, this will go straight to the\n    // tarball URL, as if it were a remote tarball dep.\n    return fetchChild(topPath, tree, sw, requested)\n  }\n}\n\nfunction isGit (sw) {\n  const version = npa.resolve(sw.name, sw.version)\n  return (version && version.type === 'git')\n}\n\nfunction makeFakeChild (name, topPath, tree, sw, requested) {\n  const isDirectory = requested.type === 'directory'\n  const from = sw.from || requested.raw\n  const pkg = {\n    name: name,\n    version: sw.version,\n    _id: name + '@' + sw.version,\n    _resolved: sw.resolved || (isGit(sw) && sw.version),\n    _requested: requested,\n    _optional: sw.optional,\n    _development: sw.dev,\n    _inBundle: sw.bundled,\n    _integrity: sw.integrity,\n    _from: from,\n    _spec: requested.rawSpec,\n    _where: topPath,\n    _args: [[requested.toString(), topPath]],\n    dependencies: sw.requires\n  }\n\n  if (!sw.bundled) {\n    const bundleDependencies = Object.keys(sw.dependencies || {}).filter((d) => sw.dependencies[d].bundled)\n    if (bundleDependencies.length === 0) {\n      pkg.bundleDependencies = bundleDependencies\n    }\n  }\n  const child = createChild({\n    package: pkg,\n    loaded: isDirectory,\n    parent: tree,\n    children: [],\n    fromShrinkwrap: requested,\n    fakeChild: sw,\n    fromBundle: sw.bundled ? tree.fromBundle || tree : null,\n    path: childPath(tree.path, pkg),\n    realpath: isDirectory ? requested.fetchSpec : childPath(tree.realpath, pkg),\n    location: (tree.location === '/' ? '' : tree.location + '/') + pkg.name,\n    isLink: isDirectory,\n    isInLink: tree.isLink || tree.isInLink,\n    swRequires: sw.requires\n  })\n  tree.children.push(child)\n  return child\n}\n\nfunction fetchChild (topPath, tree, sw, requested) {\n  return fetchPackageMetadata(requested, topPath).then((pkg) => {\n    pkg._from = sw.from || requested.raw\n    pkg._optional = sw.optional\n    pkg._development = sw.dev\n    pkg._inBundle = false\n    return addBundled(pkg).then(() => pkg)\n  }).then((pkg) => {\n    var isLink = pkg._requested.type === 'directory'\n    const child = createChild({\n      package: pkg,\n      loaded: false,\n      parent: tree,\n      fromShrinkwrap: requested,\n      path: childPath(tree.path, pkg),\n      realpath: isLink ? requested.fetchSpec : childPath(tree.realpath, pkg),\n      children: pkg._bundled || [],\n      location: (tree.location === '/' ? '' : tree.location + '/') + pkg.name,\n      fromBundle: null,\n      isLink: isLink,\n      isInLink: tree.isLink,\n      swRequires: sw.requires\n    })\n    tree.children.push(child)\n    if (pkg._bundled) {\n      delete pkg._bundled\n      inflateBundled(child, child, child.children)\n    }\n    return child\n  })\n}\n\nfunction childIsEquivalent (sw, requested, child) {\n  if (!child) return false\n  if (child.fromShrinkwrap) return true\n  if (\n    sw.integrity &&\n    child.package._integrity &&\n    ssri.parse(sw.integrity).match(child.package._integrity)\n  ) return true\n  if (child.isLink && requested.type === 'directory') return path.relative(child.realpath, requested.fetchSpec) === ''\n\n  if (sw.resolved) return child.package._resolved === sw.resolved\n  if (!isRegistry(requested) && sw.from) return child.package._from === sw.from\n  if (!isRegistry(requested) && child.package._resolved) return sw.version === child.package._resolved\n  return child.package.version === sw.version\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}