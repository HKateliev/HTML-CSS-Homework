{"ast":null,"code":"'use strict';\n\nconst cacache = require('cacache');\nconst fetch = require('node-fetch-npm');\nconst pipe = require('mississippi').pipe;\nconst ssri = require('ssri');\nconst through = require('mississippi').through;\nconst to = require('mississippi').to;\nconst url = require('url');\nconst stream = require('stream');\nconst MAX_MEM_SIZE = 5 * 1024 * 1024; // 5MB\n\nfunction cacheKey(req) {\n  const parsed = url.parse(req.url);\n  return `make-fetch-happen:request-cache:${url.format({\n    protocol: parsed.protocol,\n    slashes: parsed.slashes,\n    host: parsed.host,\n    hostname: parsed.hostname,\n    pathname: parsed.pathname\n  })}`;\n}\n\n// This is a cacache-based implementation of the Cache standard,\n// using node-fetch.\n// docs: https://developer.mozilla.org/en-US/docs/Web/API/Cache\n//\nmodule.exports = class Cache {\n  constructor(path, opts) {\n    this._path = path;\n    this.Promise = opts && opts.Promise || Promise;\n  }\n\n  // Returns a Promise that resolves to the response associated with the first\n  // matching request in the Cache object.\n  match(req, opts) {\n    opts = opts || {};\n    const key = cacheKey(req);\n    return cacache.get.info(this._path, key).then(info => {\n      return info && cacache.get.hasContent(this._path, info.integrity, opts).then(exists => exists && info);\n    }).then(info => {\n      if (info && info.metadata && matchDetails(req, {\n        url: info.metadata.url,\n        reqHeaders: new fetch.Headers(info.metadata.reqHeaders),\n        resHeaders: new fetch.Headers(info.metadata.resHeaders),\n        cacheIntegrity: info.integrity,\n        integrity: opts && opts.integrity\n      })) {\n        const resHeaders = new fetch.Headers(info.metadata.resHeaders);\n        addCacheHeaders(resHeaders, this._path, key, info.integrity, info.time);\n        if (req.method === 'HEAD') {\n          return new fetch.Response(null, {\n            url: req.url,\n            headers: resHeaders,\n            status: 200\n          });\n        }\n        let body;\n        const cachePath = this._path;\n        // avoid opening cache file handles until a user actually tries to\n        // read from it.\n        if (opts.memoize !== false && info.size > MAX_MEM_SIZE) {\n          body = new stream.PassThrough();\n          const realRead = body._read;\n          body._read = function (size) {\n            body._read = realRead;\n            pipe(cacache.get.stream.byDigest(cachePath, info.integrity, {\n              memoize: opts.memoize\n            }), body, err => body.emit(err));\n            return realRead.call(this, size);\n          };\n        } else {\n          let readOnce = false;\n          // cacache is much faster at bulk reads\n          body = new stream.Readable({\n            read() {\n              if (readOnce) return this.push(null);\n              readOnce = true;\n              cacache.get.byDigest(cachePath, info.integrity, {\n                memoize: opts.memoize\n              }).then(data => {\n                this.push(data);\n                this.push(null);\n              }, err => this.emit('error', err));\n            }\n          });\n        }\n        return this.Promise.resolve(new fetch.Response(body, {\n          url: req.url,\n          headers: resHeaders,\n          status: 200,\n          size: info.size\n        }));\n      }\n    });\n  }\n\n  // Takes both a request and its response and adds it to the given cache.\n  put(req, response, opts) {\n    opts = opts || {};\n    const size = response.headers.get('content-length');\n    const fitInMemory = !!size && opts.memoize !== false && size < MAX_MEM_SIZE;\n    const ckey = cacheKey(req);\n    const cacheOpts = {\n      algorithms: opts.algorithms,\n      metadata: {\n        url: req.url,\n        reqHeaders: req.headers.raw(),\n        resHeaders: response.headers.raw()\n      },\n      size,\n      memoize: fitInMemory && opts.memoize\n    };\n    if (req.method === 'HEAD' || response.status === 304) {\n      // Update metadata without writing\n      return cacache.get.info(this._path, ckey).then(info => {\n        // Providing these will bypass content write\n        cacheOpts.integrity = info.integrity;\n        addCacheHeaders(response.headers, this._path, ckey, info.integrity, info.time);\n        return new this.Promise((resolve, reject) => {\n          pipe(cacache.get.stream.byDigest(this._path, info.integrity, cacheOpts), cacache.put.stream(this._path, cacheKey(req), cacheOpts), err => err ? reject(err) : resolve(response));\n        });\n      }).then(() => response);\n    }\n    let buf = [];\n    let bufSize = 0;\n    let cacheTargetStream = false;\n    const cachePath = this._path;\n    let cacheStream = to((chunk, enc, cb) => {\n      if (!cacheTargetStream) {\n        if (fitInMemory) {\n          cacheTargetStream = to({\n            highWaterMark: MAX_MEM_SIZE\n          }, (chunk, enc, cb) => {\n            buf.push(chunk);\n            bufSize += chunk.length;\n            cb();\n          }, done => {\n            cacache.put(cachePath, cacheKey(req), Buffer.concat(buf, bufSize), cacheOpts).then(() => done(), done);\n          });\n        } else {\n          cacheTargetStream = cacache.put.stream(cachePath, cacheKey(req), cacheOpts);\n        }\n      }\n      cacheTargetStream.write(chunk, enc, cb);\n    }, done => {\n      cacheTargetStream ? cacheTargetStream.end(done) : done();\n    });\n    const oldBody = response.body;\n    const newBody = through({\n      highWaterMark: MAX_MEM_SIZE\n    });\n    response.body = newBody;\n    oldBody.once('error', err => newBody.emit('error', err));\n    newBody.once('error', err => oldBody.emit('error', err));\n    cacheStream.once('error', err => newBody.emit('error', err));\n    pipe(oldBody, to((chunk, enc, cb) => {\n      cacheStream.write(chunk, enc, () => {\n        newBody.write(chunk, enc, cb);\n      });\n    }, done => {\n      cacheStream.end(() => {\n        newBody.end(() => {\n          done();\n        });\n      });\n    }), err => err && newBody.emit('error', err));\n    return response;\n  }\n\n  // Finds the Cache entry whose key is the request, and if found, deletes the\n  // Cache entry and returns a Promise that resolves to true. If no Cache entry\n  // is found, it returns false.\n  'delete'(req, opts) {\n    opts = opts || {};\n    if (typeof opts.memoize === 'object') {\n      if (opts.memoize.reset) {\n        opts.memoize.reset();\n      } else if (opts.memoize.clear) {\n        opts.memoize.clear();\n      } else {\n        Object.keys(opts.memoize).forEach(k => {\n          opts.memoize[k] = null;\n        });\n      }\n    }\n    return cacache.rm.entry(this._path, cacheKey(req)\n    // TODO - true/false\n    ).then(() => false);\n  }\n};\nfunction matchDetails(req, cached) {\n  const reqUrl = url.parse(req.url);\n  const cacheUrl = url.parse(cached.url);\n  const vary = cached.resHeaders.get('Vary');\n  // https://tools.ietf.org/html/rfc7234#section-4.1\n  if (vary) {\n    if (vary.match(/\\*/)) {\n      return false;\n    } else {\n      const fieldsMatch = vary.split(/\\s*,\\s*/).every(field => {\n        return cached.reqHeaders.get(field) === req.headers.get(field);\n      });\n      if (!fieldsMatch) {\n        return false;\n      }\n    }\n  }\n  if (cached.integrity) {\n    return ssri.parse(cached.integrity).match(cached.cacheIntegrity);\n  }\n  reqUrl.hash = null;\n  cacheUrl.hash = null;\n  return url.format(reqUrl) === url.format(cacheUrl);\n}\nfunction addCacheHeaders(resHeaders, path, key, hash, time) {\n  resHeaders.set('X-Local-Cache', encodeURIComponent(path));\n  resHeaders.set('X-Local-Cache-Key', encodeURIComponent(key));\n  resHeaders.set('X-Local-Cache-Hash', encodeURIComponent(hash));\n  resHeaders.set('X-Local-Cache-Time', new Date(time).toUTCString());\n}","map":{"version":3,"names":["cacache","require","fetch","pipe","ssri","through","to","url","stream","MAX_MEM_SIZE","cacheKey","req","parsed","parse","format","protocol","slashes","host","hostname","pathname","module","exports","Cache","constructor","path","opts","_path","Promise","match","key","get","info","then","hasContent","integrity","exists","metadata","matchDetails","reqHeaders","Headers","resHeaders","cacheIntegrity","addCacheHeaders","time","method","Response","headers","status","body","cachePath","memoize","size","PassThrough","realRead","_read","byDigest","err","emit","call","readOnce","Readable","read","push","data","resolve","put","response","fitInMemory","ckey","cacheOpts","algorithms","raw","reject","buf","bufSize","cacheTargetStream","cacheStream","chunk","enc","cb","highWaterMark","length","done","Buffer","concat","write","end","oldBody","newBody","once","delete","reset","clear","Object","keys","forEach","k","rm","entry","cached","reqUrl","cacheUrl","vary","fieldsMatch","split","every","field","hash","set","encodeURIComponent","Date","toUTCString"],"sources":["/Users/hkateliev/node_modules/npm/node_modules/make-fetch-happen/cache.js"],"sourcesContent":["'use strict'\n\nconst cacache = require('cacache')\nconst fetch = require('node-fetch-npm')\nconst pipe = require('mississippi').pipe\nconst ssri = require('ssri')\nconst through = require('mississippi').through\nconst to = require('mississippi').to\nconst url = require('url')\nconst stream = require('stream')\n\nconst MAX_MEM_SIZE = 5 * 1024 * 1024 // 5MB\n\nfunction cacheKey (req) {\n  const parsed = url.parse(req.url)\n  return `make-fetch-happen:request-cache:${\n    url.format({\n      protocol: parsed.protocol,\n      slashes: parsed.slashes,\n      host: parsed.host,\n      hostname: parsed.hostname,\n      pathname: parsed.pathname\n    })\n  }`\n}\n\n// This is a cacache-based implementation of the Cache standard,\n// using node-fetch.\n// docs: https://developer.mozilla.org/en-US/docs/Web/API/Cache\n//\nmodule.exports = class Cache {\n  constructor (path, opts) {\n    this._path = path\n    this.Promise = (opts && opts.Promise) || Promise\n  }\n\n  // Returns a Promise that resolves to the response associated with the first\n  // matching request in the Cache object.\n  match (req, opts) {\n    opts = opts || {}\n    const key = cacheKey(req)\n    return cacache.get.info(this._path, key).then(info => {\n      return info && cacache.get.hasContent(\n        this._path, info.integrity, opts\n      ).then(exists => exists && info)\n    }).then(info => {\n      if (info && info.metadata && matchDetails(req, {\n        url: info.metadata.url,\n        reqHeaders: new fetch.Headers(info.metadata.reqHeaders),\n        resHeaders: new fetch.Headers(info.metadata.resHeaders),\n        cacheIntegrity: info.integrity,\n        integrity: opts && opts.integrity\n      })) {\n        const resHeaders = new fetch.Headers(info.metadata.resHeaders)\n        addCacheHeaders(resHeaders, this._path, key, info.integrity, info.time)\n        if (req.method === 'HEAD') {\n          return new fetch.Response(null, {\n            url: req.url,\n            headers: resHeaders,\n            status: 200\n          })\n        }\n        let body\n        const cachePath = this._path\n        // avoid opening cache file handles until a user actually tries to\n        // read from it.\n        if (opts.memoize !== false && info.size > MAX_MEM_SIZE) {\n          body = new stream.PassThrough()\n          const realRead = body._read\n          body._read = function (size) {\n            body._read = realRead\n            pipe(\n              cacache.get.stream.byDigest(cachePath, info.integrity, {\n                memoize: opts.memoize\n              }),\n              body,\n              err => body.emit(err))\n            return realRead.call(this, size)\n          }\n        } else {\n          let readOnce = false\n          // cacache is much faster at bulk reads\n          body = new stream.Readable({\n            read () {\n              if (readOnce) return this.push(null)\n              readOnce = true\n              cacache.get.byDigest(cachePath, info.integrity, {\n                memoize: opts.memoize\n              }).then(data => {\n                this.push(data)\n                this.push(null)\n              }, err => this.emit('error', err))\n            }\n          })\n        }\n        return this.Promise.resolve(new fetch.Response(body, {\n          url: req.url,\n          headers: resHeaders,\n          status: 200,\n          size: info.size\n        }))\n      }\n    })\n  }\n\n  // Takes both a request and its response and adds it to the given cache.\n  put (req, response, opts) {\n    opts = opts || {}\n    const size = response.headers.get('content-length')\n    const fitInMemory = !!size && opts.memoize !== false && size < MAX_MEM_SIZE\n    const ckey = cacheKey(req)\n    const cacheOpts = {\n      algorithms: opts.algorithms,\n      metadata: {\n        url: req.url,\n        reqHeaders: req.headers.raw(),\n        resHeaders: response.headers.raw()\n      },\n      size,\n      memoize: fitInMemory && opts.memoize\n    }\n    if (req.method === 'HEAD' || response.status === 304) {\n      // Update metadata without writing\n      return cacache.get.info(this._path, ckey).then(info => {\n        // Providing these will bypass content write\n        cacheOpts.integrity = info.integrity\n        addCacheHeaders(\n          response.headers, this._path, ckey, info.integrity, info.time\n        )\n        return new this.Promise((resolve, reject) => {\n          pipe(\n            cacache.get.stream.byDigest(this._path, info.integrity, cacheOpts),\n            cacache.put.stream(this._path, cacheKey(req), cacheOpts),\n            err => err ? reject(err) : resolve(response)\n          )\n        })\n      }).then(() => response)\n    }\n    let buf = []\n    let bufSize = 0\n    let cacheTargetStream = false\n    const cachePath = this._path\n    let cacheStream = to((chunk, enc, cb) => {\n      if (!cacheTargetStream) {\n        if (fitInMemory) {\n          cacheTargetStream =\n          to({highWaterMark: MAX_MEM_SIZE}, (chunk, enc, cb) => {\n            buf.push(chunk)\n            bufSize += chunk.length\n            cb()\n          }, done => {\n            cacache.put(\n              cachePath,\n              cacheKey(req),\n              Buffer.concat(buf, bufSize),\n              cacheOpts\n            ).then(\n              () => done(),\n              done\n            )\n          })\n        } else {\n          cacheTargetStream =\n          cacache.put.stream(cachePath, cacheKey(req), cacheOpts)\n        }\n      }\n      cacheTargetStream.write(chunk, enc, cb)\n    }, done => {\n      cacheTargetStream ? cacheTargetStream.end(done) : done()\n    })\n    const oldBody = response.body\n    const newBody = through({highWaterMark: MAX_MEM_SIZE})\n    response.body = newBody\n    oldBody.once('error', err => newBody.emit('error', err))\n    newBody.once('error', err => oldBody.emit('error', err))\n    cacheStream.once('error', err => newBody.emit('error', err))\n    pipe(oldBody, to((chunk, enc, cb) => {\n      cacheStream.write(chunk, enc, () => {\n        newBody.write(chunk, enc, cb)\n      })\n    }, done => {\n      cacheStream.end(() => {\n        newBody.end(() => {\n          done()\n        })\n      })\n    }), err => err && newBody.emit('error', err))\n    return response\n  }\n\n  // Finds the Cache entry whose key is the request, and if found, deletes the\n  // Cache entry and returns a Promise that resolves to true. If no Cache entry\n  // is found, it returns false.\n  'delete' (req, opts) {\n    opts = opts || {}\n    if (typeof opts.memoize === 'object') {\n      if (opts.memoize.reset) {\n        opts.memoize.reset()\n      } else if (opts.memoize.clear) {\n        opts.memoize.clear()\n      } else {\n        Object.keys(opts.memoize).forEach(k => {\n          opts.memoize[k] = null\n        })\n      }\n    }\n    return cacache.rm.entry(\n      this._path,\n      cacheKey(req)\n    // TODO - true/false\n    ).then(() => false)\n  }\n}\n\nfunction matchDetails (req, cached) {\n  const reqUrl = url.parse(req.url)\n  const cacheUrl = url.parse(cached.url)\n  const vary = cached.resHeaders.get('Vary')\n  // https://tools.ietf.org/html/rfc7234#section-4.1\n  if (vary) {\n    if (vary.match(/\\*/)) {\n      return false\n    } else {\n      const fieldsMatch = vary.split(/\\s*,\\s*/).every(field => {\n        return cached.reqHeaders.get(field) === req.headers.get(field)\n      })\n      if (!fieldsMatch) {\n        return false\n      }\n    }\n  }\n  if (cached.integrity) {\n    return ssri.parse(cached.integrity).match(cached.cacheIntegrity)\n  }\n  reqUrl.hash = null\n  cacheUrl.hash = null\n  return url.format(reqUrl) === url.format(cacheUrl)\n}\n\nfunction addCacheHeaders (resHeaders, path, key, hash, time) {\n  resHeaders.set('X-Local-Cache', encodeURIComponent(path))\n  resHeaders.set('X-Local-Cache-Key', encodeURIComponent(key))\n  resHeaders.set('X-Local-Cache-Hash', encodeURIComponent(hash))\n  resHeaders.set('X-Local-Cache-Time', new Date(time).toUTCString())\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}