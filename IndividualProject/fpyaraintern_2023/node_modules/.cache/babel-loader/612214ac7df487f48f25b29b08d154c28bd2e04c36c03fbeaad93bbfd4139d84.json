{"ast":null,"code":"'use strict';\n\nconst Buffer = require('./buffer.js');\n\n// tar -r\nconst hlo = require('./high-level-opt.js');\nconst Pack = require('./pack.js');\nconst Parse = require('./parse.js');\nconst fs = require('fs');\nconst fsm = require('fs-minipass');\nconst t = require('./list.js');\nconst path = require('path');\n\n// starting at the head of the file, read a Header\n// If the checksum is invalid, that's our position to start writing\n// If it is, jump forward by the specified size (round up to 512)\n// and try again.\n// Write the new Pack stream starting there.\n\nconst Header = require('./header.js');\nconst r = module.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_);\n  if (!opt.file) throw new TypeError('file is required');\n  if (opt.gzip) throw new TypeError('cannot append to compressed archives');\n  if (!files || !Array.isArray(files) || !files.length) throw new TypeError('no files or directories specified');\n  files = Array.from(files);\n  return opt.sync ? replaceSync(opt, files) : replace(opt, files, cb);\n};\nconst replaceSync = (opt, files) => {\n  const p = new Pack.Sync(opt);\n  let threw = true;\n  let fd;\n  let position;\n  try {\n    try {\n      fd = fs.openSync(opt.file, 'r+');\n    } catch (er) {\n      if (er.code === 'ENOENT') fd = fs.openSync(opt.file, 'w+');else throw er;\n    }\n    const st = fs.fstatSync(fd);\n    const headBuf = Buffer.alloc(512);\n    POSITION: for (position = 0; position < st.size; position += 512) {\n      for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {\n        bytes = fs.readSync(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos);\n        if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) throw new Error('cannot append to compressed archives');\n        if (!bytes) break POSITION;\n      }\n      let h = new Header(headBuf);\n      if (!h.cksumValid) break;\n      let entryBlockSize = 512 * Math.ceil(h.size / 512);\n      if (position + entryBlockSize + 512 > st.size) break;\n      // the 512 for the header we just parsed will be added as well\n      // also jump ahead all the blocks for the body\n      position += entryBlockSize;\n      if (opt.mtimeCache) opt.mtimeCache.set(h.path, h.mtime);\n    }\n    threw = false;\n    streamSync(opt, p, position, fd, files);\n  } finally {\n    if (threw) try {\n      fs.closeSync(fd);\n    } catch (er) {}\n  }\n};\nconst streamSync = (opt, p, position, fd, files) => {\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    fd: fd,\n    start: position\n  });\n  p.pipe(stream);\n  addFilesSync(p, files);\n};\nconst replace = (opt, files, cb) => {\n  files = Array.from(files);\n  const p = new Pack(opt);\n  const getPos = (fd, size, cb_) => {\n    const cb = (er, pos) => {\n      if (er) fs.close(fd, _ => cb_(er));else cb_(null, pos);\n    };\n    let position = 0;\n    if (size === 0) return cb(null, 0);\n    let bufPos = 0;\n    const headBuf = Buffer.alloc(512);\n    const onread = (er, bytes) => {\n      if (er) return cb(er);\n      bufPos += bytes;\n      if (bufPos < 512 && bytes) return fs.read(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos, onread);\n      if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) return cb(new Error('cannot append to compressed archives'));\n\n      // truncated header\n      if (bufPos < 512) return cb(null, position);\n      const h = new Header(headBuf);\n      if (!h.cksumValid) return cb(null, position);\n      const entryBlockSize = 512 * Math.ceil(h.size / 512);\n      if (position + entryBlockSize + 512 > size) return cb(null, position);\n      position += entryBlockSize + 512;\n      if (position >= size) return cb(null, position);\n      if (opt.mtimeCache) opt.mtimeCache.set(h.path, h.mtime);\n      bufPos = 0;\n      fs.read(fd, headBuf, 0, 512, position, onread);\n    };\n    fs.read(fd, headBuf, 0, 512, position, onread);\n  };\n  const promise = new Promise((resolve, reject) => {\n    p.on('error', reject);\n    let flag = 'r+';\n    const onopen = (er, fd) => {\n      if (er && er.code === 'ENOENT' && flag === 'r+') {\n        flag = 'w+';\n        return fs.open(opt.file, flag, onopen);\n      }\n      if (er) return reject(er);\n      fs.fstat(fd, (er, st) => {\n        if (er) return fs.close(fd, () => reject(er));\n        getPos(fd, st.size, (er, position) => {\n          if (er) return reject(er);\n          const stream = new fsm.WriteStream(opt.file, {\n            fd: fd,\n            start: position\n          });\n          p.pipe(stream);\n          stream.on('error', reject);\n          stream.on('close', resolve);\n          addFilesAsync(p, files);\n        });\n      });\n    };\n    fs.open(opt.file, flag, onopen);\n  });\n  return cb ? promise.then(cb, cb) : promise;\n};\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@') t({\n      file: path.resolve(p.cwd, file.substr(1)),\n      sync: true,\n      noResume: true,\n      onentry: entry => p.add(entry)\n    });else p.add(file);\n  });\n  p.end();\n};\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift();\n    if (file.charAt(0) === '@') return t({\n      file: path.resolve(p.cwd, file.substr(1)),\n      noResume: true,\n      onentry: entry => p.add(entry)\n    }).then(_ => addFilesAsync(p, files));else p.add(file);\n  }\n  p.end();\n};","map":{"version":3,"names":["Buffer","require","hlo","Pack","Parse","fs","fsm","t","path","Header","r","module","exports","opt_","files","cb","opt","file","TypeError","gzip","Array","isArray","length","from","sync","replaceSync","replace","p","Sync","threw","fd","position","openSync","er","code","st","fstatSync","headBuf","alloc","POSITION","size","bufPos","bytes","readSync","Error","h","cksumValid","entryBlockSize","Math","ceil","mtimeCache","set","mtime","streamSync","closeSync","stream","WriteStreamSync","start","pipe","addFilesSync","getPos","cb_","pos","close","_","onread","read","promise","Promise","resolve","reject","on","flag","onopen","open","fstat","WriteStream","addFilesAsync","then","forEach","charAt","cwd","substr","noResume","onentry","entry","add","end","shift"],"sources":["/Users/hkateliev/node_modules/npm/node_modules/tar/lib/replace.js"],"sourcesContent":["'use strict'\nconst Buffer = require('./buffer.js')\n\n// tar -r\nconst hlo = require('./high-level-opt.js')\nconst Pack = require('./pack.js')\nconst Parse = require('./parse.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst t = require('./list.js')\nconst path = require('path')\n\n// starting at the head of the file, read a Header\n// If the checksum is invalid, that's our position to start writing\n// If it is, jump forward by the specified size (round up to 512)\n// and try again.\n// Write the new Pack stream starting there.\n\nconst Header = require('./header.js')\n\nconst r = module.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_)\n\n  if (!opt.file)\n    throw new TypeError('file is required')\n\n  if (opt.gzip)\n    throw new TypeError('cannot append to compressed archives')\n\n  if (!files || !Array.isArray(files) || !files.length)\n    throw new TypeError('no files or directories specified')\n\n  files = Array.from(files)\n\n  return opt.sync ? replaceSync(opt, files)\n    : replace(opt, files, cb)\n}\n\nconst replaceSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n\n  let threw = true\n  let fd\n  let position\n\n  try {\n    try {\n      fd = fs.openSync(opt.file, 'r+')\n    } catch (er) {\n      if (er.code === 'ENOENT')\n        fd = fs.openSync(opt.file, 'w+')\n      else\n        throw er\n    }\n\n    const st = fs.fstatSync(fd)\n    const headBuf = Buffer.alloc(512)\n\n    POSITION: for (position = 0; position < st.size; position += 512) {\n      for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {\n        bytes = fs.readSync(\n          fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos\n        )\n\n        if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b)\n          throw new Error('cannot append to compressed archives')\n\n        if (!bytes)\n          break POSITION\n      }\n\n      let h = new Header(headBuf)\n      if (!h.cksumValid)\n        break\n      let entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > st.size)\n        break\n      // the 512 for the header we just parsed will be added as well\n      // also jump ahead all the blocks for the body\n      position += entryBlockSize\n      if (opt.mtimeCache)\n        opt.mtimeCache.set(h.path, h.mtime)\n    }\n    threw = false\n\n    streamSync(opt, p, position, fd, files)\n  } finally {\n    if (threw)\n      try { fs.closeSync(fd) } catch (er) {}\n  }\n}\n\nconst streamSync = (opt, p, position, fd, files) => {\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    fd: fd,\n    start: position\n  })\n  p.pipe(stream)\n  addFilesSync(p, files)\n}\n\nconst replace = (opt, files, cb) => {\n  files = Array.from(files)\n  const p = new Pack(opt)\n\n  const getPos = (fd, size, cb_) => {\n    const cb = (er, pos) => {\n      if (er)\n        fs.close(fd, _ => cb_(er))\n      else\n        cb_(null, pos)\n    }\n\n    let position = 0\n    if (size === 0)\n      return cb(null, 0)\n\n    let bufPos = 0\n    const headBuf = Buffer.alloc(512)\n    const onread = (er, bytes) => {\n      if (er)\n        return cb(er)\n      bufPos += bytes\n      if (bufPos < 512 && bytes)\n        return fs.read(\n          fd, headBuf, bufPos, headBuf.length - bufPos,\n          position + bufPos, onread\n        )\n\n      if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b)\n        return cb(new Error('cannot append to compressed archives'))\n\n      // truncated header\n      if (bufPos < 512)\n        return cb(null, position)\n\n      const h = new Header(headBuf)\n      if (!h.cksumValid)\n        return cb(null, position)\n\n      const entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > size)\n        return cb(null, position)\n\n      position += entryBlockSize + 512\n      if (position >= size)\n        return cb(null, position)\n\n      if (opt.mtimeCache)\n        opt.mtimeCache.set(h.path, h.mtime)\n      bufPos = 0\n      fs.read(fd, headBuf, 0, 512, position, onread)\n    }\n    fs.read(fd, headBuf, 0, 512, position, onread)\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    p.on('error', reject)\n    let flag = 'r+'\n    const onopen = (er, fd) => {\n      if (er && er.code === 'ENOENT' && flag === 'r+') {\n        flag = 'w+'\n        return fs.open(opt.file, flag, onopen)\n      }\n\n      if (er)\n        return reject(er)\n\n      fs.fstat(fd, (er, st) => {\n        if (er)\n          return fs.close(fd, () => reject(er))\n\n        getPos(fd, st.size, (er, position) => {\n          if (er)\n            return reject(er)\n          const stream = new fsm.WriteStream(opt.file, {\n            fd: fd,\n            start: position\n          })\n          p.pipe(stream)\n          stream.on('error', reject)\n          stream.on('close', resolve)\n          addFilesAsync(p, files)\n        })\n      })\n    }\n    fs.open(opt.file, flag, onopen)\n  })\n\n  return cb ? promise.then(cb, cb) : promise\n}\n\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@')\n      t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry)\n      })\n    else\n      p.add(file)\n  })\n  p.end()\n}\n\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift()\n    if (file.charAt(0) === '@')\n      return t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        noResume: true,\n        onentry: entry => p.add(entry)\n      }).then(_ => addFilesAsync(p, files))\n    else\n      p.add(file)\n  }\n  p.end()\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}