{"ast":null,"code":"'use strict';\n\nconst path = require('path');\nconst validate = require('aproba');\nconst fs = require('graceful-fs');\nconst isInside = require('path-is-inside');\nconst vacuum = require('fs-vacuum');\nconst chain = require('slide').chain;\nconst asyncMap = require('slide').asyncMap;\nconst readCmdShim = require('read-cmd-shim');\nconst iferr = require('iferr');\nexports = module.exports = rm;\nfunction rm(target, opts, cb) {\n  var targetPath = path.normalize(path.resolve(opts.prefix, target));\n  if (opts.prefixes.indexOf(targetPath) !== -1) {\n    return cb(new Error('May not delete: ' + targetPath));\n  }\n  var options = {};\n  if (opts.force) {\n    options.purge = true;\n  }\n  if (opts.base) options.base = path.normalize(path.resolve(opts.prefix, opts.base));\n  if (!opts.gently) {\n    options.purge = true;\n    return vacuum(targetPath, options, cb);\n  }\n  var parent = options.base = options.base || path.normalize(opts.prefix);\n\n  // Do all the async work we'll need to do in order to tell if this is a\n  // safe operation\n  chain([[isEverInside, parent, opts.prefixes, opts.log], [readLinkOrShim, targetPath], [isEverInside, targetPath, opts.prefixes, opts.log], [isEverInside, targetPath, [parent], opts.log]], function (er, results) {\n    if (er) {\n      if (er.code === 'ENOENT') return cb();\n      return cb(er);\n    }\n    var parentInfo = {\n      path: parent,\n      managed: results[0]\n    };\n    var targetInfo = {\n      path: targetPath,\n      symlink: results[1],\n      managed: results[2],\n      inParent: results[3]\n    };\n    isSafeToRm(parentInfo, targetInfo, opts.name, opts.log, iferr(cb, thenRemove));\n    function thenRemove(toRemove, removeBase) {\n      if (!toRemove) return cb();\n      if (removeBase) options.base = removeBase;\n      return vacuum(toRemove, options, cb);\n    }\n  });\n}\nexports._isSafeToRm = isSafeToRm;\nfunction isSafeToRm(parent, target, pkgName, log, cb) {\n  log.silly('gentlyRm', 'parent.path =', parent.path);\n  log.silly('gentlyRm', 'parent.managed =', parent.managed && parent.managed.target + ' is in ' + parent.managed.path);\n  log.silly('gentlyRm', 'target.path = ', target.path);\n  log.silly('gentlyRm', 'target.symlink =', target.symlink);\n  log.silly('gentlyRm', 'target.managed =', target.managed && target.managed.target + ' is in ' + target.managed.path);\n  log.silly('gentlyRm', 'target.inParent = ', target.inParent);\n\n  // The parent directory or something it symlinks to must eventually be in\n  // a folder that we maintain.\n  if (!parent.managed) {\n    log.info('gentlyRm', parent.path, 'is not contained in any directory ' + pkgName + ' is known to control or ' + 'any place they link to');\n    return cb(clobberFail(target.path, 'containing path ' + parent.path + \" isn't under \" + pkgName + \"'s control\"));\n  }\n\n  // The target or something it symlinks to must eventually be in the parent\n  // or something the parent symlinks to\n  if (target.inParent) {\n    var actualTarget = target.inParent.target;\n    var targetsParent = target.inParent.path;\n    // if the target.path was what we found in some version of parent, remove\n    // using that parent as the base\n    if (target.path === actualTarget) {\n      return cb(null, target.path, targetsParent);\n    } else {\n      // If something the target.path links to was what was found, just\n      // remove target.path in the location it was found.\n      return cb(null, target.path, path.dirname(target.path));\n    }\n  }\n\n  // If the target is in a managed directory and is in a symlink, but was\n  // not in our parent that usually means someone else installed a bin file\n  // with the same name as one of our bin files.\n  if (target.managed && target.symlink) {\n    log.warn('rm', 'not removing', target.path, \"as it wasn't installed by\", parent.path);\n    return cb();\n  }\n  if (target.symlink) {\n    return cb(clobberFail(target.path, target.symlink + ' symlink target is not controlled by ' + pkgName + ' ' + parent.path));\n  } else {\n    return cb(clobberFail(target.path, 'is outside ' + parent.path + ' and not a link'));\n  }\n}\nfunction clobberFail(target, msg) {\n  validate('SS', arguments);\n  var er = new Error('Refusing to delete ' + target + ': ' + msg);\n  er.code = 'EEXIST';\n  er.path = target;\n  return er;\n}\nfunction isENOENT(err) {\n  return err && err.code === 'ENOENT';\n}\nfunction notENOENT(err) {\n  return !isENOENT(err);\n}\nfunction skipENOENT(cb) {\n  return function (err, value) {\n    if (isENOENT(err)) {\n      return cb(null, false);\n    } else {\n      return cb(err, value);\n    }\n  };\n}\nfunction errorsToValues(fn) {\n  return function () {\n    var args = Array.prototype.slice.call(arguments);\n    var cb = args.pop();\n    args.push(function (err, value) {\n      if (err) {\n        return cb(null, err);\n      } else {\n        return cb(null, value);\n      }\n    });\n    fn.apply(null, args);\n  };\n}\nfunction isNotError(value) {\n  return !(value instanceof Error);\n}\nexports._isEverInside = isEverInside;\n// return the first of path, where target (or anything it symlinks to)\n// isInside the path (or anything it symlinks to)\nfunction isEverInside(target, paths, log, cb) {\n  validate('SAOF', arguments);\n  asyncMap(paths, errorsToValues(readAllLinks), iferr(cb, function (resolvedPaths) {\n    var errorFree = resolvedPaths.filter(isNotError);\n    if (errorFree.length === 0) {\n      var badErrors = resolvedPaths.filter(notENOENT);\n      if (badErrors.length === 0) {\n        return cb(null, false);\n      } else {\n        return cb(badErrors[0]);\n      }\n    }\n    readAllLinks(target, iferr(skipENOENT(cb), function (targets) {\n      cb(null, areAnyInsideAny(targets, errorFree, log));\n    }));\n  }));\n}\nexports._areAnyInsideAny = areAnyInsideAny;\n// Return the first path found that any target is inside\nfunction areAnyInsideAny(targets, paths, log) {\n  validate('AAO', arguments);\n  var toCheck = [];\n  paths.forEach(function (path) {\n    targets.forEach(function (target) {\n      toCheck.push([target, path]);\n    });\n  });\n  for (var ii = 0; ii < toCheck.length; ++ii) {\n    var target = toCheck[ii][0];\n    var path = toCheck[ii][1];\n    var inside = isInside(target, path);\n    if (!inside) log.silly('isEverInside', target, 'is not inside', path);\n    if (inside && path) return inside && path && {\n      target: target,\n      path: path\n    };\n  }\n  return false;\n}\nexports._readAllLinks = readAllLinks;\n// resolves chains of symlinks of unlimited depth, returning a list of paths\n// it's seen in the process when it hits either a symlink cycle or a\n// non-symlink\nfunction readAllLinks(path, cb) {\n  validate('SF', arguments);\n  var seen = {};\n  _readAllLinks(path);\n  function _readAllLinks(path) {\n    if (seen[path]) return cb(null, Object.keys(seen));\n    seen[path] = true;\n    resolveSymlink(path, iferr(cb, _readAllLinks));\n  }\n}\nexports._resolveSymlink = resolveSymlink;\nvar resolvedPaths = {};\nfunction resolveSymlink(symlink, cb) {\n  validate('SF', arguments);\n  var cached = resolvedPaths[symlink];\n  if (cached) return cb(null, cached);\n  readLinkOrShim(symlink, iferr(cb, function (symlinkTarget) {\n    if (symlinkTarget) {\n      resolvedPaths[symlink] = path.resolve(path.dirname(symlink), symlinkTarget);\n    } else {\n      resolvedPaths[symlink] = symlink;\n    }\n    return cb(null, resolvedPaths[symlink]);\n  }));\n}\nexports._readLinkOrShim = readLinkOrShim;\nfunction readLinkOrShim(path, cb) {\n  validate('SF', arguments);\n  fs.lstat(path, iferr(cb, function (stat) {\n    if (stat.isSymbolicLink()) {\n      fs.readlink(path, cb);\n    } else {\n      readCmdShim(path, function (er, source) {\n        if (!er) return cb(null, source);\n        // lstat wouldn't return an error on these, so we don't either.\n        if (er.code === 'ENOTASHIM' || er.code === 'EISDIR') {\n          return cb(null, null);\n        } else {\n          return cb(er);\n        }\n      });\n    }\n  }));\n}","map":{"version":3,"names":["path","require","validate","fs","isInside","vacuum","chain","asyncMap","readCmdShim","iferr","exports","module","rm","target","opts","cb","targetPath","normalize","resolve","prefix","prefixes","indexOf","Error","options","force","purge","base","gently","parent","isEverInside","log","readLinkOrShim","er","results","code","parentInfo","managed","targetInfo","symlink","inParent","isSafeToRm","name","thenRemove","toRemove","removeBase","_isSafeToRm","pkgName","silly","info","clobberFail","actualTarget","targetsParent","dirname","warn","msg","arguments","isENOENT","err","notENOENT","skipENOENT","value","errorsToValues","fn","args","Array","prototype","slice","call","pop","push","apply","isNotError","_isEverInside","paths","readAllLinks","resolvedPaths","errorFree","filter","length","badErrors","targets","areAnyInsideAny","_areAnyInsideAny","toCheck","forEach","ii","inside","_readAllLinks","seen","Object","keys","resolveSymlink","_resolveSymlink","cached","symlinkTarget","_readLinkOrShim","lstat","stat","isSymbolicLink","readlink","source"],"sources":["/Users/hkateliev/node_modules/npm/node_modules/gentle-fs/lib/rm.js"],"sourcesContent":["'use strict'\n\nconst path = require('path')\nconst validate = require('aproba')\nconst fs = require('graceful-fs')\nconst isInside = require('path-is-inside')\nconst vacuum = require('fs-vacuum')\nconst chain = require('slide').chain\nconst asyncMap = require('slide').asyncMap\nconst readCmdShim = require('read-cmd-shim')\nconst iferr = require('iferr')\n\nexports = module.exports = rm\n\nfunction rm (target, opts, cb) {\n  var targetPath = path.normalize(path.resolve(opts.prefix, target))\n  if (opts.prefixes.indexOf(targetPath) !== -1) {\n    return cb(new Error('May not delete: ' + targetPath))\n  }\n  var options = {}\n  if (opts.force) { options.purge = true }\n  if (opts.base) options.base = path.normalize(path.resolve(opts.prefix, opts.base))\n\n  if (!opts.gently) {\n    options.purge = true\n    return vacuum(targetPath, options, cb)\n  }\n\n  var parent = options.base = options.base || path.normalize(opts.prefix)\n\n  // Do all the async work we'll need to do in order to tell if this is a\n  // safe operation\n  chain([\n    [isEverInside, parent, opts.prefixes, opts.log],\n    [readLinkOrShim, targetPath],\n    [isEverInside, targetPath, opts.prefixes, opts.log],\n    [isEverInside, targetPath, [parent], opts.log]\n  ], function (er, results) {\n    if (er) {\n      if (er.code === 'ENOENT') return cb()\n      return cb(er)\n    }\n    var parentInfo = {\n      path: parent,\n      managed: results[0]\n    }\n    var targetInfo = {\n      path: targetPath,\n      symlink: results[1],\n      managed: results[2],\n      inParent: results[3]\n    }\n\n    isSafeToRm(parentInfo, targetInfo, opts.name, opts.log, iferr(cb, thenRemove))\n\n    function thenRemove (toRemove, removeBase) {\n      if (!toRemove) return cb()\n      if (removeBase) options.base = removeBase\n      return vacuum(toRemove, options, cb)\n    }\n  })\n}\n\nexports._isSafeToRm = isSafeToRm\nfunction isSafeToRm (parent, target, pkgName, log, cb) {\n  log.silly('gentlyRm', 'parent.path =', parent.path)\n  log.silly('gentlyRm', 'parent.managed =',\n    parent.managed && parent.managed.target + ' is in ' + parent.managed.path)\n  log.silly('gentlyRm', 'target.path = ', target.path)\n  log.silly('gentlyRm', 'target.symlink =', target.symlink)\n  log.silly('gentlyRm', 'target.managed =',\n    target.managed && target.managed.target + ' is in ' + target.managed.path)\n  log.silly('gentlyRm', 'target.inParent = ', target.inParent)\n\n  // The parent directory or something it symlinks to must eventually be in\n  // a folder that we maintain.\n  if (!parent.managed) {\n    log.info('gentlyRm', parent.path,\n      'is not contained in any directory ' + pkgName + ' is known to control or ' +\n      'any place they link to')\n    return cb(clobberFail(target.path, 'containing path ' + parent.path +\n      \" isn't under \" + pkgName + \"'s control\"))\n  }\n\n  // The target or something it symlinks to must eventually be in the parent\n  // or something the parent symlinks to\n  if (target.inParent) {\n    var actualTarget = target.inParent.target\n    var targetsParent = target.inParent.path\n    // if the target.path was what we found in some version of parent, remove\n    // using that parent as the base\n    if (target.path === actualTarget) {\n      return cb(null, target.path, targetsParent)\n    } else {\n      // If something the target.path links to was what was found, just\n      // remove target.path in the location it was found.\n      return cb(null, target.path, path.dirname(target.path))\n    }\n  }\n\n  // If the target is in a managed directory and is in a symlink, but was\n  // not in our parent that usually means someone else installed a bin file\n  // with the same name as one of our bin files.\n  if (target.managed && target.symlink) {\n    log.warn('rm', 'not removing', target.path,\n      \"as it wasn't installed by\", parent.path)\n    return cb()\n  }\n\n  if (target.symlink) {\n    return cb(clobberFail(target.path, target.symlink +\n      ' symlink target is not controlled by ' + pkgName + ' ' + parent.path))\n  } else {\n    return cb(clobberFail(target.path, 'is outside ' + parent.path +\n      ' and not a link'))\n  }\n}\n\nfunction clobberFail (target, msg) {\n  validate('SS', arguments)\n  var er = new Error('Refusing to delete ' + target + ': ' + msg)\n  er.code = 'EEXIST'\n  er.path = target\n  return er\n}\n\nfunction isENOENT (err) {\n  return err && err.code === 'ENOENT'\n}\n\nfunction notENOENT (err) {\n  return !isENOENT(err)\n}\n\nfunction skipENOENT (cb) {\n  return function (err, value) {\n    if (isENOENT(err)) {\n      return cb(null, false)\n    } else {\n      return cb(err, value)\n    }\n  }\n}\n\nfunction errorsToValues (fn) {\n  return function () {\n    var args = Array.prototype.slice.call(arguments)\n    var cb = args.pop()\n    args.push(function (err, value) {\n      if (err) {\n        return cb(null, err)\n      } else {\n        return cb(null, value)\n      }\n    })\n    fn.apply(null, args)\n  }\n}\n\nfunction isNotError (value) {\n  return !(value instanceof Error)\n}\n\nexports._isEverInside = isEverInside\n// return the first of path, where target (or anything it symlinks to)\n// isInside the path (or anything it symlinks to)\nfunction isEverInside (target, paths, log, cb) {\n  validate('SAOF', arguments)\n  asyncMap(paths, errorsToValues(readAllLinks), iferr(cb, function (resolvedPaths) {\n    var errorFree = resolvedPaths.filter(isNotError)\n    if (errorFree.length === 0) {\n      var badErrors = resolvedPaths.filter(notENOENT)\n      if (badErrors.length === 0) {\n        return cb(null, false)\n      } else {\n        return cb(badErrors[0])\n      }\n    }\n    readAllLinks(target, iferr(skipENOENT(cb), function (targets) {\n      cb(null, areAnyInsideAny(targets, errorFree, log))\n    }))\n  }))\n}\n\nexports._areAnyInsideAny = areAnyInsideAny\n// Return the first path found that any target is inside\nfunction areAnyInsideAny (targets, paths, log) {\n  validate('AAO', arguments)\n  var toCheck = []\n  paths.forEach(function (path) {\n    targets.forEach(function (target) {\n      toCheck.push([target, path])\n    })\n  })\n  for (var ii = 0; ii < toCheck.length; ++ii) {\n    var target = toCheck[ii][0]\n    var path = toCheck[ii][1]\n    var inside = isInside(target, path)\n    if (!inside) log.silly('isEverInside', target, 'is not inside', path)\n    if (inside && path) return inside && path && {target: target, path: path}\n  }\n  return false\n}\n\nexports._readAllLinks = readAllLinks\n// resolves chains of symlinks of unlimited depth, returning a list of paths\n// it's seen in the process when it hits either a symlink cycle or a\n// non-symlink\nfunction readAllLinks (path, cb) {\n  validate('SF', arguments)\n  var seen = {}\n  _readAllLinks(path)\n\n  function _readAllLinks (path) {\n    if (seen[path]) return cb(null, Object.keys(seen))\n    seen[path] = true\n    resolveSymlink(path, iferr(cb, _readAllLinks))\n  }\n}\n\nexports._resolveSymlink = resolveSymlink\nvar resolvedPaths = {}\nfunction resolveSymlink (symlink, cb) {\n  validate('SF', arguments)\n  var cached = resolvedPaths[symlink]\n  if (cached) return cb(null, cached)\n\n  readLinkOrShim(symlink, iferr(cb, function (symlinkTarget) {\n    if (symlinkTarget) {\n      resolvedPaths[symlink] = path.resolve(path.dirname(symlink), symlinkTarget)\n    } else {\n      resolvedPaths[symlink] = symlink\n    }\n    return cb(null, resolvedPaths[symlink])\n  }))\n}\n\nexports._readLinkOrShim = readLinkOrShim\nfunction readLinkOrShim (path, cb) {\n  validate('SF', arguments)\n  fs.lstat(path, iferr(cb, function (stat) {\n    if (stat.isSymbolicLink()) {\n      fs.readlink(path, cb)\n    } else {\n      readCmdShim(path, function (er, source) {\n        if (!er) return cb(null, source)\n        // lstat wouldn't return an error on these, so we don't either.\n        if (er.code === 'ENOTASHIM' || er.code === 'EISDIR') {\n          return cb(null, null)\n        } else {\n          return cb(er)\n        }\n      })\n    }\n  }))\n}\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAMC,QAAQ,GAAGD,OAAO,CAAC,QAAQ,CAAC;AAClC,MAAME,EAAE,GAAGF,OAAO,CAAC,aAAa,CAAC;AACjC,MAAMG,QAAQ,GAAGH,OAAO,CAAC,gBAAgB,CAAC;AAC1C,MAAMI,MAAM,GAAGJ,OAAO,CAAC,WAAW,CAAC;AACnC,MAAMK,KAAK,GAAGL,OAAO,CAAC,OAAO,CAAC,CAACK,KAAK;AACpC,MAAMC,QAAQ,GAAGN,OAAO,CAAC,OAAO,CAAC,CAACM,QAAQ;AAC1C,MAAMC,WAAW,GAAGP,OAAO,CAAC,eAAe,CAAC;AAC5C,MAAMQ,KAAK,GAAGR,OAAO,CAAC,OAAO,CAAC;AAE9BS,OAAO,GAAGC,MAAM,CAACD,OAAO,GAAGE,EAAE;AAE7B,SAASA,EAAEA,CAAEC,MAAM,EAAEC,IAAI,EAAEC,EAAE,EAAE;EAC7B,IAAIC,UAAU,GAAGhB,IAAI,CAACiB,SAAS,CAACjB,IAAI,CAACkB,OAAO,CAACJ,IAAI,CAACK,MAAM,EAAEN,MAAM,CAAC,CAAC;EAClE,IAAIC,IAAI,CAACM,QAAQ,CAACC,OAAO,CAACL,UAAU,CAAC,KAAK,CAAC,CAAC,EAAE;IAC5C,OAAOD,EAAE,CAAC,IAAIO,KAAK,CAAC,kBAAkB,GAAGN,UAAU,CAAC,CAAC;EACvD;EACA,IAAIO,OAAO,GAAG,CAAC,CAAC;EAChB,IAAIT,IAAI,CAACU,KAAK,EAAE;IAAED,OAAO,CAACE,KAAK,GAAG,IAAI;EAAC;EACvC,IAAIX,IAAI,CAACY,IAAI,EAAEH,OAAO,CAACG,IAAI,GAAG1B,IAAI,CAACiB,SAAS,CAACjB,IAAI,CAACkB,OAAO,CAACJ,IAAI,CAACK,MAAM,EAAEL,IAAI,CAACY,IAAI,CAAC,CAAC;EAElF,IAAI,CAACZ,IAAI,CAACa,MAAM,EAAE;IAChBJ,OAAO,CAACE,KAAK,GAAG,IAAI;IACpB,OAAOpB,MAAM,CAACW,UAAU,EAAEO,OAAO,EAAER,EAAE,CAAC;EACxC;EAEA,IAAIa,MAAM,GAAGL,OAAO,CAACG,IAAI,GAAGH,OAAO,CAACG,IAAI,IAAI1B,IAAI,CAACiB,SAAS,CAACH,IAAI,CAACK,MAAM,CAAC;;EAEvE;EACA;EACAb,KAAK,CAAC,CACJ,CAACuB,YAAY,EAAED,MAAM,EAAEd,IAAI,CAACM,QAAQ,EAAEN,IAAI,CAACgB,GAAG,CAAC,EAC/C,CAACC,cAAc,EAAEf,UAAU,CAAC,EAC5B,CAACa,YAAY,EAAEb,UAAU,EAAEF,IAAI,CAACM,QAAQ,EAAEN,IAAI,CAACgB,GAAG,CAAC,EACnD,CAACD,YAAY,EAAEb,UAAU,EAAE,CAACY,MAAM,CAAC,EAAEd,IAAI,CAACgB,GAAG,CAAC,CAC/C,EAAE,UAAUE,EAAE,EAAEC,OAAO,EAAE;IACxB,IAAID,EAAE,EAAE;MACN,IAAIA,EAAE,CAACE,IAAI,KAAK,QAAQ,EAAE,OAAOnB,EAAE,EAAE;MACrC,OAAOA,EAAE,CAACiB,EAAE,CAAC;IACf;IACA,IAAIG,UAAU,GAAG;MACfnC,IAAI,EAAE4B,MAAM;MACZQ,OAAO,EAAEH,OAAO,CAAC,CAAC;IACpB,CAAC;IACD,IAAII,UAAU,GAAG;MACfrC,IAAI,EAAEgB,UAAU;MAChBsB,OAAO,EAAEL,OAAO,CAAC,CAAC,CAAC;MACnBG,OAAO,EAAEH,OAAO,CAAC,CAAC,CAAC;MACnBM,QAAQ,EAAEN,OAAO,CAAC,CAAC;IACrB,CAAC;IAEDO,UAAU,CAACL,UAAU,EAAEE,UAAU,EAAEvB,IAAI,CAAC2B,IAAI,EAAE3B,IAAI,CAACgB,GAAG,EAAErB,KAAK,CAACM,EAAE,EAAE2B,UAAU,CAAC,CAAC;IAE9E,SAASA,UAAUA,CAAEC,QAAQ,EAAEC,UAAU,EAAE;MACzC,IAAI,CAACD,QAAQ,EAAE,OAAO5B,EAAE,EAAE;MAC1B,IAAI6B,UAAU,EAAErB,OAAO,CAACG,IAAI,GAAGkB,UAAU;MACzC,OAAOvC,MAAM,CAACsC,QAAQ,EAAEpB,OAAO,EAAER,EAAE,CAAC;IACtC;EACF,CAAC,CAAC;AACJ;AAEAL,OAAO,CAACmC,WAAW,GAAGL,UAAU;AAChC,SAASA,UAAUA,CAAEZ,MAAM,EAAEf,MAAM,EAAEiC,OAAO,EAAEhB,GAAG,EAAEf,EAAE,EAAE;EACrDe,GAAG,CAACiB,KAAK,CAAC,UAAU,EAAE,eAAe,EAAEnB,MAAM,CAAC5B,IAAI,CAAC;EACnD8B,GAAG,CAACiB,KAAK,CAAC,UAAU,EAAE,kBAAkB,EACtCnB,MAAM,CAACQ,OAAO,IAAIR,MAAM,CAACQ,OAAO,CAACvB,MAAM,GAAG,SAAS,GAAGe,MAAM,CAACQ,OAAO,CAACpC,IAAI,CAAC;EAC5E8B,GAAG,CAACiB,KAAK,CAAC,UAAU,EAAE,gBAAgB,EAAElC,MAAM,CAACb,IAAI,CAAC;EACpD8B,GAAG,CAACiB,KAAK,CAAC,UAAU,EAAE,kBAAkB,EAAElC,MAAM,CAACyB,OAAO,CAAC;EACzDR,GAAG,CAACiB,KAAK,CAAC,UAAU,EAAE,kBAAkB,EACtClC,MAAM,CAACuB,OAAO,IAAIvB,MAAM,CAACuB,OAAO,CAACvB,MAAM,GAAG,SAAS,GAAGA,MAAM,CAACuB,OAAO,CAACpC,IAAI,CAAC;EAC5E8B,GAAG,CAACiB,KAAK,CAAC,UAAU,EAAE,oBAAoB,EAAElC,MAAM,CAAC0B,QAAQ,CAAC;;EAE5D;EACA;EACA,IAAI,CAACX,MAAM,CAACQ,OAAO,EAAE;IACnBN,GAAG,CAACkB,IAAI,CAAC,UAAU,EAAEpB,MAAM,CAAC5B,IAAI,EAC9B,oCAAoC,GAAG8C,OAAO,GAAG,0BAA0B,GAC3E,wBAAwB,CAAC;IAC3B,OAAO/B,EAAE,CAACkC,WAAW,CAACpC,MAAM,CAACb,IAAI,EAAE,kBAAkB,GAAG4B,MAAM,CAAC5B,IAAI,GACjE,eAAe,GAAG8C,OAAO,GAAG,YAAY,CAAC,CAAC;EAC9C;;EAEA;EACA;EACA,IAAIjC,MAAM,CAAC0B,QAAQ,EAAE;IACnB,IAAIW,YAAY,GAAGrC,MAAM,CAAC0B,QAAQ,CAAC1B,MAAM;IACzC,IAAIsC,aAAa,GAAGtC,MAAM,CAAC0B,QAAQ,CAACvC,IAAI;IACxC;IACA;IACA,IAAIa,MAAM,CAACb,IAAI,KAAKkD,YAAY,EAAE;MAChC,OAAOnC,EAAE,CAAC,IAAI,EAAEF,MAAM,CAACb,IAAI,EAAEmD,aAAa,CAAC;IAC7C,CAAC,MAAM;MACL;MACA;MACA,OAAOpC,EAAE,CAAC,IAAI,EAAEF,MAAM,CAACb,IAAI,EAAEA,IAAI,CAACoD,OAAO,CAACvC,MAAM,CAACb,IAAI,CAAC,CAAC;IACzD;EACF;;EAEA;EACA;EACA;EACA,IAAIa,MAAM,CAACuB,OAAO,IAAIvB,MAAM,CAACyB,OAAO,EAAE;IACpCR,GAAG,CAACuB,IAAI,CAAC,IAAI,EAAE,cAAc,EAAExC,MAAM,CAACb,IAAI,EACxC,2BAA2B,EAAE4B,MAAM,CAAC5B,IAAI,CAAC;IAC3C,OAAOe,EAAE,EAAE;EACb;EAEA,IAAIF,MAAM,CAACyB,OAAO,EAAE;IAClB,OAAOvB,EAAE,CAACkC,WAAW,CAACpC,MAAM,CAACb,IAAI,EAAEa,MAAM,CAACyB,OAAO,GAC/C,uCAAuC,GAAGQ,OAAO,GAAG,GAAG,GAAGlB,MAAM,CAAC5B,IAAI,CAAC,CAAC;EAC3E,CAAC,MAAM;IACL,OAAOe,EAAE,CAACkC,WAAW,CAACpC,MAAM,CAACb,IAAI,EAAE,aAAa,GAAG4B,MAAM,CAAC5B,IAAI,GAC5D,iBAAiB,CAAC,CAAC;EACvB;AACF;AAEA,SAASiD,WAAWA,CAAEpC,MAAM,EAAEyC,GAAG,EAAE;EACjCpD,QAAQ,CAAC,IAAI,EAAEqD,SAAS,CAAC;EACzB,IAAIvB,EAAE,GAAG,IAAIV,KAAK,CAAC,qBAAqB,GAAGT,MAAM,GAAG,IAAI,GAAGyC,GAAG,CAAC;EAC/DtB,EAAE,CAACE,IAAI,GAAG,QAAQ;EAClBF,EAAE,CAAChC,IAAI,GAAGa,MAAM;EAChB,OAAOmB,EAAE;AACX;AAEA,SAASwB,QAAQA,CAAEC,GAAG,EAAE;EACtB,OAAOA,GAAG,IAAIA,GAAG,CAACvB,IAAI,KAAK,QAAQ;AACrC;AAEA,SAASwB,SAASA,CAAED,GAAG,EAAE;EACvB,OAAO,CAACD,QAAQ,CAACC,GAAG,CAAC;AACvB;AAEA,SAASE,UAAUA,CAAE5C,EAAE,EAAE;EACvB,OAAO,UAAU0C,GAAG,EAAEG,KAAK,EAAE;IAC3B,IAAIJ,QAAQ,CAACC,GAAG,CAAC,EAAE;MACjB,OAAO1C,EAAE,CAAC,IAAI,EAAE,KAAK,CAAC;IACxB,CAAC,MAAM;MACL,OAAOA,EAAE,CAAC0C,GAAG,EAAEG,KAAK,CAAC;IACvB;EACF,CAAC;AACH;AAEA,SAASC,cAAcA,CAAEC,EAAE,EAAE;EAC3B,OAAO,YAAY;IACjB,IAAIC,IAAI,GAAGC,KAAK,CAACC,SAAS,CAACC,KAAK,CAACC,IAAI,CAACZ,SAAS,CAAC;IAChD,IAAIxC,EAAE,GAAGgD,IAAI,CAACK,GAAG,EAAE;IACnBL,IAAI,CAACM,IAAI,CAAC,UAAUZ,GAAG,EAAEG,KAAK,EAAE;MAC9B,IAAIH,GAAG,EAAE;QACP,OAAO1C,EAAE,CAAC,IAAI,EAAE0C,GAAG,CAAC;MACtB,CAAC,MAAM;QACL,OAAO1C,EAAE,CAAC,IAAI,EAAE6C,KAAK,CAAC;MACxB;IACF,CAAC,CAAC;IACFE,EAAE,CAACQ,KAAK,CAAC,IAAI,EAAEP,IAAI,CAAC;EACtB,CAAC;AACH;AAEA,SAASQ,UAAUA,CAAEX,KAAK,EAAE;EAC1B,OAAO,EAAEA,KAAK,YAAYtC,KAAK,CAAC;AAClC;AAEAZ,OAAO,CAAC8D,aAAa,GAAG3C,YAAY;AACpC;AACA;AACA,SAASA,YAAYA,CAAEhB,MAAM,EAAE4D,KAAK,EAAE3C,GAAG,EAAEf,EAAE,EAAE;EAC7Cb,QAAQ,CAAC,MAAM,EAAEqD,SAAS,CAAC;EAC3BhD,QAAQ,CAACkE,KAAK,EAAEZ,cAAc,CAACa,YAAY,CAAC,EAAEjE,KAAK,CAACM,EAAE,EAAE,UAAU4D,aAAa,EAAE;IAC/E,IAAIC,SAAS,GAAGD,aAAa,CAACE,MAAM,CAACN,UAAU,CAAC;IAChD,IAAIK,SAAS,CAACE,MAAM,KAAK,CAAC,EAAE;MAC1B,IAAIC,SAAS,GAAGJ,aAAa,CAACE,MAAM,CAACnB,SAAS,CAAC;MAC/C,IAAIqB,SAAS,CAACD,MAAM,KAAK,CAAC,EAAE;QAC1B,OAAO/D,EAAE,CAAC,IAAI,EAAE,KAAK,CAAC;MACxB,CAAC,MAAM;QACL,OAAOA,EAAE,CAACgE,SAAS,CAAC,CAAC,CAAC,CAAC;MACzB;IACF;IACAL,YAAY,CAAC7D,MAAM,EAAEJ,KAAK,CAACkD,UAAU,CAAC5C,EAAE,CAAC,EAAE,UAAUiE,OAAO,EAAE;MAC5DjE,EAAE,CAAC,IAAI,EAAEkE,eAAe,CAACD,OAAO,EAAEJ,SAAS,EAAE9C,GAAG,CAAC,CAAC;IACpD,CAAC,CAAC,CAAC;EACL,CAAC,CAAC,CAAC;AACL;AAEApB,OAAO,CAACwE,gBAAgB,GAAGD,eAAe;AAC1C;AACA,SAASA,eAAeA,CAAED,OAAO,EAAEP,KAAK,EAAE3C,GAAG,EAAE;EAC7C5B,QAAQ,CAAC,KAAK,EAAEqD,SAAS,CAAC;EAC1B,IAAI4B,OAAO,GAAG,EAAE;EAChBV,KAAK,CAACW,OAAO,CAAC,UAAUpF,IAAI,EAAE;IAC5BgF,OAAO,CAACI,OAAO,CAAC,UAAUvE,MAAM,EAAE;MAChCsE,OAAO,CAACd,IAAI,CAAC,CAACxD,MAAM,EAAEb,IAAI,CAAC,CAAC;IAC9B,CAAC,CAAC;EACJ,CAAC,CAAC;EACF,KAAK,IAAIqF,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGF,OAAO,CAACL,MAAM,EAAE,EAAEO,EAAE,EAAE;IAC1C,IAAIxE,MAAM,GAAGsE,OAAO,CAACE,EAAE,CAAC,CAAC,CAAC,CAAC;IAC3B,IAAIrF,IAAI,GAAGmF,OAAO,CAACE,EAAE,CAAC,CAAC,CAAC,CAAC;IACzB,IAAIC,MAAM,GAAGlF,QAAQ,CAACS,MAAM,EAAEb,IAAI,CAAC;IACnC,IAAI,CAACsF,MAAM,EAAExD,GAAG,CAACiB,KAAK,CAAC,cAAc,EAAElC,MAAM,EAAE,eAAe,EAAEb,IAAI,CAAC;IACrE,IAAIsF,MAAM,IAAItF,IAAI,EAAE,OAAOsF,MAAM,IAAItF,IAAI,IAAI;MAACa,MAAM,EAAEA,MAAM;MAAEb,IAAI,EAAEA;IAAI,CAAC;EAC3E;EACA,OAAO,KAAK;AACd;AAEAU,OAAO,CAAC6E,aAAa,GAAGb,YAAY;AACpC;AACA;AACA;AACA,SAASA,YAAYA,CAAE1E,IAAI,EAAEe,EAAE,EAAE;EAC/Bb,QAAQ,CAAC,IAAI,EAAEqD,SAAS,CAAC;EACzB,IAAIiC,IAAI,GAAG,CAAC,CAAC;EACbD,aAAa,CAACvF,IAAI,CAAC;EAEnB,SAASuF,aAAaA,CAAEvF,IAAI,EAAE;IAC5B,IAAIwF,IAAI,CAACxF,IAAI,CAAC,EAAE,OAAOe,EAAE,CAAC,IAAI,EAAE0E,MAAM,CAACC,IAAI,CAACF,IAAI,CAAC,CAAC;IAClDA,IAAI,CAACxF,IAAI,CAAC,GAAG,IAAI;IACjB2F,cAAc,CAAC3F,IAAI,EAAES,KAAK,CAACM,EAAE,EAAEwE,aAAa,CAAC,CAAC;EAChD;AACF;AAEA7E,OAAO,CAACkF,eAAe,GAAGD,cAAc;AACxC,IAAIhB,aAAa,GAAG,CAAC,CAAC;AACtB,SAASgB,cAAcA,CAAErD,OAAO,EAAEvB,EAAE,EAAE;EACpCb,QAAQ,CAAC,IAAI,EAAEqD,SAAS,CAAC;EACzB,IAAIsC,MAAM,GAAGlB,aAAa,CAACrC,OAAO,CAAC;EACnC,IAAIuD,MAAM,EAAE,OAAO9E,EAAE,CAAC,IAAI,EAAE8E,MAAM,CAAC;EAEnC9D,cAAc,CAACO,OAAO,EAAE7B,KAAK,CAACM,EAAE,EAAE,UAAU+E,aAAa,EAAE;IACzD,IAAIA,aAAa,EAAE;MACjBnB,aAAa,CAACrC,OAAO,CAAC,GAAGtC,IAAI,CAACkB,OAAO,CAAClB,IAAI,CAACoD,OAAO,CAACd,OAAO,CAAC,EAAEwD,aAAa,CAAC;IAC7E,CAAC,MAAM;MACLnB,aAAa,CAACrC,OAAO,CAAC,GAAGA,OAAO;IAClC;IACA,OAAOvB,EAAE,CAAC,IAAI,EAAE4D,aAAa,CAACrC,OAAO,CAAC,CAAC;EACzC,CAAC,CAAC,CAAC;AACL;AAEA5B,OAAO,CAACqF,eAAe,GAAGhE,cAAc;AACxC,SAASA,cAAcA,CAAE/B,IAAI,EAAEe,EAAE,EAAE;EACjCb,QAAQ,CAAC,IAAI,EAAEqD,SAAS,CAAC;EACzBpD,EAAE,CAAC6F,KAAK,CAAChG,IAAI,EAAES,KAAK,CAACM,EAAE,EAAE,UAAUkF,IAAI,EAAE;IACvC,IAAIA,IAAI,CAACC,cAAc,EAAE,EAAE;MACzB/F,EAAE,CAACgG,QAAQ,CAACnG,IAAI,EAAEe,EAAE,CAAC;IACvB,CAAC,MAAM;MACLP,WAAW,CAACR,IAAI,EAAE,UAAUgC,EAAE,EAAEoE,MAAM,EAAE;QACtC,IAAI,CAACpE,EAAE,EAAE,OAAOjB,EAAE,CAAC,IAAI,EAAEqF,MAAM,CAAC;QAChC;QACA,IAAIpE,EAAE,CAACE,IAAI,KAAK,WAAW,IAAIF,EAAE,CAACE,IAAI,KAAK,QAAQ,EAAE;UACnD,OAAOnB,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC;QACvB,CAAC,MAAM;UACL,OAAOA,EAAE,CAACiB,EAAE,CAAC;QACf;MACF,CAAC,CAAC;IACJ;EACF,CAAC,CAAC,CAAC;AACL"},"metadata":{},"sourceType":"script","externalDependencies":[]}