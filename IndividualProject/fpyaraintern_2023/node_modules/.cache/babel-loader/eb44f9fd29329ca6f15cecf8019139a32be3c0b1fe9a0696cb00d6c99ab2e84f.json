{"ast":null,"code":"'use strict';\n\n// this[BUFFER] is the remainder of a chunk if we're waiting for\n// the full 512 bytes of a header to come in.  We will Buffer.concat()\n// it to the next write(), which is a mem copy, but a small one.\n//\n// this[QUEUE] is a Yallist of entries that haven't been emitted\n// yet this can only get filled up if the user keeps write()ing after\n// a write() returns false, or does a write() with more than one entry\n//\n// We don't buffer chunks, we always parse them and either create an\n// entry, or push it into the active entry.  The ReadEntry class knows\n// to throw data away if .ignore=true\n//\n// Shift entry off the buffer when it emits 'end', and emit 'entry' for\n// the next one in the list.\n//\n// At any time, we're pushing body chunks into the entry at WRITEENTRY,\n// and waiting for 'end' on the entry at READENTRY\n//\n// ignored entries get .resume() called on them straight away\nconst warner = require('./warn-mixin.js');\nconst path = require('path');\nconst Header = require('./header.js');\nconst EE = require('events');\nconst Yallist = require('yallist');\nconst maxMetaEntrySize = 1024 * 1024;\nconst Entry = require('./read-entry.js');\nconst Pax = require('./pax.js');\nconst zlib = require('minizlib');\nconst Buffer = require('./buffer.js');\nconst gzipHeader = Buffer.from([0x1f, 0x8b]);\nconst STATE = Symbol('state');\nconst WRITEENTRY = Symbol('writeEntry');\nconst READENTRY = Symbol('readEntry');\nconst NEXTENTRY = Symbol('nextEntry');\nconst PROCESSENTRY = Symbol('processEntry');\nconst EX = Symbol('extendedHeader');\nconst GEX = Symbol('globalExtendedHeader');\nconst META = Symbol('meta');\nconst EMITMETA = Symbol('emitMeta');\nconst BUFFER = Symbol('buffer');\nconst QUEUE = Symbol('queue');\nconst ENDED = Symbol('ended');\nconst EMITTEDEND = Symbol('emittedEnd');\nconst EMIT = Symbol('emit');\nconst UNZIP = Symbol('unzip');\nconst CONSUMECHUNK = Symbol('consumeChunk');\nconst CONSUMECHUNKSUB = Symbol('consumeChunkSub');\nconst CONSUMEBODY = Symbol('consumeBody');\nconst CONSUMEMETA = Symbol('consumeMeta');\nconst CONSUMEHEADER = Symbol('consumeHeader');\nconst CONSUMING = Symbol('consuming');\nconst BUFFERCONCAT = Symbol('bufferConcat');\nconst MAYBEEND = Symbol('maybeEnd');\nconst WRITING = Symbol('writing');\nconst ABORTED = Symbol('aborted');\nconst DONE = Symbol('onDone');\nconst noop = _ => true;\nmodule.exports = warner(class Parser extends EE {\n  constructor(opt) {\n    opt = opt || {};\n    super(opt);\n    if (opt.ondone) this.on(DONE, opt.ondone);else this.on(DONE, _ => {\n      this.emit('prefinish');\n      this.emit('finish');\n      this.emit('end');\n      this.emit('close');\n    });\n    this.strict = !!opt.strict;\n    this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize;\n    this.filter = typeof opt.filter === 'function' ? opt.filter : noop;\n\n    // have to set this so that streams are ok piping into it\n    this.writable = true;\n    this.readable = false;\n    this[QUEUE] = new Yallist();\n    this[BUFFER] = null;\n    this[READENTRY] = null;\n    this[WRITEENTRY] = null;\n    this[STATE] = 'begin';\n    this[META] = '';\n    this[EX] = null;\n    this[GEX] = null;\n    this[ENDED] = false;\n    this[UNZIP] = null;\n    this[ABORTED] = false;\n    if (typeof opt.onwarn === 'function') this.on('warn', opt.onwarn);\n    if (typeof opt.onentry === 'function') this.on('entry', opt.onentry);\n  }\n  [CONSUMEHEADER](chunk, position) {\n    let header;\n    try {\n      header = new Header(chunk, position, this[EX], this[GEX]);\n    } catch (er) {\n      return this.warn('invalid entry', er);\n    }\n    if (header.nullBlock) this[EMIT]('nullBlock');else if (!header.cksumValid) this.warn('invalid entry', header);else if (!header.path) this.warn('invalid: path is required', header);else {\n      const type = header.type;\n      if (/^(Symbolic)?Link$/.test(type) && !header.linkpath) this.warn('invalid: linkpath required', header);else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath) this.warn('invalid: linkpath forbidden', header);else {\n        const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX]);\n        if (entry.meta) {\n          if (entry.size > this.maxMetaEntrySize) {\n            entry.ignore = true;\n            this[EMIT]('ignoredEntry', entry);\n            this[STATE] = 'ignore';\n          } else if (entry.size > 0) {\n            this[META] = '';\n            entry.on('data', c => this[META] += c);\n            this[STATE] = 'meta';\n          }\n        } else {\n          this[EX] = null;\n          entry.ignore = entry.ignore || !this.filter(entry.path, entry);\n          if (entry.ignore) {\n            this[EMIT]('ignoredEntry', entry);\n            this[STATE] = entry.remain ? 'ignore' : 'begin';\n          } else {\n            if (entry.remain) this[STATE] = 'body';else {\n              this[STATE] = 'begin';\n              entry.end();\n            }\n            if (!this[READENTRY]) {\n              this[QUEUE].push(entry);\n              this[NEXTENTRY]();\n            } else this[QUEUE].push(entry);\n          }\n        }\n      }\n    }\n  }\n  [PROCESSENTRY](entry) {\n    let go = true;\n    if (!entry) {\n      this[READENTRY] = null;\n      go = false;\n    } else if (Array.isArray(entry)) this.emit.apply(this, entry);else {\n      this[READENTRY] = entry;\n      this.emit('entry', entry);\n      if (!entry.emittedEnd) {\n        entry.on('end', _ => this[NEXTENTRY]());\n        go = false;\n      }\n    }\n    return go;\n  }\n  [NEXTENTRY]() {\n    do {} while (this[PROCESSENTRY](this[QUEUE].shift()));\n    if (!this[QUEUE].length) {\n      // At this point, there's nothing in the queue, but we may have an\n      // entry which is being consumed (readEntry).\n      // If we don't, then we definitely can handle more data.\n      // If we do, and either it's flowing, or it has never had any data\n      // written to it, then it needs more.\n      // The only other possibility is that it has returned false from a\n      // write() call, so we wait for the next drain to continue.\n      const re = this[READENTRY];\n      const drainNow = !re || re.flowing || re.size === re.remain;\n      if (drainNow) {\n        if (!this[WRITING]) this.emit('drain');\n      } else re.once('drain', _ => this.emit('drain'));\n    }\n  }\n  [CONSUMEBODY](chunk, position) {\n    // write up to but no  more than writeEntry.blockRemain\n    const entry = this[WRITEENTRY];\n    const br = entry.blockRemain;\n    const c = br >= chunk.length && position === 0 ? chunk : chunk.slice(position, position + br);\n    entry.write(c);\n    if (!entry.blockRemain) {\n      this[STATE] = 'begin';\n      this[WRITEENTRY] = null;\n      entry.end();\n    }\n    return c.length;\n  }\n  [CONSUMEMETA](chunk, position) {\n    const entry = this[WRITEENTRY];\n    const ret = this[CONSUMEBODY](chunk, position);\n\n    // if we finished, then the entry is reset\n    if (!this[WRITEENTRY]) this[EMITMETA](entry);\n    return ret;\n  }\n  [EMIT](ev, data, extra) {\n    if (!this[QUEUE].length && !this[READENTRY]) this.emit(ev, data, extra);else this[QUEUE].push([ev, data, extra]);\n  }\n  [EMITMETA](entry) {\n    this[EMIT]('meta', this[META]);\n    switch (entry.type) {\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this[EX] = Pax.parse(this[META], this[EX], false);\n        break;\n      case 'GlobalExtendedHeader':\n        this[GEX] = Pax.parse(this[META], this[GEX], true);\n        break;\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n        this[EX] = this[EX] || Object.create(null);\n        this[EX].path = this[META].replace(/\\0.*/, '');\n        break;\n      case 'NextFileHasLongLinkpath':\n        this[EX] = this[EX] || Object.create(null);\n        this[EX].linkpath = this[META].replace(/\\0.*/, '');\n        break;\n\n      /* istanbul ignore next */\n      default:\n        throw new Error('unknown meta: ' + entry.type);\n    }\n  }\n  abort(msg, error) {\n    this[ABORTED] = true;\n    this.warn(msg, error);\n    this.emit('abort', error);\n    this.emit('error', error);\n  }\n  write(chunk) {\n    if (this[ABORTED]) return;\n\n    // first write, might be gzipped\n    if (this[UNZIP] === null && chunk) {\n      if (this[BUFFER]) {\n        chunk = Buffer.concat([this[BUFFER], chunk]);\n        this[BUFFER] = null;\n      }\n      if (chunk.length < gzipHeader.length) {\n        this[BUFFER] = chunk;\n        return true;\n      }\n      for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {\n        if (chunk[i] !== gzipHeader[i]) this[UNZIP] = false;\n      }\n      if (this[UNZIP] === null) {\n        const ended = this[ENDED];\n        this[ENDED] = false;\n        this[UNZIP] = new zlib.Unzip();\n        this[UNZIP].on('data', chunk => this[CONSUMECHUNK](chunk));\n        this[UNZIP].on('error', er => this.abort(er.message, er));\n        this[UNZIP].on('end', _ => {\n          this[ENDED] = true;\n          this[CONSUMECHUNK]();\n        });\n        this[WRITING] = true;\n        const ret = this[UNZIP][ended ? 'end' : 'write'](chunk);\n        this[WRITING] = false;\n        return ret;\n      }\n    }\n    this[WRITING] = true;\n    if (this[UNZIP]) this[UNZIP].write(chunk);else this[CONSUMECHUNK](chunk);\n    this[WRITING] = false;\n\n    // return false if there's a queue, or if the current entry isn't flowing\n    const ret = this[QUEUE].length ? false : this[READENTRY] ? this[READENTRY].flowing : true;\n\n    // if we have no queue, then that means a clogged READENTRY\n    if (!ret && !this[QUEUE].length) this[READENTRY].once('drain', _ => this.emit('drain'));\n    return ret;\n  }\n  [BUFFERCONCAT](c) {\n    if (c && !this[ABORTED]) this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c;\n  }\n  [MAYBEEND]() {\n    if (this[ENDED] && !this[EMITTEDEND] && !this[ABORTED] && !this[CONSUMING]) {\n      this[EMITTEDEND] = true;\n      const entry = this[WRITEENTRY];\n      if (entry && entry.blockRemain) {\n        const have = this[BUFFER] ? this[BUFFER].length : 0;\n        this.warn('Truncated input (needed ' + entry.blockRemain + ' more bytes, only ' + have + ' available)', entry);\n        if (this[BUFFER]) entry.write(this[BUFFER]);\n        entry.end();\n      }\n      this[EMIT](DONE);\n    }\n  }\n  [CONSUMECHUNK](chunk) {\n    if (this[CONSUMING]) {\n      this[BUFFERCONCAT](chunk);\n    } else if (!chunk && !this[BUFFER]) {\n      this[MAYBEEND]();\n    } else {\n      this[CONSUMING] = true;\n      if (this[BUFFER]) {\n        this[BUFFERCONCAT](chunk);\n        const c = this[BUFFER];\n        this[BUFFER] = null;\n        this[CONSUMECHUNKSUB](c);\n      } else {\n        this[CONSUMECHUNKSUB](chunk);\n      }\n      while (this[BUFFER] && this[BUFFER].length >= 512 && !this[ABORTED]) {\n        const c = this[BUFFER];\n        this[BUFFER] = null;\n        this[CONSUMECHUNKSUB](c);\n      }\n      this[CONSUMING] = false;\n    }\n    if (!this[BUFFER] || this[ENDED]) this[MAYBEEND]();\n  }\n  [CONSUMECHUNKSUB](chunk) {\n    // we know that we are in CONSUMING mode, so anything written goes into\n    // the buffer.  Advance the position and put any remainder in the buffer.\n    let position = 0;\n    let length = chunk.length;\n    while (position + 512 <= length && !this[ABORTED]) {\n      switch (this[STATE]) {\n        case 'begin':\n          this[CONSUMEHEADER](chunk, position);\n          position += 512;\n          break;\n        case 'ignore':\n        case 'body':\n          position += this[CONSUMEBODY](chunk, position);\n          break;\n        case 'meta':\n          position += this[CONSUMEMETA](chunk, position);\n          break;\n\n        /* istanbul ignore next */\n        default:\n          throw new Error('invalid state: ' + this[STATE]);\n      }\n    }\n    if (position < length) {\n      if (this[BUFFER]) this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]]);else this[BUFFER] = chunk.slice(position);\n    }\n  }\n  end(chunk) {\n    if (!this[ABORTED]) {\n      if (this[UNZIP]) this[UNZIP].end(chunk);else {\n        this[ENDED] = true;\n        this.write(chunk);\n      }\n    }\n  }\n});","map":{"version":3,"names":["warner","require","path","Header","EE","Yallist","maxMetaEntrySize","Entry","Pax","zlib","Buffer","gzipHeader","from","STATE","Symbol","WRITEENTRY","READENTRY","NEXTENTRY","PROCESSENTRY","EX","GEX","META","EMITMETA","BUFFER","QUEUE","ENDED","EMITTEDEND","EMIT","UNZIP","CONSUMECHUNK","CONSUMECHUNKSUB","CONSUMEBODY","CONSUMEMETA","CONSUMEHEADER","CONSUMING","BUFFERCONCAT","MAYBEEND","WRITING","ABORTED","DONE","noop","_","module","exports","Parser","constructor","opt","ondone","on","emit","strict","filter","writable","readable","onwarn","onentry","chunk","position","header","er","warn","nullBlock","cksumValid","type","test","linkpath","entry","meta","size","ignore","c","remain","end","push","go","Array","isArray","apply","emittedEnd","shift","length","re","drainNow","flowing","once","br","blockRemain","slice","write","ret","ev","data","extra","parse","Object","create","replace","Error","abort","msg","error","concat","i","ended","Unzip","message","have"],"sources":["/Users/hkateliev/node_modules/npm/node_modules/tar/lib/parse.js"],"sourcesContent":["'use strict'\n\n// this[BUFFER] is the remainder of a chunk if we're waiting for\n// the full 512 bytes of a header to come in.  We will Buffer.concat()\n// it to the next write(), which is a mem copy, but a small one.\n//\n// this[QUEUE] is a Yallist of entries that haven't been emitted\n// yet this can only get filled up if the user keeps write()ing after\n// a write() returns false, or does a write() with more than one entry\n//\n// We don't buffer chunks, we always parse them and either create an\n// entry, or push it into the active entry.  The ReadEntry class knows\n// to throw data away if .ignore=true\n//\n// Shift entry off the buffer when it emits 'end', and emit 'entry' for\n// the next one in the list.\n//\n// At any time, we're pushing body chunks into the entry at WRITEENTRY,\n// and waiting for 'end' on the entry at READENTRY\n//\n// ignored entries get .resume() called on them straight away\n\nconst warner = require('./warn-mixin.js')\nconst path = require('path')\nconst Header = require('./header.js')\nconst EE = require('events')\nconst Yallist = require('yallist')\nconst maxMetaEntrySize = 1024 * 1024\nconst Entry = require('./read-entry.js')\nconst Pax = require('./pax.js')\nconst zlib = require('minizlib')\nconst Buffer = require('./buffer.js')\n\nconst gzipHeader = Buffer.from([0x1f, 0x8b])\nconst STATE = Symbol('state')\nconst WRITEENTRY = Symbol('writeEntry')\nconst READENTRY = Symbol('readEntry')\nconst NEXTENTRY = Symbol('nextEntry')\nconst PROCESSENTRY = Symbol('processEntry')\nconst EX = Symbol('extendedHeader')\nconst GEX = Symbol('globalExtendedHeader')\nconst META = Symbol('meta')\nconst EMITMETA = Symbol('emitMeta')\nconst BUFFER = Symbol('buffer')\nconst QUEUE = Symbol('queue')\nconst ENDED = Symbol('ended')\nconst EMITTEDEND = Symbol('emittedEnd')\nconst EMIT = Symbol('emit')\nconst UNZIP = Symbol('unzip')\nconst CONSUMECHUNK = Symbol('consumeChunk')\nconst CONSUMECHUNKSUB = Symbol('consumeChunkSub')\nconst CONSUMEBODY = Symbol('consumeBody')\nconst CONSUMEMETA = Symbol('consumeMeta')\nconst CONSUMEHEADER = Symbol('consumeHeader')\nconst CONSUMING = Symbol('consuming')\nconst BUFFERCONCAT = Symbol('bufferConcat')\nconst MAYBEEND = Symbol('maybeEnd')\nconst WRITING = Symbol('writing')\nconst ABORTED = Symbol('aborted')\nconst DONE = Symbol('onDone')\n\nconst noop = _ => true\n\nmodule.exports = warner(class Parser extends EE {\n  constructor (opt) {\n    opt = opt || {}\n    super(opt)\n\n    if (opt.ondone)\n      this.on(DONE, opt.ondone)\n    else\n      this.on(DONE, _ => {\n        this.emit('prefinish')\n        this.emit('finish')\n        this.emit('end')\n        this.emit('close')\n      })\n\n    this.strict = !!opt.strict\n    this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize\n    this.filter = typeof opt.filter === 'function' ? opt.filter : noop\n\n    // have to set this so that streams are ok piping into it\n    this.writable = true\n    this.readable = false\n\n    this[QUEUE] = new Yallist()\n    this[BUFFER] = null\n    this[READENTRY] = null\n    this[WRITEENTRY] = null\n    this[STATE] = 'begin'\n    this[META] = ''\n    this[EX] = null\n    this[GEX] = null\n    this[ENDED] = false\n    this[UNZIP] = null\n    this[ABORTED] = false\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n    if (typeof opt.onentry === 'function')\n      this.on('entry', opt.onentry)\n  }\n\n  [CONSUMEHEADER] (chunk, position) {\n    let header\n    try {\n      header = new Header(chunk, position, this[EX], this[GEX])\n    } catch (er) {\n      return this.warn('invalid entry', er)\n    }\n\n    if (header.nullBlock)\n      this[EMIT]('nullBlock')\n    else if (!header.cksumValid)\n      this.warn('invalid entry', header)\n    else if (!header.path)\n      this.warn('invalid: path is required', header)\n    else {\n      const type = header.type\n      if (/^(Symbolic)?Link$/.test(type) && !header.linkpath)\n        this.warn('invalid: linkpath required', header)\n      else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath)\n        this.warn('invalid: linkpath forbidden', header)\n      else {\n        const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX])\n\n        if (entry.meta) {\n          if (entry.size > this.maxMetaEntrySize) {\n            entry.ignore = true\n            this[EMIT]('ignoredEntry', entry)\n            this[STATE] = 'ignore'\n          } else if (entry.size > 0) {\n            this[META] = ''\n            entry.on('data', c => this[META] += c)\n            this[STATE] = 'meta'\n          }\n        } else {\n\n          this[EX] = null\n          entry.ignore = entry.ignore || !this.filter(entry.path, entry)\n          if (entry.ignore) {\n            this[EMIT]('ignoredEntry', entry)\n            this[STATE] = entry.remain ? 'ignore' : 'begin'\n          } else {\n            if (entry.remain)\n              this[STATE] = 'body'\n            else {\n              this[STATE] = 'begin'\n              entry.end()\n            }\n\n            if (!this[READENTRY]) {\n              this[QUEUE].push(entry)\n              this[NEXTENTRY]()\n            } else\n              this[QUEUE].push(entry)\n          }\n        }\n      }\n    }\n  }\n\n  [PROCESSENTRY] (entry) {\n    let go = true\n\n    if (!entry) {\n      this[READENTRY] = null\n      go = false\n    } else if (Array.isArray(entry))\n      this.emit.apply(this, entry)\n    else {\n      this[READENTRY] = entry\n      this.emit('entry', entry)\n      if (!entry.emittedEnd) {\n        entry.on('end', _ => this[NEXTENTRY]())\n        go = false\n      }\n    }\n\n    return go\n  }\n\n  [NEXTENTRY] () {\n    do {} while (this[PROCESSENTRY](this[QUEUE].shift()))\n\n    if (!this[QUEUE].length) {\n      // At this point, there's nothing in the queue, but we may have an\n      // entry which is being consumed (readEntry).\n      // If we don't, then we definitely can handle more data.\n      // If we do, and either it's flowing, or it has never had any data\n      // written to it, then it needs more.\n      // The only other possibility is that it has returned false from a\n      // write() call, so we wait for the next drain to continue.\n      const re = this[READENTRY]\n      const drainNow = !re || re.flowing || re.size === re.remain\n      if (drainNow) {\n        if (!this[WRITING])\n          this.emit('drain')\n      } else\n        re.once('drain', _ => this.emit('drain'))\n     }\n  }\n\n  [CONSUMEBODY] (chunk, position) {\n    // write up to but no  more than writeEntry.blockRemain\n    const entry = this[WRITEENTRY]\n    const br = entry.blockRemain\n    const c = (br >= chunk.length && position === 0) ? chunk\n      : chunk.slice(position, position + br)\n\n    entry.write(c)\n\n    if (!entry.blockRemain) {\n      this[STATE] = 'begin'\n      this[WRITEENTRY] = null\n      entry.end()\n    }\n\n    return c.length\n  }\n\n  [CONSUMEMETA] (chunk, position) {\n    const entry = this[WRITEENTRY]\n    const ret = this[CONSUMEBODY](chunk, position)\n\n    // if we finished, then the entry is reset\n    if (!this[WRITEENTRY])\n      this[EMITMETA](entry)\n\n    return ret\n  }\n\n  [EMIT] (ev, data, extra) {\n    if (!this[QUEUE].length && !this[READENTRY])\n      this.emit(ev, data, extra)\n    else\n      this[QUEUE].push([ev, data, extra])\n  }\n\n  [EMITMETA] (entry) {\n    this[EMIT]('meta', this[META])\n    switch (entry.type) {\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this[EX] = Pax.parse(this[META], this[EX], false)\n        break\n\n      case 'GlobalExtendedHeader':\n        this[GEX] = Pax.parse(this[META], this[GEX], true)\n        break\n\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n        this[EX] = this[EX] || Object.create(null)\n        this[EX].path = this[META].replace(/\\0.*/, '')\n        break\n\n      case 'NextFileHasLongLinkpath':\n        this[EX] = this[EX] || Object.create(null)\n        this[EX].linkpath = this[META].replace(/\\0.*/, '')\n        break\n\n      /* istanbul ignore next */\n      default: throw new Error('unknown meta: ' + entry.type)\n    }\n  }\n\n  abort (msg, error) {\n    this[ABORTED] = true\n    this.warn(msg, error)\n    this.emit('abort', error)\n    this.emit('error', error)\n  }\n\n  write (chunk) {\n    if (this[ABORTED])\n      return\n\n    // first write, might be gzipped\n    if (this[UNZIP] === null && chunk) {\n      if (this[BUFFER]) {\n        chunk = Buffer.concat([this[BUFFER], chunk])\n        this[BUFFER] = null\n      }\n      if (chunk.length < gzipHeader.length) {\n        this[BUFFER] = chunk\n        return true\n      }\n      for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {\n        if (chunk[i] !== gzipHeader[i])\n          this[UNZIP] = false\n      }\n      if (this[UNZIP] === null) {\n        const ended = this[ENDED]\n        this[ENDED] = false\n        this[UNZIP] = new zlib.Unzip()\n        this[UNZIP].on('data', chunk => this[CONSUMECHUNK](chunk))\n        this[UNZIP].on('error', er =>\n          this.abort(er.message, er))\n        this[UNZIP].on('end', _ => {\n          this[ENDED] = true\n          this[CONSUMECHUNK]()\n        })\n        this[WRITING] = true\n        const ret = this[UNZIP][ended ? 'end' : 'write' ](chunk)\n        this[WRITING] = false\n        return ret\n      }\n    }\n\n    this[WRITING] = true\n    if (this[UNZIP])\n      this[UNZIP].write(chunk)\n    else\n      this[CONSUMECHUNK](chunk)\n    this[WRITING] = false\n\n    // return false if there's a queue, or if the current entry isn't flowing\n    const ret =\n      this[QUEUE].length ? false :\n      this[READENTRY] ? this[READENTRY].flowing :\n      true\n\n    // if we have no queue, then that means a clogged READENTRY\n    if (!ret && !this[QUEUE].length)\n      this[READENTRY].once('drain', _ => this.emit('drain'))\n\n    return ret\n  }\n\n  [BUFFERCONCAT] (c) {\n    if (c && !this[ABORTED])\n      this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c\n  }\n\n  [MAYBEEND] () {\n    if (this[ENDED] &&\n        !this[EMITTEDEND] &&\n        !this[ABORTED] &&\n        !this[CONSUMING]) {\n      this[EMITTEDEND] = true\n      const entry = this[WRITEENTRY]\n      if (entry && entry.blockRemain) {\n        const have = this[BUFFER] ? this[BUFFER].length : 0\n        this.warn('Truncated input (needed ' + entry.blockRemain +\n                  ' more bytes, only ' + have + ' available)', entry)\n        if (this[BUFFER])\n          entry.write(this[BUFFER])\n        entry.end()\n      }\n      this[EMIT](DONE)\n    }\n  }\n\n  [CONSUMECHUNK] (chunk) {\n    if (this[CONSUMING]) {\n      this[BUFFERCONCAT](chunk)\n    } else if (!chunk && !this[BUFFER]) {\n      this[MAYBEEND]()\n    } else {\n      this[CONSUMING] = true\n      if (this[BUFFER]) {\n        this[BUFFERCONCAT](chunk)\n        const c = this[BUFFER]\n        this[BUFFER] = null\n        this[CONSUMECHUNKSUB](c)\n      } else {\n        this[CONSUMECHUNKSUB](chunk)\n      }\n\n      while (this[BUFFER] && this[BUFFER].length >= 512 && !this[ABORTED]) {\n        const c = this[BUFFER]\n        this[BUFFER] = null\n        this[CONSUMECHUNKSUB](c)\n      }\n      this[CONSUMING] = false\n    }\n\n    if (!this[BUFFER] || this[ENDED])\n      this[MAYBEEND]()\n  }\n\n  [CONSUMECHUNKSUB] (chunk) {\n    // we know that we are in CONSUMING mode, so anything written goes into\n    // the buffer.  Advance the position and put any remainder in the buffer.\n    let position = 0\n    let length = chunk.length\n    while (position + 512 <= length && !this[ABORTED]) {\n      switch (this[STATE]) {\n        case 'begin':\n          this[CONSUMEHEADER](chunk, position)\n          position += 512\n          break\n\n        case 'ignore':\n        case 'body':\n          position += this[CONSUMEBODY](chunk, position)\n          break\n\n        case 'meta':\n          position += this[CONSUMEMETA](chunk, position)\n          break\n\n        /* istanbul ignore next */\n        default:\n          throw new Error('invalid state: ' + this[STATE])\n      }\n    }\n\n    if (position < length) {\n      if (this[BUFFER])\n        this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]])\n      else\n        this[BUFFER] = chunk.slice(position)\n    }\n  }\n\n  end (chunk) {\n    if (!this[ABORTED]) {\n      if (this[UNZIP])\n        this[UNZIP].end(chunk)\n      else {\n        this[ENDED] = true\n        this.write(chunk)\n      }\n    }\n  }\n})\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}