{"ast":null,"code":"'use strict';\n\nconst BB = require('bluebird');\nconst cacache = require('cacache');\nconst fetch = require('./fetch.js');\nconst fs = require('fs');\nconst npa = require('npm-package-arg');\nconst optCheck = require('./util/opt-check.js');\nconst path = require('path');\nconst ssri = require('ssri');\nconst retry = require('promise-retry');\nconst statAsync = BB.promisify(fs.stat);\nconst RETRIABLE_ERRORS = new Set(['ENOENT', 'EINTEGRITY', 'Z_DATA_ERROR']);\nmodule.exports = withTarballStream;\nfunction withTarballStream(spec, opts, streamHandler) {\n  opts = optCheck(opts);\n  spec = npa(spec, opts.where);\n\n  // First, we check for a file: resolved shortcut\n  const tryFile = !opts.preferOnline && opts.integrity && opts.resolved && opts.resolved.startsWith('file:') ? BB.try(() => {\n    // NOTE - this is a special shortcut! Packages installed as files do not\n    // have a `resolved` field -- this specific case only occurs when you have,\n    // say, a git dependency or a registry dependency that you've packaged into\n    // a local file, and put that file: spec in the `resolved` field.\n    opts.log.silly('pacote', `trying ${spec} by local file: ${opts.resolved}`);\n    const file = path.resolve(opts.where || '.', opts.resolved.substr(5));\n    return statAsync(file).then(() => {\n      const verifier = ssri.integrityStream({\n        integrity: opts.integrity\n      });\n      const stream = fs.createReadStream(file).on('error', err => verifier.emit('error', err)).pipe(verifier);\n      return streamHandler(stream);\n    }).catch(err => {\n      if (err.code === 'EINTEGRITY') {\n        opts.log.warn('pacote', `EINTEGRITY while extracting ${spec} from ${file}.You will have to recreate the file.`);\n        opts.log.verbose('pacote', `EINTEGRITY for ${spec}: ${err.message}`);\n      }\n      throw err;\n    });\n  }) : BB.reject(Object.assign(new Error('no file!'), {\n    code: 'ENOENT'\n  }));\n  const tryDigest = tryFile.catch(err => {\n    if (opts.preferOnline || !opts.cache || !opts.integrity || !RETRIABLE_ERRORS.has(err.code)) {\n      throw err;\n    } else {\n      opts.log.silly('tarball', `trying ${spec} by hash: ${opts.integrity}`);\n      const stream = cacache.get.stream.byDigest(opts.cache, opts.integrity, opts);\n      stream.once('error', err => stream.on('newListener', (ev, l) => {\n        if (ev === 'error') {\n          l(err);\n        }\n      }));\n      return streamHandler(stream).catch(err => {\n        if (err.code === 'EINTEGRITY' || err.code === 'Z_DATA_ERROR') {\n          opts.log.warn('tarball', `cached data for ${spec} (${opts.integrity}) seems to be corrupted. Refreshing cache.`);\n          return cleanUpCached(opts.cache, opts.integrity, opts).then(() => {\n            throw err;\n          });\n        } else {\n          throw err;\n        }\n      });\n    }\n  });\n  const trySpec = tryDigest.catch(err => {\n    if (!RETRIABLE_ERRORS.has(err.code)) {\n      // If it's not one of our retriable errors, bail out and give up.\n      throw err;\n    } else {\n      opts.log.silly('tarball', `no local data for ${spec}. Extracting by manifest.`);\n      return BB.resolve(retry((tryAgain, attemptNum) => {\n        const tardata = fetch.tarball(spec, opts);\n        if (!opts.resolved) {\n          tardata.on('manifest', m => {\n            opts = opts.concat({\n              resolved: m._resolved\n            });\n          });\n          tardata.on('integrity', i => {\n            opts = opts.concat({\n              integrity: i\n            });\n          });\n        }\n        return BB.try(() => streamHandler(tardata)).catch(err => {\n          // Retry once if we have a cache, to clear up any weird conditions.\n          // Don't retry network errors, though -- make-fetch-happen has already\n          // taken care of making sure we're all set on that front.\n          if (opts.cache && err.code && !String(err.code).match(/^E\\d{3}$/)) {\n            if (err.code === 'EINTEGRITY' || err.code === 'Z_DATA_ERROR') {\n              opts.log.warn('tarball', `tarball data for ${spec} (${opts.integrity}) seems to be corrupted. Trying one more time.`);\n            }\n            return cleanUpCached(opts.cache, err.sri, opts).then(() => tryAgain(err));\n          } else {\n            throw err;\n          }\n        });\n      }, {\n        retries: 1\n      }));\n    }\n  });\n  return trySpec.catch(err => {\n    if (err.code === 'EINTEGRITY') {\n      err.message = `Verification failed while extracting ${spec}:\\n${err.message}`;\n    }\n    throw err;\n  });\n}\nfunction cleanUpCached(cachePath, integrity, opts) {\n  return cacache.rm.content(cachePath, integrity, opts);\n}","map":{"version":3,"names":["BB","require","cacache","fetch","fs","npa","optCheck","path","ssri","retry","statAsync","promisify","stat","RETRIABLE_ERRORS","Set","module","exports","withTarballStream","spec","opts","streamHandler","where","tryFile","preferOnline","integrity","resolved","startsWith","try","log","silly","file","resolve","substr","then","verifier","integrityStream","stream","createReadStream","on","err","emit","pipe","catch","code","warn","verbose","message","reject","Object","assign","Error","tryDigest","cache","has","get","byDigest","once","ev","l","cleanUpCached","trySpec","tryAgain","attemptNum","tardata","tarball","m","concat","_resolved","i","String","match","sri","retries","cachePath","rm","content"],"sources":["/Users/hkateliev/node_modules/npm/node_modules/pacote/lib/with-tarball-stream.js"],"sourcesContent":["'use strict'\n\nconst BB = require('bluebird')\n\nconst cacache = require('cacache')\nconst fetch = require('./fetch.js')\nconst fs = require('fs')\nconst npa = require('npm-package-arg')\nconst optCheck = require('./util/opt-check.js')\nconst path = require('path')\nconst ssri = require('ssri')\nconst retry = require('promise-retry')\n\nconst statAsync = BB.promisify(fs.stat)\n\nconst RETRIABLE_ERRORS = new Set(['ENOENT', 'EINTEGRITY', 'Z_DATA_ERROR'])\n\nmodule.exports = withTarballStream\nfunction withTarballStream (spec, opts, streamHandler) {\n  opts = optCheck(opts)\n  spec = npa(spec, opts.where)\n\n  // First, we check for a file: resolved shortcut\n  const tryFile = (\n    !opts.preferOnline &&\n    opts.integrity &&\n    opts.resolved &&\n    opts.resolved.startsWith('file:')\n  )\n    ? BB.try(() => {\n    // NOTE - this is a special shortcut! Packages installed as files do not\n    // have a `resolved` field -- this specific case only occurs when you have,\n    // say, a git dependency or a registry dependency that you've packaged into\n    // a local file, and put that file: spec in the `resolved` field.\n      opts.log.silly('pacote', `trying ${spec} by local file: ${opts.resolved}`)\n      const file = path.resolve(opts.where || '.', opts.resolved.substr(5))\n      return statAsync(file)\n        .then(() => {\n          const verifier = ssri.integrityStream({ integrity: opts.integrity })\n          const stream = fs.createReadStream(file)\n            .on('error', err => verifier.emit('error', err))\n            .pipe(verifier)\n          return streamHandler(stream)\n        })\n        .catch(err => {\n          if (err.code === 'EINTEGRITY') {\n            opts.log.warn('pacote', `EINTEGRITY while extracting ${spec} from ${file}.You will have to recreate the file.`)\n            opts.log.verbose('pacote', `EINTEGRITY for ${spec}: ${err.message}`)\n          }\n          throw err\n        })\n    })\n    : BB.reject(Object.assign(new Error('no file!'), { code: 'ENOENT' }))\n\n  const tryDigest = tryFile\n    .catch(err => {\n      if (\n        opts.preferOnline ||\n      !opts.cache ||\n      !opts.integrity ||\n      !RETRIABLE_ERRORS.has(err.code)\n      ) {\n        throw err\n      } else {\n        opts.log.silly('tarball', `trying ${spec} by hash: ${opts.integrity}`)\n        const stream = cacache.get.stream.byDigest(\n          opts.cache, opts.integrity, opts\n        )\n        stream.once('error', err => stream.on('newListener', (ev, l) => {\n          if (ev === 'error') { l(err) }\n        }))\n        return streamHandler(stream)\n          .catch(err => {\n            if (err.code === 'EINTEGRITY' || err.code === 'Z_DATA_ERROR') {\n              opts.log.warn('tarball', `cached data for ${spec} (${opts.integrity}) seems to be corrupted. Refreshing cache.`)\n              return cleanUpCached(opts.cache, opts.integrity, opts)\n                .then(() => { throw err })\n            } else {\n              throw err\n            }\n          })\n      }\n    })\n\n  const trySpec = tryDigest\n    .catch(err => {\n      if (!RETRIABLE_ERRORS.has(err.code)) {\n      // If it's not one of our retriable errors, bail out and give up.\n        throw err\n      } else {\n        opts.log.silly(\n          'tarball',\n          `no local data for ${spec}. Extracting by manifest.`\n        )\n        return BB.resolve(retry((tryAgain, attemptNum) => {\n          const tardata = fetch.tarball(spec, opts)\n          if (!opts.resolved) {\n            tardata.on('manifest', m => {\n              opts = opts.concat({ resolved: m._resolved })\n            })\n            tardata.on('integrity', i => {\n              opts = opts.concat({ integrity: i })\n            })\n          }\n          return BB.try(() => streamHandler(tardata))\n            .catch(err => {\n              // Retry once if we have a cache, to clear up any weird conditions.\n              // Don't retry network errors, though -- make-fetch-happen has already\n              // taken care of making sure we're all set on that front.\n              if (opts.cache && err.code && !String(err.code).match(/^E\\d{3}$/)) {\n                if (err.code === 'EINTEGRITY' || err.code === 'Z_DATA_ERROR') {\n                  opts.log.warn('tarball', `tarball data for ${spec} (${opts.integrity}) seems to be corrupted. Trying one more time.`)\n                }\n                return cleanUpCached(opts.cache, err.sri, opts)\n                  .then(() => tryAgain(err))\n              } else {\n                throw err\n              }\n            })\n        }, { retries: 1 }))\n      }\n    })\n\n  return trySpec\n    .catch(err => {\n      if (err.code === 'EINTEGRITY') {\n        err.message = `Verification failed while extracting ${spec}:\\n${err.message}`\n      }\n      throw err\n    })\n}\n\nfunction cleanUpCached (cachePath, integrity, opts) {\n  return cacache.rm.content(cachePath, integrity, opts)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}