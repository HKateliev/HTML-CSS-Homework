{"ast":null,"code":"\"use strict\";\n\nvar wcwidth = require('./width');\n\n/**\n * repeat string `str` up to total length of `len`\n *\n * @param String str string to repeat\n * @param Number len total length of output string\n */\n\nfunction repeatString(str, len) {\n  return Array.apply(null, {\n    length: len + 1\n  }).join(str).slice(0, len);\n}\n\n/**\n * Pad `str` up to total length `max` with `chr`.\n * If `str` is longer than `max`, padRight will return `str` unaltered.\n *\n * @param String str string to pad\n * @param Number max total length of output string\n * @param String chr optional. Character to pad with. default: ' '\n * @return String padded str\n */\n\nfunction padRight(str, max, chr) {\n  str = str != null ? str : '';\n  str = String(str);\n  var length = max - wcwidth(str);\n  if (length <= 0) return str;\n  return str + repeatString(chr || ' ', length);\n}\n\n/**\n * Pad `str` up to total length `max` with `chr`.\n * If `str` is longer than `max`, padCenter will return `str` unaltered.\n *\n * @param String str string to pad\n * @param Number max total length of output string\n * @param String chr optional. Character to pad with. default: ' '\n * @return String padded str\n */\n\nfunction padCenter(str, max, chr) {\n  str = str != null ? str : '';\n  str = String(str);\n  var length = max - wcwidth(str);\n  if (length <= 0) return str;\n  var lengthLeft = Math.floor(length / 2);\n  var lengthRight = length - lengthLeft;\n  return repeatString(chr || ' ', lengthLeft) + str + repeatString(chr || ' ', lengthRight);\n}\n\n/**\n * Pad `str` up to total length `max` with `chr`, on the left.\n * If `str` is longer than `max`, padRight will return `str` unaltered.\n *\n * @param String str string to pad\n * @param Number max total length of output string\n * @param String chr optional. Character to pad with. default: ' '\n * @return String padded str\n */\n\nfunction padLeft(str, max, chr) {\n  str = str != null ? str : '';\n  str = String(str);\n  var length = max - wcwidth(str);\n  if (length <= 0) return str;\n  return repeatString(chr || ' ', length) + str;\n}\n\n/**\n * Split a String `str` into lines of maxiumum length `max`.\n * Splits on word boundaries. Preserves existing new lines.\n *\n * @param String str string to split\n * @param Number max length of each line\n * @return Array Array containing lines.\n */\n\nfunction splitIntoLines(str, max) {\n  function _splitIntoLines(str, max) {\n    return str.trim().split(' ').reduce(function (lines, word) {\n      var line = lines[lines.length - 1];\n      if (line && wcwidth(line.join(' ')) + wcwidth(word) < max) {\n        lines[lines.length - 1].push(word); // add to line\n      } else lines.push([word]); // new line\n      return lines;\n    }, []).map(function (l) {\n      return l.join(' ');\n    });\n  }\n  return str.split('\\n').map(function (str) {\n    return _splitIntoLines(str, max);\n  }).reduce(function (lines, line) {\n    return lines.concat(line);\n  }, []);\n}\n\n/**\n * Add spaces and `truncationChar` between words of\n * `str` which are longer than `max`.\n *\n * @param String str string to split\n * @param Number max length of each line\n * @param Number truncationChar character to append to split words\n * @return String\n */\n\nfunction splitLongWords(str, max, truncationChar) {\n  str = str.trim();\n  var result = [];\n  var words = str.split(' ');\n  var remainder = '';\n  var truncationWidth = wcwidth(truncationChar);\n  while (remainder || words.length) {\n    if (remainder) {\n      var word = remainder;\n      remainder = '';\n    } else {\n      var word = words.shift();\n    }\n    if (wcwidth(word) > max) {\n      // slice is based on length no wcwidth\n      var i = 0;\n      var wwidth = 0;\n      var limit = max - truncationWidth;\n      while (i < word.length) {\n        var w = wcwidth(word.charAt(i));\n        if (w + wwidth > limit) {\n          break;\n        }\n        wwidth += w;\n        ++i;\n      }\n      remainder = word.slice(i); // get remainder\n      // save remainder for next loop\n\n      word = word.slice(0, i); // grab truncated word\n      word += truncationChar; // add trailing … or whatever\n    }\n\n    result.push(word);\n  }\n  return result.join(' ');\n}\n\n/**\n * Truncate `str` into total width `max`\n * If `str` is shorter than `max`,  will return `str` unaltered.\n *\n * @param String str string to truncated\n * @param Number max total wcwidth of output string\n * @return String truncated str\n */\n\nfunction truncateString(str, max) {\n  str = str != null ? str : '';\n  str = String(str);\n  if (max == Infinity) return str;\n  var i = 0;\n  var wwidth = 0;\n  while (i < str.length) {\n    var w = wcwidth(str.charAt(i));\n    if (w + wwidth > max) break;\n    wwidth += w;\n    ++i;\n  }\n  return str.slice(0, i);\n}\n\n/**\n * Exports\n */\n\nmodule.exports.padRight = padRight;\nmodule.exports.padCenter = padCenter;\nmodule.exports.padLeft = padLeft;\nmodule.exports.splitIntoLines = splitIntoLines;\nmodule.exports.splitLongWords = splitLongWords;\nmodule.exports.truncateString = truncateString;","map":{"version":3,"names":["wcwidth","require","repeatString","str","len","Array","apply","length","join","slice","padRight","max","chr","String","padCenter","lengthLeft","Math","floor","lengthRight","padLeft","splitIntoLines","_splitIntoLines","trim","split","reduce","lines","word","line","push","map","l","concat","splitLongWords","truncationChar","result","words","remainder","truncationWidth","shift","i","wwidth","limit","w","charAt","truncateString","Infinity","module","exports"],"sources":["/Users/hkateliev/node_modules/npm/node_modules/columnify/utils.js"],"sourcesContent":["\"use strict\"\n\nvar wcwidth = require('./width')\n\n/**\n * repeat string `str` up to total length of `len`\n *\n * @param String str string to repeat\n * @param Number len total length of output string\n */\n\nfunction repeatString(str, len) {\n  return Array.apply(null, {length: len + 1}).join(str).slice(0, len)\n}\n\n/**\n * Pad `str` up to total length `max` with `chr`.\n * If `str` is longer than `max`, padRight will return `str` unaltered.\n *\n * @param String str string to pad\n * @param Number max total length of output string\n * @param String chr optional. Character to pad with. default: ' '\n * @return String padded str\n */\n\nfunction padRight(str, max, chr) {\n  str = str != null ? str : ''\n  str = String(str)\n  var length = max - wcwidth(str)\n  if (length <= 0) return str\n  return str + repeatString(chr || ' ', length)\n}\n\n/**\n * Pad `str` up to total length `max` with `chr`.\n * If `str` is longer than `max`, padCenter will return `str` unaltered.\n *\n * @param String str string to pad\n * @param Number max total length of output string\n * @param String chr optional. Character to pad with. default: ' '\n * @return String padded str\n */\n\nfunction padCenter(str, max, chr) {\n  str = str != null ? str : ''\n  str = String(str)\n  var length = max - wcwidth(str)\n  if (length <= 0) return str\n  var lengthLeft = Math.floor(length/2)\n  var lengthRight = length - lengthLeft\n  return repeatString(chr || ' ', lengthLeft) + str + repeatString(chr || ' ', lengthRight)\n}\n\n/**\n * Pad `str` up to total length `max` with `chr`, on the left.\n * If `str` is longer than `max`, padRight will return `str` unaltered.\n *\n * @param String str string to pad\n * @param Number max total length of output string\n * @param String chr optional. Character to pad with. default: ' '\n * @return String padded str\n */\n\nfunction padLeft(str, max, chr) {\n  str = str != null ? str : ''\n  str = String(str)\n  var length = max - wcwidth(str)\n  if (length <= 0) return str\n  return repeatString(chr || ' ', length) + str\n}\n\n/**\n * Split a String `str` into lines of maxiumum length `max`.\n * Splits on word boundaries. Preserves existing new lines.\n *\n * @param String str string to split\n * @param Number max length of each line\n * @return Array Array containing lines.\n */\n\nfunction splitIntoLines(str, max) {\n  function _splitIntoLines(str, max) {\n    return str.trim().split(' ').reduce(function(lines, word) {\n      var line = lines[lines.length - 1]\n      if (line && wcwidth(line.join(' ')) + wcwidth(word) < max) {\n        lines[lines.length - 1].push(word) // add to line\n      }\n      else lines.push([word]) // new line\n      return lines\n    }, []).map(function(l) {\n      return l.join(' ')\n    })\n  }\n  return str.split('\\n').map(function(str) {\n    return _splitIntoLines(str, max)\n  }).reduce(function(lines, line) {\n    return lines.concat(line)\n  }, [])\n}\n\n/**\n * Add spaces and `truncationChar` between words of\n * `str` which are longer than `max`.\n *\n * @param String str string to split\n * @param Number max length of each line\n * @param Number truncationChar character to append to split words\n * @return String\n */\n\nfunction splitLongWords(str, max, truncationChar) {\n  str = str.trim()\n  var result = []\n  var words = str.split(' ')\n  var remainder = ''\n\n  var truncationWidth = wcwidth(truncationChar)\n\n  while (remainder || words.length) {\n    if (remainder) {\n      var word = remainder\n      remainder = ''\n    } else {\n      var word = words.shift()\n    }\n\n    if (wcwidth(word) > max) {\n      // slice is based on length no wcwidth\n      var i = 0\n      var wwidth = 0\n      var limit = max - truncationWidth\n      while (i < word.length) {\n        var w = wcwidth(word.charAt(i))\n        if (w + wwidth > limit) {\n          break\n        }\n        wwidth += w\n        ++i\n      }\n\n      remainder = word.slice(i) // get remainder\n      // save remainder for next loop\n\n      word = word.slice(0, i) // grab truncated word\n      word += truncationChar // add trailing … or whatever\n    }\n    result.push(word)\n  }\n\n  return result.join(' ')\n}\n\n\n/**\n * Truncate `str` into total width `max`\n * If `str` is shorter than `max`,  will return `str` unaltered.\n *\n * @param String str string to truncated\n * @param Number max total wcwidth of output string\n * @return String truncated str\n */\n\nfunction truncateString(str, max) {\n\n  str = str != null ? str : ''\n  str = String(str)\n\n  if(max == Infinity) return str\n\n  var i = 0\n  var wwidth = 0\n  while (i < str.length) {\n    var w = wcwidth(str.charAt(i))\n    if(w + wwidth > max)\n      break\n    wwidth += w\n    ++i\n  }\n  return str.slice(0, i)\n}\n\n\n\n/**\n * Exports\n */\n\nmodule.exports.padRight = padRight\nmodule.exports.padCenter = padCenter\nmodule.exports.padLeft = padLeft\nmodule.exports.splitIntoLines = splitIntoLines\nmodule.exports.splitLongWords = splitLongWords\nmodule.exports.truncateString = truncateString\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}