{"ast":null,"code":"'use strict';\n\nconst defaultMaxRunning = 50;\nconst limit = module.exports = function (func, maxRunning) {\n  const state = {\n    running: 0,\n    queue: []\n  };\n  if (!maxRunning) maxRunning = defaultMaxRunning;\n  return function limited() {\n    const args = Array.prototype.slice.call(arguments);\n    if (state.running >= maxRunning) {\n      state.queue.push({\n        obj: this,\n        args\n      });\n    } else {\n      callFunc(this, args);\n    }\n  };\n  function callNext() {\n    if (state.queue.length === 0) return;\n    const next = state.queue.shift();\n    callFunc(next.obj, next.args);\n  }\n  function callFunc(obj, args) {\n    const cb = typeof args[args.length - 1] === 'function' && args.pop();\n    try {\n      ++state.running;\n      func.apply(obj, args.concat(function () {\n        --state.running;\n        process.nextTick(callNext);\n        if (cb) process.nextTick(() => cb.apply(obj, arguments));\n      }));\n    } catch (err) {\n      --state.running;\n      if (cb) process.nextTick(() => cb.call(obj, err));\n      process.nextTick(callNext);\n    }\n  }\n};\nmodule.exports.method = function (classOrObj, method, maxRunning) {\n  if (typeof classOrObj === 'function') {\n    const func = classOrObj.prototype[method];\n    classOrObj.prototype[method] = limit(func, maxRunning);\n  } else {\n    const func = classOrObj[method];\n    classOrObj[method] = limit(func, maxRunning);\n  }\n};\nmodule.exports.promise = function (func, maxRunning) {\n  const state = {\n    running: 0,\n    queue: []\n  };\n  if (!maxRunning) maxRunning = defaultMaxRunning;\n  return function limited() {\n    const args = Array.prototype.slice.call(arguments);\n    if (state.running >= maxRunning) {\n      return new Promise(resolve => {\n        state.queue.push({\n          resolve,\n          obj: this,\n          args\n        });\n      });\n    } else {\n      return callFunc(this, args);\n    }\n  };\n  function callNext() {\n    if (state.queue.length === 0) return;\n    const next = state.queue.shift();\n    next.resolve(callFunc(next.obj, next.args));\n  }\n  function callFunc(obj, args) {\n    return callFinally(() => {\n      ++state.running;\n      return func.apply(obj, args);\n    }, () => {\n      --state.running;\n      process.nextTick(callNext);\n    });\n  }\n  function callFinally(action, fin) {\n    try {\n      return Promise.resolve(action()).then(value => {\n        fin();\n        return value;\n      }, err => {\n        fin();\n        return Promise.reject(err);\n      });\n    } catch (err) {\n      fin();\n      return Promise.reject(err);\n    }\n  }\n};\nmodule.exports.promise.method = function (classOrObj, method, maxRunning) {\n  if (typeof classOrObj === 'function') {\n    const func = classOrObj.prototype[method];\n    classOrObj.prototype[method] = limit.promise(func, maxRunning);\n  } else {\n    const func = classOrObj[method];\n    classOrObj[method] = limit.promise(func, maxRunning);\n  }\n};","map":{"version":3,"names":["defaultMaxRunning","limit","module","exports","func","maxRunning","state","running","queue","limited","args","Array","prototype","slice","call","arguments","push","obj","callFunc","callNext","length","next","shift","cb","pop","apply","concat","process","nextTick","err","method","classOrObj","promise","Promise","resolve","callFinally","action","fin","then","value","reject"],"sources":["/Users/hkateliev/node_modules/npm/node_modules/call-limit/call-limit.js"],"sourcesContent":["'use strict'\n\nconst defaultMaxRunning = 50\n\nconst limit = module.exports = function (func, maxRunning) {\n  const state = {running: 0, queue: []}\n  if (!maxRunning) maxRunning = defaultMaxRunning\n  return function limited () {\n    const args = Array.prototype.slice.call(arguments)\n    if (state.running >= maxRunning) {\n      state.queue.push({obj: this, args})\n    } else {\n      callFunc(this, args)\n    }\n  }\n  function callNext () {\n    if (state.queue.length === 0) return\n    const next = state.queue.shift()\n    callFunc(next.obj, next.args)\n  }\n  function callFunc (obj, args) {\n    const cb = typeof args[args.length - 1] === 'function' && args.pop()\n    try {\n      ++state.running\n      func.apply(obj, args.concat(function () {\n        --state.running\n        process.nextTick(callNext)\n        if (cb) process.nextTick(() => cb.apply(obj, arguments))\n      }))\n    } catch (err) {\n      --state.running\n      if (cb) process.nextTick(() => cb.call(obj, err))\n      process.nextTick(callNext)\n    }\n  }\n}\n\nmodule.exports.method = function (classOrObj, method, maxRunning) {\n  if (typeof classOrObj === 'function') {\n    const func = classOrObj.prototype[method]\n    classOrObj.prototype[method] = limit(func, maxRunning)\n  } else {\n    const func = classOrObj[method]\n    classOrObj[method] = limit(func, maxRunning)\n  }\n}\n\nmodule.exports.promise = function (func, maxRunning) {\n  const state = {running: 0, queue: []}\n  if (!maxRunning) maxRunning = defaultMaxRunning\n  return function limited () {\n    const args = Array.prototype.slice.call(arguments)\n    if (state.running >= maxRunning) {\n      return new Promise(resolve => {\n        state.queue.push({resolve, obj: this, args})\n      })\n    } else {\n      return callFunc(this, args)\n    }\n  }\n  function callNext () {\n    if (state.queue.length === 0) return\n    const next = state.queue.shift()\n    next.resolve(callFunc(next.obj, next.args))\n  }\n  function callFunc (obj, args) {\n    return callFinally(() => {\n      ++state.running\n      return func.apply(obj, args)\n    }, () => {\n      --state.running\n      process.nextTick(callNext)\n    })\n  }\n  function callFinally (action, fin) {\n    try {\n      return Promise.resolve(action()).then(value => {\n        fin()\n        return value\n      }, err => {\n        fin()\n        return Promise.reject(err)\n      })\n    } catch (err) {\n      fin()\n      return Promise.reject(err)\n    }\n  }\n}\n\nmodule.exports.promise.method = function (classOrObj, method, maxRunning) {\n  if (typeof classOrObj === 'function') {\n    const func = classOrObj.prototype[method]\n    classOrObj.prototype[method] = limit.promise(func, maxRunning)\n  } else {\n    const func = classOrObj[method]\n    classOrObj[method] = limit.promise(func, maxRunning)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}