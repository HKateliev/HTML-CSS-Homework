{"ast":null,"code":"'use strict';\n\nconst BB = require('bluebird');\nconst cacache = require('cacache');\nconst cacheKey = require('./util/cache-key');\nconst fetchFromManifest = require('./fetch').fromManifest;\nconst finished = require('./util/finished');\nconst minimatch = require('minimatch');\nconst normalize = require('normalize-package-data');\nconst optCheck = require('./util/opt-check');\nconst path = require('path');\nconst pipe = BB.promisify(require('mississippi').pipe);\nconst ssri = require('ssri');\nconst tar = require('tar');\nconst readJson = require('./util/read-json');\nconst normalizePackageBin = require('npm-normalize-package-bin');\n\n// `finalizeManifest` takes as input the various kinds of manifests that\n// manifest handlers ('lib/fetchers/*.js#manifest()') return, and makes sure\n// they are:\n//\n// * filled out with any required data that the handler couldn't fill in\n// * formatted consistently\n// * cached so we don't have to repeat this work more than necessary\n//\n// The biggest thing this package might do is do a full tarball extraction in\n// order to find missing bits of metadata required by the npm installer. For\n// example, it will fill in `_shrinkwrap`, `_integrity`, and other details that\n// the plain manifest handlers would require a tarball to fill out. If a\n// handler returns everything necessary, this process is skipped.\n//\n// If we get to the tarball phase, the corresponding tarball handler for the\n// requested type will be invoked and the entire tarball will be read from the\n// stream.\n//\nmodule.exports = finalizeManifest;\nfunction finalizeManifest(pkg, spec, opts) {\n  const key = finalKey(pkg, spec);\n  opts = optCheck(opts);\n  const cachedManifest = opts.cache && key && !opts.preferOnline && !opts.fullMetadata && !opts.enjoyBy ? cacache.get.info(opts.cache, key, opts) : BB.resolve(null);\n  return cachedManifest.then(cached => {\n    if (cached && cached.metadata && cached.metadata.manifest) {\n      return new Manifest(cached.metadata.manifest);\n    } else {\n      return tarballedProps(pkg, spec, opts).then(props => {\n        return pkg && pkg.name ? new Manifest(pkg, props, opts.fullMetadata) : new Manifest(props, null, opts.fullMetadata);\n      }).then(manifest => {\n        const cacheKey = key || finalKey(manifest, spec);\n        if (!opts.cache || !cacheKey) {\n          return manifest;\n        } else {\n          return cacache.put(opts.cache, cacheKey, '.', {\n            metadata: {\n              id: manifest._id,\n              manifest,\n              type: 'finalized-manifest'\n            }\n          }).then(() => manifest);\n        }\n      });\n    }\n  });\n}\nmodule.exports.Manifest = Manifest;\nfunction Manifest(pkg, fromTarball, fullMetadata) {\n  fromTarball = fromTarball || {};\n  if (fullMetadata) {\n    Object.assign(this, pkg);\n  }\n  this.name = pkg.name;\n  this.version = pkg.version;\n  this.engines = pkg.engines || fromTarball.engines;\n  this.cpu = pkg.cpu || fromTarball.cpu;\n  this.os = pkg.os || fromTarball.os;\n  this.dependencies = pkg.dependencies || {};\n  this.optionalDependencies = pkg.optionalDependencies || {};\n  this.peerDependenciesMeta = pkg.peerDependenciesMeta || {};\n  this.devDependencies = pkg.devDependencies || {};\n  const bundled = pkg.bundledDependencies || pkg.bundleDependencies || false;\n  this.bundleDependencies = bundled;\n  this.peerDependencies = pkg.peerDependencies || {};\n  this.deprecated = pkg.deprecated || false;\n\n  // These depend entirely on each handler\n  this._resolved = pkg._resolved;\n\n  // Not all handlers (or registries) provide these out of the box,\n  // and if they don't, we need to extract and read the tarball ourselves.\n  // These are details required by the installer.\n  this._integrity = pkg._integrity || fromTarball._integrity || null;\n  this._shasum = pkg._shasum || fromTarball._shasum || null;\n  this._shrinkwrap = pkg._shrinkwrap || fromTarball._shrinkwrap || null;\n  this.bin = pkg.bin || fromTarball.bin || null;\n\n  // turn arrays and strings into a legit object, strip out bad stuff\n  normalizePackageBin(this);\n  this._id = null;\n\n  // TODO - freezing and inextensibility pending npm changes. See test suite.\n  // Object.preventExtensions(this)\n  normalize(this);\n\n  // I don't want this why did you give it to me. Go away. ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥\n  delete this.readme;\n\n  // Object.freeze(this)\n}\n\n// Some things aren't filled in by standard manifest fetching.\n// If this function needs to do its work, it will grab the\n// package tarball, extract it, and take whatever it needs\n// from the stream.\nfunction tarballedProps(pkg, spec, opts) {\n  const needsShrinkwrap = !pkg || pkg._hasShrinkwrap !== false && !pkg._shrinkwrap;\n  const needsBin = !!(!pkg || !pkg.bin && pkg.directories && pkg.directories.bin);\n  const needsIntegrity = !pkg || !pkg._integrity && pkg._integrity !== false;\n  const needsShasum = !pkg || !pkg._shasum && pkg._shasum !== false;\n  const needsHash = needsIntegrity || needsShasum;\n  const needsManifest = !pkg || !pkg.name;\n  const needsExtract = needsShrinkwrap || needsBin || needsManifest;\n  if (!needsShrinkwrap && !needsBin && !needsHash && !needsManifest) {\n    return BB.resolve({});\n  } else {\n    opts = optCheck(opts);\n    const tarStream = fetchFromManifest(pkg, spec, opts);\n    const extracted = needsExtract && new tar.Parse();\n    return BB.join(needsShrinkwrap && jsonFromStream('npm-shrinkwrap.json', extracted), needsManifest && jsonFromStream('package.json', extracted), needsBin && getPaths(extracted), needsHash && ssri.fromStream(tarStream, {\n      algorithms: ['sha1', 'sha512']\n    }), needsExtract && pipe(tarStream, extracted), (sr, mani, paths, hash) => {\n      if (needsManifest && !mani) {\n        const err = new Error(`Non-registry package missing package.json: ${spec}.`);\n        err.code = 'ENOPACKAGEJSON';\n        throw err;\n      }\n      const extraProps = mani || {};\n      delete extraProps._resolved;\n      // drain out the rest of the tarball\n      tarStream.resume();\n      // if we have directories.bin, we need to collect any matching files\n      // to add to bin\n      if (paths && paths.length) {\n        const dirBin = mani ? mani && mani.directories && mani.directories.bin : pkg && pkg.directories && pkg.directories.bin;\n        if (dirBin) {\n          extraProps.bin = {};\n          paths.forEach(filePath => {\n            if (minimatch(filePath, dirBin + '/**')) {\n              const relative = path.relative(dirBin, filePath);\n              if (relative && relative[0] !== '.') {\n                extraProps.bin[path.basename(relative)] = path.join(dirBin, relative);\n              }\n            }\n          });\n        }\n      }\n      return Object.assign(extraProps, {\n        _shrinkwrap: sr,\n        _resolved: mani && mani._resolved || pkg && pkg._resolved || spec.fetchSpec,\n        _integrity: needsIntegrity && hash && hash.sha512 && hash.sha512[0].toString(),\n        _shasum: needsShasum && hash && hash.sha1 && hash.sha1[0].hexDigest()\n      });\n    });\n  }\n}\nfunction jsonFromStream(filename, dataStream) {\n  return BB.fromNode(cb => {\n    dataStream.on('error', cb);\n    dataStream.on('close', cb);\n    dataStream.on('entry', entry => {\n      const filePath = entry.header.path.replace(/[^/]+\\//, '');\n      if (filePath !== filename) {\n        entry.resume();\n      } else {\n        let data = '';\n        entry.on('error', cb);\n        finished(entry).then(() => {\n          try {\n            cb(null, readJson(data));\n          } catch (err) {\n            cb(err);\n          }\n        }, err => {\n          cb(err);\n        });\n        entry.on('data', d => {\n          data += d;\n        });\n      }\n    });\n  });\n}\nfunction getPaths(dataStream) {\n  return BB.fromNode(cb => {\n    let paths = [];\n    dataStream.on('error', cb);\n    dataStream.on('close', () => cb(null, paths));\n    dataStream.on('entry', function handler(entry) {\n      const filePath = entry.header.path.replace(/[^/]+\\//, '');\n      entry.resume();\n      paths.push(filePath);\n    });\n  });\n}\nfunction finalKey(pkg, spec) {\n  if (pkg && pkg._uniqueResolved) {\n    // git packages have a unique, identifiable id, but no tar sha\n    return cacheKey(`${spec.type}-manifest`, pkg._uniqueResolved);\n  } else {\n    return pkg && pkg._integrity && cacheKey(`${spec.type}-manifest`, `${pkg._resolved}:${ssri.stringify(pkg._integrity)}`);\n  }\n}","map":{"version":3,"names":["BB","require","cacache","cacheKey","fetchFromManifest","fromManifest","finished","minimatch","normalize","optCheck","path","pipe","promisify","ssri","tar","readJson","normalizePackageBin","module","exports","finalizeManifest","pkg","spec","opts","key","finalKey","cachedManifest","cache","preferOnline","fullMetadata","enjoyBy","get","info","resolve","then","cached","metadata","manifest","Manifest","tarballedProps","props","name","put","id","_id","type","fromTarball","Object","assign","version","engines","cpu","os","dependencies","optionalDependencies","peerDependenciesMeta","devDependencies","bundled","bundledDependencies","bundleDependencies","peerDependencies","deprecated","_resolved","_integrity","_shasum","_shrinkwrap","bin","readme","needsShrinkwrap","_hasShrinkwrap","needsBin","directories","needsIntegrity","needsShasum","needsHash","needsManifest","needsExtract","tarStream","extracted","Parse","join","jsonFromStream","getPaths","fromStream","algorithms","sr","mani","paths","hash","err","Error","code","extraProps","resume","length","dirBin","forEach","filePath","relative","basename","fetchSpec","sha512","toString","sha1","hexDigest","filename","dataStream","fromNode","cb","on","entry","header","replace","data","d","handler","push","_uniqueResolved","stringify"],"sources":["/Users/hkateliev/node_modules/npm/node_modules/pacote/lib/finalize-manifest.js"],"sourcesContent":["'use strict'\n\nconst BB = require('bluebird')\n\nconst cacache = require('cacache')\nconst cacheKey = require('./util/cache-key')\nconst fetchFromManifest = require('./fetch').fromManifest\nconst finished = require('./util/finished')\nconst minimatch = require('minimatch')\nconst normalize = require('normalize-package-data')\nconst optCheck = require('./util/opt-check')\nconst path = require('path')\nconst pipe = BB.promisify(require('mississippi').pipe)\nconst ssri = require('ssri')\nconst tar = require('tar')\nconst readJson = require('./util/read-json')\nconst normalizePackageBin = require('npm-normalize-package-bin')\n\n// `finalizeManifest` takes as input the various kinds of manifests that\n// manifest handlers ('lib/fetchers/*.js#manifest()') return, and makes sure\n// they are:\n//\n// * filled out with any required data that the handler couldn't fill in\n// * formatted consistently\n// * cached so we don't have to repeat this work more than necessary\n//\n// The biggest thing this package might do is do a full tarball extraction in\n// order to find missing bits of metadata required by the npm installer. For\n// example, it will fill in `_shrinkwrap`, `_integrity`, and other details that\n// the plain manifest handlers would require a tarball to fill out. If a\n// handler returns everything necessary, this process is skipped.\n//\n// If we get to the tarball phase, the corresponding tarball handler for the\n// requested type will be invoked and the entire tarball will be read from the\n// stream.\n//\nmodule.exports = finalizeManifest\nfunction finalizeManifest (pkg, spec, opts) {\n  const key = finalKey(pkg, spec)\n  opts = optCheck(opts)\n\n  const cachedManifest = (opts.cache && key && !opts.preferOnline && !opts.fullMetadata && !opts.enjoyBy)\n    ? cacache.get.info(opts.cache, key, opts)\n    : BB.resolve(null)\n\n  return cachedManifest.then(cached => {\n    if (cached && cached.metadata && cached.metadata.manifest) {\n      return new Manifest(cached.metadata.manifest)\n    } else {\n      return tarballedProps(pkg, spec, opts).then(props => {\n        return pkg && pkg.name\n          ? new Manifest(pkg, props, opts.fullMetadata)\n          : new Manifest(props, null, opts.fullMetadata)\n      }).then(manifest => {\n        const cacheKey = key || finalKey(manifest, spec)\n        if (!opts.cache || !cacheKey) {\n          return manifest\n        } else {\n          return cacache.put(\n            opts.cache, cacheKey, '.', {\n              metadata: {\n                id: manifest._id,\n                manifest,\n                type: 'finalized-manifest'\n              }\n            }\n          ).then(() => manifest)\n        }\n      })\n    }\n  })\n}\n\nmodule.exports.Manifest = Manifest\nfunction Manifest (pkg, fromTarball, fullMetadata) {\n  fromTarball = fromTarball || {}\n  if (fullMetadata) {\n    Object.assign(this, pkg)\n  }\n  this.name = pkg.name\n  this.version = pkg.version\n  this.engines = pkg.engines || fromTarball.engines\n  this.cpu = pkg.cpu || fromTarball.cpu\n  this.os = pkg.os || fromTarball.os\n  this.dependencies = pkg.dependencies || {}\n  this.optionalDependencies = pkg.optionalDependencies || {}\n  this.peerDependenciesMeta = pkg.peerDependenciesMeta || {}\n  this.devDependencies = pkg.devDependencies || {}\n  const bundled = (\n    pkg.bundledDependencies ||\n    pkg.bundleDependencies ||\n    false\n  )\n  this.bundleDependencies = bundled\n  this.peerDependencies = pkg.peerDependencies || {}\n  this.deprecated = pkg.deprecated || false\n\n  // These depend entirely on each handler\n  this._resolved = pkg._resolved\n\n  // Not all handlers (or registries) provide these out of the box,\n  // and if they don't, we need to extract and read the tarball ourselves.\n  // These are details required by the installer.\n  this._integrity = pkg._integrity || fromTarball._integrity || null\n  this._shasum = pkg._shasum || fromTarball._shasum || null\n  this._shrinkwrap = pkg._shrinkwrap || fromTarball._shrinkwrap || null\n  this.bin = pkg.bin || fromTarball.bin || null\n\n  // turn arrays and strings into a legit object, strip out bad stuff\n  normalizePackageBin(this)\n\n  this._id = null\n\n  // TODO - freezing and inextensibility pending npm changes. See test suite.\n  // Object.preventExtensions(this)\n  normalize(this)\n\n  // I don't want this why did you give it to me. Go away. ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥\n  delete this.readme\n\n  // Object.freeze(this)\n}\n\n// Some things aren't filled in by standard manifest fetching.\n// If this function needs to do its work, it will grab the\n// package tarball, extract it, and take whatever it needs\n// from the stream.\nfunction tarballedProps (pkg, spec, opts) {\n  const needsShrinkwrap = (!pkg || (\n    pkg._hasShrinkwrap !== false &&\n    !pkg._shrinkwrap\n  ))\n  const needsBin = !!(!pkg || (\n    !pkg.bin &&\n    pkg.directories &&\n    pkg.directories.bin\n  ))\n  const needsIntegrity = !pkg || (!pkg._integrity && pkg._integrity !== false)\n  const needsShasum = !pkg || (!pkg._shasum && pkg._shasum !== false)\n  const needsHash = needsIntegrity || needsShasum\n  const needsManifest = !pkg || !pkg.name\n  const needsExtract = needsShrinkwrap || needsBin || needsManifest\n  if (!needsShrinkwrap && !needsBin && !needsHash && !needsManifest) {\n    return BB.resolve({})\n  } else {\n    opts = optCheck(opts)\n    const tarStream = fetchFromManifest(pkg, spec, opts)\n    const extracted = needsExtract && new tar.Parse()\n    return BB.join(\n      needsShrinkwrap && jsonFromStream('npm-shrinkwrap.json', extracted),\n      needsManifest && jsonFromStream('package.json', extracted),\n      needsBin && getPaths(extracted),\n      needsHash && ssri.fromStream(tarStream, { algorithms: ['sha1', 'sha512'] }),\n      needsExtract && pipe(tarStream, extracted),\n      (sr, mani, paths, hash) => {\n        if (needsManifest && !mani) {\n          const err = new Error(`Non-registry package missing package.json: ${spec}.`)\n          err.code = 'ENOPACKAGEJSON'\n          throw err\n        }\n        const extraProps = mani || {}\n        delete extraProps._resolved\n        // drain out the rest of the tarball\n        tarStream.resume()\n        // if we have directories.bin, we need to collect any matching files\n        // to add to bin\n        if (paths && paths.length) {\n          const dirBin = mani\n            ? (mani && mani.directories && mani.directories.bin)\n            : (pkg && pkg.directories && pkg.directories.bin)\n          if (dirBin) {\n            extraProps.bin = {}\n            paths.forEach(filePath => {\n              if (minimatch(filePath, dirBin + '/**')) {\n                const relative = path.relative(dirBin, filePath)\n                if (relative && relative[0] !== '.') {\n                  extraProps.bin[path.basename(relative)] = path.join(dirBin, relative)\n                }\n              }\n            })\n          }\n        }\n        return Object.assign(extraProps, {\n          _shrinkwrap: sr,\n          _resolved: (mani && mani._resolved) ||\n          (pkg && pkg._resolved) ||\n          spec.fetchSpec,\n          _integrity: needsIntegrity && hash && hash.sha512 && hash.sha512[0].toString(),\n          _shasum: needsShasum && hash && hash.sha1 && hash.sha1[0].hexDigest()\n        })\n      }\n    )\n  }\n}\n\nfunction jsonFromStream (filename, dataStream) {\n  return BB.fromNode(cb => {\n    dataStream.on('error', cb)\n    dataStream.on('close', cb)\n    dataStream.on('entry', entry => {\n      const filePath = entry.header.path.replace(/[^/]+\\//, '')\n      if (filePath !== filename) {\n        entry.resume()\n      } else {\n        let data = ''\n        entry.on('error', cb)\n        finished(entry).then(() => {\n          try {\n            cb(null, readJson(data))\n          } catch (err) {\n            cb(err)\n          }\n        }, err => {\n          cb(err)\n        })\n        entry.on('data', d => { data += d })\n      }\n    })\n  })\n}\n\nfunction getPaths (dataStream) {\n  return BB.fromNode(cb => {\n    let paths = []\n    dataStream.on('error', cb)\n    dataStream.on('close', () => cb(null, paths))\n    dataStream.on('entry', function handler (entry) {\n      const filePath = entry.header.path.replace(/[^/]+\\//, '')\n      entry.resume()\n      paths.push(filePath)\n    })\n  })\n}\n\nfunction finalKey (pkg, spec) {\n  if (pkg && pkg._uniqueResolved) {\n    // git packages have a unique, identifiable id, but no tar sha\n    return cacheKey(`${spec.type}-manifest`, pkg._uniqueResolved)\n  } else {\n    return (\n      pkg && pkg._integrity &&\n      cacheKey(\n        `${spec.type}-manifest`,\n        `${pkg._resolved}:${ssri.stringify(pkg._integrity)}`\n      )\n    )\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}